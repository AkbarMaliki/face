(self["webpackChunkbackend_faceapi"]=self["webpackChunkbackend_faceapi"]||[]).push([[998],{9662:function(e,t,n){var r=n(614),a=n(6330),s=TypeError;e.exports=function(e){if(r(e))return e;throw s(a(e)+" is not a function")}},6077:function(e,t,n){var r=n(614),a=String,s=TypeError;e.exports=function(e){if("object"==typeof e||r(e))return e;throw s("Can't set "+a(e)+" as a prototype")}},5787:function(e,t,n){var r=n(7976),a=TypeError;e.exports=function(e,t){if(r(t,e))return e;throw a("Incorrect invocation")}},9670:function(e,t,n){var r=n(111),a=String,s=TypeError;e.exports=function(e){if(r(e))return e;throw s(a(e)+" is not an object")}},3013:function(e){e.exports="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof DataView},260:function(e,t,n){"use strict";var r,a,s,i=n(3013),o=n(9781),l=n(7854),u=n(614),p=n(111),c=n(2597),d=n(648),h=n(6330),f=n(8880),m=n(8052),g=n(7045),y=n(7976),b=n(9518),x=n(7674),v=n(5112),w=n(9711),k=n(9909),I=k.enforce,S=k.get,N=l.Int8Array,T=N&&N.prototype,_=l.Uint8ClampedArray,C=_&&_.prototype,E=N&&b(N),A=T&&b(T),$=Object.prototype,R=l.TypeError,F=v("toStringTag"),D=w("TYPED_ARRAY_TAG"),M="TypedArrayConstructor",O=i&&!!x&&"Opera"!==d(l.opera),P=!1,L={Int8Array:1,Uint8Array:1,Uint8ClampedArray:1,Int16Array:2,Uint16Array:2,Int32Array:4,Uint32Array:4,Float32Array:4,Float64Array:8},z={BigInt64Array:8,BigUint64Array:8},B=function(e){if(!p(e))return!1;var t=d(e);return"DataView"===t||c(L,t)||c(z,t)},W=function(e){var t=b(e);if(p(t)){var n=S(t);return n&&c(n,M)?n[M]:W(t)}},U=function(e){if(!p(e))return!1;var t=d(e);return c(L,t)||c(z,t)},V=function(e){if(U(e))return e;throw R("Target is not a typed array")},G=function(e){if(u(e)&&(!x||y(E,e)))return e;throw R(h(e)+" is not a typed array constructor")},H=function(e,t,n,r){if(o){if(n)for(var a in L){var s=l[a];if(s&&c(s.prototype,e))try{delete s.prototype[e]}catch(i){try{s.prototype[e]=t}catch(u){}}}A[e]&&!n||m(A,e,n?t:O&&T[e]||t,r)}},j=function(e,t,n){var r,a;if(o){if(x){if(n)for(r in L)if(a=l[r],a&&c(a,e))try{delete a[e]}catch(s){}if(E[e]&&!n)return;try{return m(E,e,n?t:O&&E[e]||t)}catch(s){}}for(r in L)a=l[r],!a||a[e]&&!n||m(a,e,t)}};for(r in L)a=l[r],s=a&&a.prototype,s?I(s)[M]=a:O=!1;for(r in z)a=l[r],s=a&&a.prototype,s&&(I(s)[M]=a);if((!O||!u(E)||E===Function.prototype)&&(E=function(){throw R("Incorrect invocation")},O))for(r in L)l[r]&&x(l[r],E);if((!O||!A||A===$)&&(A=E.prototype,O))for(r in L)l[r]&&x(l[r].prototype,A);if(O&&b(C)!==A&&x(C,A),o&&!c(A,F))for(r in P=!0,g(A,F,{configurable:!0,get:function(){return p(this)?this[D]:void 0}}),L)l[r]&&f(l[r],D,r);e.exports={NATIVE_ARRAY_BUFFER_VIEWS:O,TYPED_ARRAY_TAG:P&&D,aTypedArray:V,aTypedArrayConstructor:G,exportTypedArrayMethod:H,exportTypedArrayStaticMethod:j,getTypedArrayConstructor:W,isView:B,isTypedArray:U,TypedArray:E,TypedArrayPrototype:A}},7745:function(e,t,n){var r=n(6244);e.exports=function(e,t){var n=0,a=r(t),s=new e(a);while(a>n)s[n]=t[n++];return s}},1318:function(e,t,n){var r=n(5656),a=n(1400),s=n(6244),i=function(e){return function(t,n,i){var o,l=r(t),u=s(l),p=a(i,u);if(e&&n!=n){while(u>p)if(o=l[p++],o!=o)return!0}else for(;u>p;p++)if((e||p in l)&&l[p]===n)return e||p||0;return!e&&-1}};e.exports={includes:i(!0),indexOf:i(!1)}},3658:function(e,t,n){"use strict";var r=n(9781),a=n(3157),s=TypeError,i=Object.getOwnPropertyDescriptor,o=r&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(e){return e instanceof TypeError}}();e.exports=o?function(e,t){if(a(e)&&!i(e,"length").writable)throw s("Cannot set read only .length");return e.length=t}:function(e,t){return e.length=t}},206:function(e,t,n){var r=n(1702);e.exports=r([].slice)},1843:function(e,t,n){var r=n(6244);e.exports=function(e,t){for(var n=r(e),a=new t(n),s=0;s<n;s++)a[s]=e[n-s-1];return a}},1572:function(e,t,n){var r=n(6244),a=n(9303),s=RangeError;e.exports=function(e,t,n,i){var o=r(e),l=a(n),u=l<0?o+l:l;if(u>=o||u<0)throw s("Incorrect index");for(var p=new t(o),c=0;c<o;c++)p[c]=c===u?i:e[c];return p}},4326:function(e,t,n){var r=n(1702),a=r({}.toString),s=r("".slice);e.exports=function(e){return s(a(e),8,-1)}},648:function(e,t,n){var r=n(1694),a=n(614),s=n(4326),i=n(5112),o=i("toStringTag"),l=Object,u="Arguments"==s(function(){return arguments}()),p=function(e,t){try{return e[t]}catch(n){}};e.exports=r?s:function(e){var t,n,r;return void 0===e?"Undefined":null===e?"Null":"string"==typeof(n=p(t=l(e),o))?n:u?s(t):"Object"==(r=s(t))&&a(t.callee)?"Arguments":r}},9920:function(e,t,n){var r=n(2597),a=n(3887),s=n(1236),i=n(3070);e.exports=function(e,t,n){for(var o=a(t),l=i.f,u=s.f,p=0;p<o.length;p++){var c=o[p];r(e,c)||n&&r(n,c)||l(e,c,u(t,c))}}},8544:function(e,t,n){var r=n(7293);e.exports=!r((function(){function e(){}return e.prototype.constructor=null,Object.getPrototypeOf(new e)!==e.prototype}))},8880:function(e,t,n){var r=n(9781),a=n(3070),s=n(9114);e.exports=r?function(e,t,n){return a.f(e,t,s(1,n))}:function(e,t,n){return e[t]=n,e}},9114:function(e){e.exports=function(e,t){return{enumerable:!(1&e),configurable:!(2&e),writable:!(4&e),value:t}}},7045:function(e,t,n){var r=n(6339),a=n(3070);e.exports=function(e,t,n){return n.get&&r(n.get,t,{getter:!0}),n.set&&r(n.set,t,{setter:!0}),a.f(e,t,n)}},8052:function(e,t,n){var r=n(614),a=n(3070),s=n(6339),i=n(3072);e.exports=function(e,t,n,o){o||(o={});var l=o.enumerable,u=void 0!==o.name?o.name:t;if(r(n)&&s(n,u,o),o.global)l?e[t]=n:i(t,n);else{try{o.unsafe?e[t]&&(l=!0):delete e[t]}catch(p){}l?e[t]=n:a.f(e,t,{value:n,enumerable:!1,configurable:!o.nonConfigurable,writable:!o.nonWritable})}return e}},3072:function(e,t,n){var r=n(7854),a=Object.defineProperty;e.exports=function(e,t){try{a(r,e,{value:t,configurable:!0,writable:!0})}catch(n){r[e]=t}return t}},5117:function(e,t,n){"use strict";var r=n(6330),a=TypeError;e.exports=function(e,t){if(!delete e[t])throw a("Cannot delete property "+r(t)+" of "+r(e))}},9781:function(e,t,n){var r=n(7293);e.exports=!r((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},4154:function(e){var t="object"==typeof document&&document.all,n="undefined"==typeof t&&void 0!==t;e.exports={all:t,IS_HTMLDDA:n}},317:function(e,t,n){var r=n(7854),a=n(111),s=r.document,i=a(s)&&a(s.createElement);e.exports=function(e){return i?s.createElement(e):{}}},7207:function(e){var t=TypeError,n=9007199254740991;e.exports=function(e){if(e>n)throw t("Maximum allowed index exceeded");return e}},3678:function(e){e.exports={IndexSizeError:{s:"INDEX_SIZE_ERR",c:1,m:1},DOMStringSizeError:{s:"DOMSTRING_SIZE_ERR",c:2,m:0},HierarchyRequestError:{s:"HIERARCHY_REQUEST_ERR",c:3,m:1},WrongDocumentError:{s:"WRONG_DOCUMENT_ERR",c:4,m:1},InvalidCharacterError:{s:"INVALID_CHARACTER_ERR",c:5,m:1},NoDataAllowedError:{s:"NO_DATA_ALLOWED_ERR",c:6,m:0},NoModificationAllowedError:{s:"NO_MODIFICATION_ALLOWED_ERR",c:7,m:1},NotFoundError:{s:"NOT_FOUND_ERR",c:8,m:1},NotSupportedError:{s:"NOT_SUPPORTED_ERR",c:9,m:1},InUseAttributeError:{s:"INUSE_ATTRIBUTE_ERR",c:10,m:1},InvalidStateError:{s:"INVALID_STATE_ERR",c:11,m:1},SyntaxError:{s:"SYNTAX_ERR",c:12,m:1},InvalidModificationError:{s:"INVALID_MODIFICATION_ERR",c:13,m:1},NamespaceError:{s:"NAMESPACE_ERR",c:14,m:1},InvalidAccessError:{s:"INVALID_ACCESS_ERR",c:15,m:1},ValidationError:{s:"VALIDATION_ERR",c:16,m:0},TypeMismatchError:{s:"TYPE_MISMATCH_ERR",c:17,m:1},SecurityError:{s:"SECURITY_ERR",c:18,m:1},NetworkError:{s:"NETWORK_ERR",c:19,m:1},AbortError:{s:"ABORT_ERR",c:20,m:1},URLMismatchError:{s:"URL_MISMATCH_ERR",c:21,m:1},QuotaExceededError:{s:"QUOTA_EXCEEDED_ERR",c:22,m:1},TimeoutError:{s:"TIMEOUT_ERR",c:23,m:1},InvalidNodeTypeError:{s:"INVALID_NODE_TYPE_ERR",c:24,m:1},DataCloneError:{s:"DATA_CLONE_ERR",c:25,m:1}}},9363:function(e){e.exports="function"==typeof Bun&&Bun&&"string"==typeof Bun.version},6833:function(e,t,n){var r=n(8113);e.exports=/(?:ipad|iphone|ipod).*applewebkit/i.test(r)},5268:function(e,t,n){var r=n(4326);e.exports="undefined"!=typeof process&&"process"==r(process)},8113:function(e){e.exports="undefined"!=typeof navigator&&String(navigator.userAgent)||""},7392:function(e,t,n){var r,a,s=n(7854),i=n(8113),o=s.process,l=s.Deno,u=o&&o.versions||l&&l.version,p=u&&u.v8;p&&(r=p.split("."),a=r[0]>0&&r[0]<4?1:+(r[0]+r[1])),!a&&i&&(r=i.match(/Edge\/(\d+)/),(!r||r[1]>=74)&&(r=i.match(/Chrome\/(\d+)/),r&&(a=+r[1]))),e.exports=a},748:function(e){e.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},1060:function(e,t,n){var r=n(1702),a=Error,s=r("".replace),i=function(e){return String(a(e).stack)}("zxcasd"),o=/\n\s*at [^:]*:[^\n]*/,l=o.test(i);e.exports=function(e,t){if(l&&"string"==typeof e&&!a.prepareStackTrace)while(t--)e=s(e,o,"");return e}},2109:function(e,t,n){var r=n(7854),a=n(1236).f,s=n(8880),i=n(8052),o=n(3072),l=n(9920),u=n(4705);e.exports=function(e,t){var n,p,c,d,h,f,m=e.target,g=e.global,y=e.stat;if(p=g?r:y?r[m]||o(m,{}):(r[m]||{}).prototype,p)for(c in t){if(h=t[c],e.dontCallGetSet?(f=a(p,c),d=f&&f.value):d=p[c],n=u(g?c:m+(y?".":"#")+c,e.forced),!n&&void 0!==d){if(typeof h==typeof d)continue;l(h,d)}(e.sham||d&&d.sham)&&s(h,"sham",!0),i(p,c,h,e)}}},7293:function(e){e.exports=function(e){try{return!!e()}catch(t){return!0}}},2104:function(e,t,n){var r=n(4374),a=Function.prototype,s=a.apply,i=a.call;e.exports="object"==typeof Reflect&&Reflect.apply||(r?i.bind(s):function(){return i.apply(s,arguments)})},9974:function(e,t,n){var r=n(1470),a=n(9662),s=n(4374),i=r(r.bind);e.exports=function(e,t){return a(e),void 0===t?e:s?i(e,t):function(){return e.apply(t,arguments)}}},4374:function(e,t,n){var r=n(7293);e.exports=!r((function(){var e=function(){}.bind();return"function"!=typeof e||e.hasOwnProperty("prototype")}))},6916:function(e,t,n){var r=n(4374),a=Function.prototype.call;e.exports=r?a.bind(a):function(){return a.apply(a,arguments)}},6530:function(e,t,n){var r=n(9781),a=n(2597),s=Function.prototype,i=r&&Object.getOwnPropertyDescriptor,o=a(s,"name"),l=o&&"something"===function(){}.name,u=o&&(!r||r&&i(s,"name").configurable);e.exports={EXISTS:o,PROPER:l,CONFIGURABLE:u}},5668:function(e,t,n){var r=n(1702),a=n(9662);e.exports=function(e,t,n){try{return r(a(Object.getOwnPropertyDescriptor(e,t)[n]))}catch(s){}}},1470:function(e,t,n){var r=n(4326),a=n(1702);e.exports=function(e){if("Function"===r(e))return a(e)}},1702:function(e,t,n){var r=n(4374),a=Function.prototype,s=a.call,i=r&&a.bind.bind(s,s);e.exports=r?i:function(e){return function(){return s.apply(e,arguments)}}},5005:function(e,t,n){var r=n(7854),a=n(614),s=function(e){return a(e)?e:void 0};e.exports=function(e,t){return arguments.length<2?s(r[e]):r[e]&&r[e][t]}},8173:function(e,t,n){var r=n(9662),a=n(8554);e.exports=function(e,t){var n=e[t];return a(n)?void 0:r(n)}},7854:function(e,t,n){var r=function(e){return e&&e.Math==Math&&e};e.exports=r("object"==typeof globalThis&&globalThis)||r("object"==typeof window&&window)||r("object"==typeof self&&self)||r("object"==typeof n.g&&n.g)||function(){return this}()||Function("return this")()},2597:function(e,t,n){var r=n(1702),a=n(7908),s=r({}.hasOwnProperty);e.exports=Object.hasOwn||function(e,t){return s(a(e),t)}},3501:function(e){e.exports={}},490:function(e,t,n){var r=n(5005);e.exports=r("document","documentElement")},4664:function(e,t,n){var r=n(9781),a=n(7293),s=n(317);e.exports=!r&&!a((function(){return 7!=Object.defineProperty(s("div"),"a",{get:function(){return 7}}).a}))},8361:function(e,t,n){var r=n(1702),a=n(7293),s=n(4326),i=Object,o=r("".split);e.exports=a((function(){return!i("z").propertyIsEnumerable(0)}))?function(e){return"String"==s(e)?o(e,""):i(e)}:i},9587:function(e,t,n){var r=n(614),a=n(111),s=n(7674);e.exports=function(e,t,n){var i,o;return s&&r(i=t.constructor)&&i!==n&&a(o=i.prototype)&&o!==n.prototype&&s(e,o),e}},2788:function(e,t,n){var r=n(1702),a=n(614),s=n(5465),i=r(Function.toString);a(s.inspectSource)||(s.inspectSource=function(e){return i(e)}),e.exports=s.inspectSource},9909:function(e,t,n){var r,a,s,i=n(4811),o=n(7854),l=n(111),u=n(8880),p=n(2597),c=n(5465),d=n(6200),h=n(3501),f="Object already initialized",m=o.TypeError,g=o.WeakMap,y=function(e){return s(e)?a(e):r(e,{})},b=function(e){return function(t){var n;if(!l(t)||(n=a(t)).type!==e)throw m("Incompatible receiver, "+e+" required");return n}};if(i||c.state){var x=c.state||(c.state=new g);x.get=x.get,x.has=x.has,x.set=x.set,r=function(e,t){if(x.has(e))throw m(f);return t.facade=e,x.set(e,t),t},a=function(e){return x.get(e)||{}},s=function(e){return x.has(e)}}else{var v=d("state");h[v]=!0,r=function(e,t){if(p(e,v))throw m(f);return t.facade=e,u(e,v,t),t},a=function(e){return p(e,v)?e[v]:{}},s=function(e){return p(e,v)}}e.exports={set:r,get:a,has:s,enforce:y,getterFor:b}},3157:function(e,t,n){var r=n(4326);e.exports=Array.isArray||function(e){return"Array"==r(e)}},4067:function(e,t,n){var r=n(648);e.exports=function(e){var t=r(e);return"BigInt64Array"==t||"BigUint64Array"==t}},614:function(e,t,n){var r=n(4154),a=r.all;e.exports=r.IS_HTMLDDA?function(e){return"function"==typeof e||e===a}:function(e){return"function"==typeof e}},4705:function(e,t,n){var r=n(7293),a=n(614),s=/#|\.prototype\./,i=function(e,t){var n=l[o(e)];return n==p||n!=u&&(a(t)?r(t):!!t)},o=i.normalize=function(e){return String(e).replace(s,".").toLowerCase()},l=i.data={},u=i.NATIVE="N",p=i.POLYFILL="P";e.exports=i},8554:function(e){e.exports=function(e){return null===e||void 0===e}},111:function(e,t,n){var r=n(614),a=n(4154),s=a.all;e.exports=a.IS_HTMLDDA?function(e){return"object"==typeof e?null!==e:r(e)||e===s}:function(e){return"object"==typeof e?null!==e:r(e)}},1913:function(e){e.exports=!1},2190:function(e,t,n){var r=n(5005),a=n(614),s=n(7976),i=n(3307),o=Object;e.exports=i?function(e){return"symbol"==typeof e}:function(e){var t=r("Symbol");return a(t)&&s(t.prototype,o(e))}},6244:function(e,t,n){var r=n(7466);e.exports=function(e){return r(e.length)}},6339:function(e,t,n){var r=n(1702),a=n(7293),s=n(614),i=n(2597),o=n(9781),l=n(6530).CONFIGURABLE,u=n(2788),p=n(9909),c=p.enforce,d=p.get,h=String,f=Object.defineProperty,m=r("".slice),g=r("".replace),y=r([].join),b=o&&!a((function(){return 8!==f((function(){}),"length",{value:8}).length})),x=String(String).split("String"),v=e.exports=function(e,t,n){"Symbol("===m(h(t),0,7)&&(t="["+g(h(t),/^Symbol\(([^)]*)\)/,"$1")+"]"),n&&n.getter&&(t="get "+t),n&&n.setter&&(t="set "+t),(!i(e,"name")||l&&e.name!==t)&&(o?f(e,"name",{value:t,configurable:!0}):e.name=t),b&&n&&i(n,"arity")&&e.length!==n.arity&&f(e,"length",{value:n.arity});try{n&&i(n,"constructor")&&n.constructor?o&&f(e,"prototype",{writable:!1}):e.prototype&&(e.prototype=void 0)}catch(a){}var r=c(e);return i(r,"source")||(r.source=y(x,"string"==typeof t?t:"")),e};Function.prototype.toString=v((function(){return s(this)&&d(this).source||u(this)}),"toString")},4758:function(e){var t=Math.ceil,n=Math.floor;e.exports=Math.trunc||function(e){var r=+e;return(r>0?n:t)(r)}},6277:function(e,t,n){var r=n(1340);e.exports=function(e,t){return void 0===e?arguments.length<2?"":t:r(e)}},3070:function(e,t,n){var r=n(9781),a=n(4664),s=n(3353),i=n(9670),o=n(4948),l=TypeError,u=Object.defineProperty,p=Object.getOwnPropertyDescriptor,c="enumerable",d="configurable",h="writable";t.f=r?s?function(e,t,n){if(i(e),t=o(t),i(n),"function"===typeof e&&"prototype"===t&&"value"in n&&h in n&&!n[h]){var r=p(e,t);r&&r[h]&&(e[t]=n.value,n={configurable:d in n?n[d]:r[d],enumerable:c in n?n[c]:r[c],writable:!1})}return u(e,t,n)}:u:function(e,t,n){if(i(e),t=o(t),i(n),a)try{return u(e,t,n)}catch(r){}if("get"in n||"set"in n)throw l("Accessors not supported");return"value"in n&&(e[t]=n.value),e}},1236:function(e,t,n){var r=n(9781),a=n(6916),s=n(5296),i=n(9114),o=n(5656),l=n(4948),u=n(2597),p=n(4664),c=Object.getOwnPropertyDescriptor;t.f=r?c:function(e,t){if(e=o(e),t=l(t),p)try{return c(e,t)}catch(n){}if(u(e,t))return i(!a(s.f,e,t),e[t])}},8006:function(e,t,n){var r=n(6324),a=n(748),s=a.concat("length","prototype");t.f=Object.getOwnPropertyNames||function(e){return r(e,s)}},5181:function(e,t){t.f=Object.getOwnPropertySymbols},9518:function(e,t,n){var r=n(2597),a=n(614),s=n(7908),i=n(6200),o=n(8544),l=i("IE_PROTO"),u=Object,p=u.prototype;e.exports=o?u.getPrototypeOf:function(e){var t=s(e);if(r(t,l))return t[l];var n=t.constructor;return a(n)&&t instanceof n?n.prototype:t instanceof u?p:null}},7976:function(e,t,n){var r=n(1702);e.exports=r({}.isPrototypeOf)},6324:function(e,t,n){var r=n(1702),a=n(2597),s=n(5656),i=n(1318).indexOf,o=n(3501),l=r([].push);e.exports=function(e,t){var n,r=s(e),u=0,p=[];for(n in r)!a(o,n)&&a(r,n)&&l(p,n);while(t.length>u)a(r,n=t[u++])&&(~i(p,n)||l(p,n));return p}},5296:function(e,t){"use strict";var n={}.propertyIsEnumerable,r=Object.getOwnPropertyDescriptor,a=r&&!n.call({1:2},1);t.f=a?function(e){var t=r(this,e);return!!t&&t.enumerable}:n},7674:function(e,t,n){var r=n(5668),a=n(9670),s=n(6077);e.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var e,t=!1,n={};try{e=r(Object.prototype,"__proto__","set"),e(n,[]),t=n instanceof Array}catch(i){}return function(n,r){return a(n),s(r),t?e(n,r):n.__proto__=r,n}}():void 0)},2140:function(e,t,n){var r=n(6916),a=n(614),s=n(111),i=TypeError;e.exports=function(e,t){var n,o;if("string"===t&&a(n=e.toString)&&!s(o=r(n,e)))return o;if(a(n=e.valueOf)&&!s(o=r(n,e)))return o;if("string"!==t&&a(n=e.toString)&&!s(o=r(n,e)))return o;throw i("Can't convert object to primitive value")}},3887:function(e,t,n){var r=n(5005),a=n(1702),s=n(8006),i=n(5181),o=n(9670),l=a([].concat);e.exports=r("Reflect","ownKeys")||function(e){var t=s.f(o(e)),n=i.f;return n?l(t,n(e)):t}},7066:function(e,t,n){"use strict";var r=n(9670);e.exports=function(){var e=r(this),t="";return e.hasIndices&&(t+="d"),e.global&&(t+="g"),e.ignoreCase&&(t+="i"),e.multiline&&(t+="m"),e.dotAll&&(t+="s"),e.unicode&&(t+="u"),e.unicodeSets&&(t+="v"),e.sticky&&(t+="y"),t}},4488:function(e,t,n){var r=n(8554),a=TypeError;e.exports=function(e){if(r(e))throw a("Can't call method on "+e);return e}},7152:function(e,t,n){"use strict";var r=n(7854),a=n(2104),s=n(614),i=n(9363),o=n(8113),l=n(206),u=n(8053),p=r.Function,c=/MSIE .\./.test(o)||i&&function(){var e=r.Bun.version.split(".");return e.length<3||0==e[0]&&(e[1]<3||3==e[1]&&0==e[2])}();e.exports=function(e,t){var n=t?2:1;return c?function(r,i){var o=u(arguments.length,1)>n,c=s(r)?r:p(r),d=o?l(arguments,n):[],h=o?function(){a(c,this,d)}:c;return t?e(h,i):e(h)}:e}},6200:function(e,t,n){var r=n(2309),a=n(9711),s=r("keys");e.exports=function(e){return s[e]||(s[e]=a(e))}},5465:function(e,t,n){var r=n(7854),a=n(3072),s="__core-js_shared__",i=r[s]||a(s,{});e.exports=i},2309:function(e,t,n){var r=n(1913),a=n(5465);(e.exports=function(e,t){return a[e]||(a[e]=void 0!==t?t:{})})("versions",[]).push({version:"3.29.1",mode:r?"pure":"global",copyright:"Â© 2014-2023 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.29.1/LICENSE",source:"https://github.com/zloirock/core-js"})},6293:function(e,t,n){var r=n(7392),a=n(7293);e.exports=!!Object.getOwnPropertySymbols&&!a((function(){var e=Symbol();return!String(e)||!(Object(e)instanceof Symbol)||!Symbol.sham&&r&&r<41}))},261:function(e,t,n){var r,a,s,i,o=n(7854),l=n(2104),u=n(9974),p=n(614),c=n(2597),d=n(7293),h=n(490),f=n(206),m=n(317),g=n(8053),y=n(6833),b=n(5268),x=o.setImmediate,v=o.clearImmediate,w=o.process,k=o.Dispatch,I=o.Function,S=o.MessageChannel,N=o.String,T=0,_={},C="onreadystatechange";d((function(){r=o.location}));var E=function(e){if(c(_,e)){var t=_[e];delete _[e],t()}},A=function(e){return function(){E(e)}},$=function(e){E(e.data)},R=function(e){o.postMessage(N(e),r.protocol+"//"+r.host)};x&&v||(x=function(e){g(arguments.length,1);var t=p(e)?e:I(e),n=f(arguments,1);return _[++T]=function(){l(t,void 0,n)},a(T),T},v=function(e){delete _[e]},b?a=function(e){w.nextTick(A(e))}:k&&k.now?a=function(e){k.now(A(e))}:S&&!y?(s=new S,i=s.port2,s.port1.onmessage=$,a=u(i.postMessage,i)):o.addEventListener&&p(o.postMessage)&&!o.importScripts&&r&&"file:"!==r.protocol&&!d(R)?(a=R,o.addEventListener("message",$,!1)):a=C in m("script")?function(e){h.appendChild(m("script"))[C]=function(){h.removeChild(this),E(e)}}:function(e){setTimeout(A(e),0)}),e.exports={set:x,clear:v}},1400:function(e,t,n){var r=n(9303),a=Math.max,s=Math.min;e.exports=function(e,t){var n=r(e);return n<0?a(n+t,0):s(n,t)}},4599:function(e,t,n){var r=n(7593),a=TypeError;e.exports=function(e){var t=r(e,"number");if("number"==typeof t)throw a("Can't convert number to bigint");return BigInt(t)}},5656:function(e,t,n){var r=n(8361),a=n(4488);e.exports=function(e){return r(a(e))}},9303:function(e,t,n){var r=n(4758);e.exports=function(e){var t=+e;return t!==t||0===t?0:r(t)}},7466:function(e,t,n){var r=n(9303),a=Math.min;e.exports=function(e){return e>0?a(r(e),9007199254740991):0}},7908:function(e,t,n){var r=n(4488),a=Object;e.exports=function(e){return a(r(e))}},7593:function(e,t,n){var r=n(6916),a=n(111),s=n(2190),i=n(8173),o=n(2140),l=n(5112),u=TypeError,p=l("toPrimitive");e.exports=function(e,t){if(!a(e)||s(e))return e;var n,l=i(e,p);if(l){if(void 0===t&&(t="default"),n=r(l,e,t),!a(n)||s(n))return n;throw u("Can't convert object to primitive value")}return void 0===t&&(t="number"),o(e,t)}},4948:function(e,t,n){var r=n(7593),a=n(2190);e.exports=function(e){var t=r(e,"string");return a(t)?t:t+""}},1694:function(e,t,n){var r=n(5112),a=r("toStringTag"),s={};s[a]="z",e.exports="[object z]"===String(s)},1340:function(e,t,n){var r=n(648),a=String;e.exports=function(e){if("Symbol"===r(e))throw TypeError("Cannot convert a Symbol value to a string");return a(e)}},6330:function(e){var t=String;e.exports=function(e){try{return t(e)}catch(n){return"Object"}}},9711:function(e,t,n){var r=n(1702),a=0,s=Math.random(),i=r(1..toString);e.exports=function(e){return"Symbol("+(void 0===e?"":e)+")_"+i(++a+s,36)}},3307:function(e,t,n){var r=n(6293);e.exports=r&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},3353:function(e,t,n){var r=n(9781),a=n(7293);e.exports=r&&a((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},8053:function(e){var t=TypeError;e.exports=function(e,n){if(e<n)throw t("Not enough arguments");return e}},4811:function(e,t,n){var r=n(7854),a=n(614),s=r.WeakMap;e.exports=a(s)&&/native code/.test(String(s))},5112:function(e,t,n){var r=n(7854),a=n(2309),s=n(2597),i=n(9711),o=n(6293),l=n(3307),u=r.Symbol,p=a("wks"),c=l?u["for"]||u:u&&u.withoutSetter||i;e.exports=function(e){return s(p,e)||(p[e]=o&&s(u,e)?u[e]:c("Symbol."+e)),p[e]}},7658:function(e,t,n){"use strict";var r=n(2109),a=n(7908),s=n(6244),i=n(3658),o=n(7207),l=n(7293),u=l((function(){return 4294967297!==[].push.call({length:4294967296},1)})),p=function(){try{Object.defineProperty([],"length",{writable:!1}).push()}catch(e){return e instanceof TypeError}},c=u||!p();r({target:"Array",proto:!0,arity:1,forced:c},{push:function(e){var t=a(this),n=s(t),r=arguments.length;o(n+r);for(var l=0;l<r;l++)t[n]=arguments[l],n++;return i(t,n),n}})},541:function(e,t,n){"use strict";var r=n(2109),a=n(7908),s=n(6244),i=n(3658),o=n(5117),l=n(7207),u=1!==[].unshift(0),p=function(){try{Object.defineProperty([],"length",{writable:!1}).unshift()}catch(e){return e instanceof TypeError}},c=u||!p();r({target:"Array",proto:!0,arity:1,forced:c},{unshift:function(e){var t=a(this),n=s(t),r=arguments.length;if(r){l(n+r);var u=n;while(u--){var p=u+r;u in t?t[p]=t[u]:o(t,p)}for(var c=0;c<r;c++)t[c]=arguments[c]}return i(t,n+r)}})},2087:function(e,t,n){var r=n(7854),a=n(9781),s=n(7045),i=n(7066),o=n(7293),l=r.RegExp,u=l.prototype,p=a&&o((function(){var e=!0;try{l(".","d")}catch(p){e=!1}var t={},n="",r=e?"dgimsy":"gimsy",a=function(e,r){Object.defineProperty(t,e,{get:function(){return n+=r,!0}})},s={dotAll:"s",global:"g",ignoreCase:"i",multiline:"m",sticky:"y"};for(var i in e&&(s.hasIndices="d"),s)a(i,s[i]);var o=Object.getOwnPropertyDescriptor(u,"flags").get.call(t);return o!==r||n!==r}));p&&s(u,"flags",{configurable:!0,get:i})},1439:function(e,t,n){"use strict";var r=n(1843),a=n(260),s=a.aTypedArray,i=a.exportTypedArrayMethod,o=a.getTypedArrayConstructor;i("toReversed",(function(){return r(s(this),o(this))}))},7585:function(e,t,n){"use strict";var r=n(260),a=n(1702),s=n(9662),i=n(7745),o=r.aTypedArray,l=r.getTypedArrayConstructor,u=r.exportTypedArrayMethod,p=a(r.TypedArrayPrototype.sort);u("toSorted",(function(e){void 0!==e&&s(e);var t=o(this),n=i(l(t),t);return p(n,e)}))},5315:function(e,t,n){"use strict";var r=n(1572),a=n(260),s=n(4067),i=n(9303),o=n(4599),l=a.aTypedArray,u=a.getTypedArrayConstructor,p=a.exportTypedArrayMethod,c=!!function(){try{new Int8Array(1)["with"](2,{valueOf:function(){throw 8}})}catch(e){return 8===e}}();p("with",{with:function(e,t){var n=l(this),a=i(e),p=s(n)?o(t):+t;return r(n,u(n),a,p)}}["with"],!c)},3767:function(e,t,n){n(1439)},8585:function(e,t,n){n(7585)},8696:function(e,t,n){n(5315)},1091:function(e,t,n){var r=n(2109),a=n(7854),s=n(261).clear;r({global:!0,bind:!0,enumerable:!0,forced:a.clearImmediate!==s},{clearImmediate:s})},2801:function(e,t,n){"use strict";var r=n(2109),a=n(7854),s=n(5005),i=n(9114),o=n(3070).f,l=n(2597),u=n(5787),p=n(9587),c=n(6277),d=n(3678),h=n(1060),f=n(9781),m=n(1913),g="DOMException",y=s("Error"),b=s(g),x=function(){u(this,v);var e=arguments.length,t=c(e<1?void 0:arguments[0]),n=c(e<2?void 0:arguments[1],"Error"),r=new b(t,n),a=y(t);return a.name=g,o(r,"stack",i(1,h(a.stack,1))),p(r,this,x),r},v=x.prototype=b.prototype,w="stack"in y(g),k="stack"in new b(1,2),I=b&&f&&Object.getOwnPropertyDescriptor(a,g),S=!!I&&!(I.writable&&I.configurable),N=w&&!S&&!k;r({global:!0,constructor:!0,forced:m||N},{DOMException:N?x:b});var T=s(g),_=T.prototype;if(_.constructor!==T)for(var C in m||o(_,"constructor",i(1,T)),d)if(l(d,C)){var E=d[C],A=E.s;l(T,A)||o(T,A,i(6,E.c))}},4633:function(e,t,n){n(1091),n(2986)},2986:function(e,t,n){var r=n(2109),a=n(7854),s=n(261).set,i=n(7152),o=a.setImmediate?i(s,!1):s;r({global:!0,bind:!0,enumerable:!0,forced:a.setImmediate!==o},{setImmediate:o})},1999:function(e,t,n){"use strict";var r="/index.js",a="/";n.d(t,{Qk:function(){return Woe},UL:function(){return Uae},aK:function(){return Aoe},bd:function(){return ole},oE:function(){return Xae},sE:function(){return Tse},vd:function(){return Boe},z2:function(){return zoe},zi:function(){return ule}});n(3767),n(8585),n(8696),n(7658),n(541),n(2087),n(2801),n(4633);var s=Object.defineProperty,i=(e=>n(6741))(),o=(e,t)=>{for(var n in t)s(e,n,{get:t[n],enumerable:!0})},l={};o(l,{Abs:()=>Ke,Acos:()=>Xe,Acosh:()=>Je,AdadeltaOptimizer:()=>_b,AdagradOptimizer:()=>Cb,AdamOptimizer:()=>Eb,AdamaxOptimizer:()=>Ab,Add:()=>Ye,AddN:()=>Ze,All:()=>Qe,Any:()=>et,ArgMax:()=>tt,ArgMin:()=>nt,Asin:()=>rt,Asinh:()=>at,Atan:()=>st,Atan2:()=>ot,Atanh:()=>it,AvgPool:()=>lt,AvgPool3D:()=>pt,AvgPool3DGrad:()=>ct,AvgPoolGrad:()=>ut,BackendWasm:()=>Wre,BatchMatMul:()=>dt,BatchToSpaceND:()=>ht,Bincount:()=>ft,BroadcastArgs:()=>gt,BroadcastTo:()=>mt,Callback:()=>FR,CallbackList:()=>ET,Cast:()=>yt,Ceil:()=>bt,ClipByValue:()=>xt,Complex:()=>vt,ComplexAbs:()=>wt,Concat:()=>kt,Conv2D:()=>It,Conv2DBackpropFilter:()=>St,Conv2DBackpropInput:()=>Nt,Conv3D:()=>Tt,Conv3DBackpropFilterV2:()=>_t,Conv3DBackpropInputV2:()=>Ct,Cos:()=>Et,Cosh:()=>At,CropAndResize:()=>Ft,Cumprod:()=>$t,Cumsum:()=>Rt,CustomCallback:()=>RT,DataStorage:()=>B,DenseBincount:()=>Dt,DepthToSpace:()=>Mt,DepthwiseConv2dNative:()=>Ot,DepthwiseConv2dNativeBackpropFilter:()=>Pt,DepthwiseConv2dNativeBackpropInput:()=>Lt,Diag:()=>zt,Dilation2D:()=>Bt,Dilation2DBackpropFilter:()=>Ut,Dilation2DBackpropInput:()=>Wt,ENV:()=>Ve,EarlyStopping:()=>OR,Einsum:()=>Gt,Elu:()=>Ht,EluGrad:()=>jt,Environment:()=>Pe,Equal:()=>Kt,Erf:()=>qt,Exp:()=>Xt,ExpandDims:()=>Jt,Expm1:()=>Yt,FFT:()=>Zt,Fill:()=>Qt,FlipLeftRight:()=>en,Floor:()=>tn,FloorDiv:()=>nn,FromPixels:()=>ia,FusedBatchNorm:()=>rn,FusedConv2D:()=>ua,FusedDepthwiseConv2D:()=>pa,GPGPUContext:()=>Xq,GatherNd:()=>sn,GatherV2:()=>an,GraphModel:()=>QD,Greater:()=>on,GreaterEqual:()=>ln,History:()=>$T,IFFT:()=>pn,Identity:()=>un,Imag:()=>cn,InputSpec:()=>SN,IsFinite:()=>dn,IsInf:()=>hn,IsNan:()=>fn,KernelBackend:()=>W,LRN:()=>_n,LRNGrad:()=>Cn,LayerVariable:()=>vN,LayersModel:()=>pC,LeakyRelu:()=>mn,Less:()=>gn,LessEqual:()=>yn,LinSpace:()=>bn,Log:()=>xn,Log1p:()=>vn,LogSoftmax:()=>Nn,LogicalAnd:()=>wn,LogicalNot:()=>kn,LogicalOr:()=>In,LogicalXor:()=>Sn,LowerBound:()=>Tn,MathBackendCPU:()=>NO,MathBackendWebGL:()=>CX,MatrixBandPart:()=>En,Max:()=>An,MaxPool:()=>Rn,MaxPool3D:()=>Dn,MaxPool3DGrad:()=>Mn,MaxPoolGrad:()=>Fn,MaxPoolWithArgmax:()=>On,Maximum:()=>$n,Mean:()=>Pn,Min:()=>Ln,Minimum:()=>zn,MirrorPad:()=>Bn,Mod:()=>Wn,MomentumOptimizer:()=>Rb,Multinomial:()=>Un,Multiply:()=>Vn,Neg:()=>Gn,NonMaxSuppressionV3:()=>jn,NonMaxSuppressionV4:()=>qn,NonMaxSuppressionV5:()=>Kn,NotEqual:()=>Hn,OP_SCOPE_SUFFIX:()=>ri,OneHot:()=>Jn,OnesLike:()=>Xn,Optimizer:()=>Tb,OptimizerConstructors:()=>Kx,Pack:()=>Yn,PadV2:()=>Zn,Pool:()=>Qn,Pow:()=>er,Prelu:()=>tr,Prod:()=>nr,RMSPropOptimizer:()=>Fb,RNN:()=>IE,RaggedGather:()=>rr,RaggedRange:()=>ar,RaggedTensorToTensor:()=>sr,Range:()=>ir,Rank:()=>ws,Real:()=>or,RealDiv:()=>Vt,Reciprocal:()=>lr,Reduction:()=>$y,Relu:()=>ur,Relu6:()=>mr,Reshape:()=>pr,ResizeBilinear:()=>hr,ResizeBilinearGrad:()=>fr,ResizeNearestNeighbor:()=>cr,ResizeNearestNeighborGrad:()=>dr,Reverse:()=>gr,RotateWithOffset:()=>oa,Round:()=>yr,Rsqrt:()=>br,SGDOptimizer:()=>$b,ScatterNd:()=>xr,SearchSorted:()=>wr,Select:()=>kr,Selu:()=>Ir,Sequential:()=>gC,Sigmoid:()=>Cr,Sign:()=>_r,Sin:()=>Nr,Sinh:()=>Tr,Slice:()=>Sr,Softmax:()=>Dr,Softplus:()=>Er,SpaceToBatchND:()=>Rr,SparseFillEmptyRows:()=>Mr,SparseReshape:()=>Or,SparseSegmentMean:()=>Pr,SparseSegmentSum:()=>Lr,SparseToDense:()=>zr,SplitV:()=>Fr,Sqrt:()=>Ar,Square:()=>Wr,SquaredDifference:()=>Br,StaticRegexReplace:()=>Ur,Step:()=>sa,StridedSlice:()=>Vr,StringNGrams:()=>Gr,StringSplit:()=>Hr,StringToHashBucketFast:()=>jr,Sub:()=>qr,Sum:()=>$r,SymbolicTensor:()=>NN,Tan:()=>Kr,Tanh:()=>Xr,Tensor:()=>bs,TensorBuffer:()=>ds,TensorScatterUpdate:()=>vr,Tile:()=>Jr,TopK:()=>Yr,Transform:()=>Zr,Transpose:()=>Qr,Unique:()=>ea,Unpack:()=>ta,UnsortedSegmentSum:()=>na,UpperBound:()=>ra,Variable:()=>vs,ZerosLike:()=>aa,_FusedMatMul:()=>la,abs:()=>nl,acos:()=>al,acosh:()=>il,add:()=>Ko,addN:()=>ll,all:()=>pl,any:()=>dl,argMax:()=>fl,argMin:()=>gl,asin:()=>bl,asinh:()=>vl,atan:()=>kl,atan2:()=>Sl,atanh:()=>Tl,avgPool:()=>Xl,avgPool3d:()=>Yl,backend:()=>Ho,backend_util:()=>Qx,basicLSTMCell:()=>uu,batchNorm:()=>fu,batchNorm2d:()=>gu,batchNorm3d:()=>bu,batchNorm4d:()=>vu,batchToSpaceND:()=>cu,bincount:()=>ku,booleanMaskAsync:()=>Km,broadcastArgs:()=>Su,broadcastTo:()=>Tu,broadcast_util:()=>bp,browser:()=>mx,buffer:()=>xo,callbacks:()=>BR,cast:()=>wo,ceil:()=>Cu,clipByValue:()=>$u,clone:()=>Io,complex:()=>ii,concat:()=>Ql,concat1d:()=>Fu,concat2d:()=>Mu,concat3d:()=>Pu,concat4d:()=>zu,constraints:()=>jN,conv1d:()=>Vu,conv2d:()=>Wu,conv2dTranspose:()=>qu,conv3d:()=>Xu,conv3dTranspose:()=>Qu,copyRegisteredKernels:()=>ka,cos:()=>tp,cosh:()=>rp,cosineWindow:()=>pg,cumprod:()=>sp,cumsum:()=>op,customGrad:()=>ed,data:()=>aM,denseBincount:()=>up,deprecationWarn:()=>Eo,depthToSpace:()=>cp,depthwiseConv2d:()=>hp,deregisterOp:()=>HR,device_util:()=>js,diag:()=>mp,dilation2d:()=>yp,disableDeprecationWarnings:()=>Co,dispose:()=>Mo,disposeVariables:()=>Ao,div:()=>Zo,divNoNan:()=>Ep,dot:()=>$p,dropout:()=>lg,einsum:()=>Fp,elu:()=>Mp,enableDebugMode:()=>_o,enableProdMode:()=>To,enclosingPowerOfTwo:()=>ug,engine:()=>$o,env:()=>We,equal:()=>Ip,erf:()=>Pp,euclideanNorm:()=>uc,exp:()=>cc,expandDims:()=>hc,expm1:()=>mc,eye:()=>xc,fft:()=>Qf,fill:()=>Eu,findBackend:()=>Uo,findBackendFactory:()=>Vo,floor:()=>wc,floorDiv:()=>Jo,forceHalfFloat:()=>$X,fused:()=>hg,gather:()=>Ic,gatherND:()=>sg,gather_util:()=>Sx,getBackend:()=>Bo,getGradient:()=>ga,getKernel:()=>ma,getKernelsForBackend:()=>ya,getThreadsCount:()=>rae,gpgpu_util:()=>Tq,grad:()=>Xc,grads:()=>Jc,greater:()=>Nc,greaterEqual:()=>_c,ifft:()=>tm,imag:()=>Ec,image:()=>yb,inTopKAsync:()=>dg,initializers:()=>oT,input:()=>xC,io:()=>Ob,irfft:()=>rm,isFinite:()=>$c,isInf:()=>Fc,isNaN:()=>Mc,keep:()=>Oo,kernel_impls:()=>sw,layers:()=>ST,leakyRelu:()=>Pc,less:()=>zc,lessEqual:()=>Wc,linalg:()=>bb,linspace:()=>Uc,loadGraphModel:()=>eM,loadGraphModelSync:()=>tM,loadLayersModel:()=>hC,localResponseNormalization:()=>Gc,log:()=>jc,log1p:()=>Kc,logSigmoid:()=>od,logSoftmax:()=>cd,logSumExp:()=>hd,logicalAnd:()=>md,logicalNot:()=>yd,logicalOr:()=>xd,logicalXor:()=>wd,losses:()=>xb,lowerBound:()=>Nd,matMul:()=>tu,math:()=>cx,max:()=>qp,maxPool:()=>_d,maxPool3d:()=>Ed,maxPoolWithArgmax:()=>$d,maximum:()=>Fd,mean:()=>Md,memory:()=>Ro,meshgrid:()=>Ld,metrics:()=>dR,min:()=>Xp,minimum:()=>Bd,mirrorPad:()=>Ud,mod:()=>Gd,model:()=>yC,models:()=>CR,moments:()=>jd,movingAverage:()=>Zm,mul:()=>el,multiRNNCell:()=>Kd,multinomial:()=>Jd,neg:()=>rd,nextFrame:()=>Yx,norm:()=>oc,notEqual:()=>Zd,oneHot:()=>eh,ones:()=>Pd,onesLike:()=>nh,op:()=>ai,outerProduct:()=>ah,pad:()=>ih,pad1d:()=>lh,pad2d:()=>ph,pad3d:()=>dh,pad4d:()=>fh,pool:()=>vh,pow:()=>Yp,prelu:()=>kh,print:()=>So,prod:()=>Sh,profile:()=>Fo,raggedGather:()=>Th,raggedRange:()=>Ch,raggedTensorToTensor:()=>Ah,rand:()=>Rh,randomGamma:()=>Qh,randomNormal:()=>tf,randomStandardNormal:()=>rf,randomUniform:()=>sf,range:()=>of,ready:()=>zo,real:()=>uf,reciprocal:()=>cf,registerBackend:()=>Go,registerCallbackConstructor:()=>vC,registerGradient:()=>xa,registerKernel:()=>ba,registerOp:()=>VR,regularizers:()=>ER,relu:()=>hf,relu6:()=>mf,removeBackend:()=>Wo,reshape:()=>ql,reverse:()=>yf,reverse1d:()=>xf,reverse2d:()=>wf,reverse3d:()=>If,reverse4d:()=>Nf,rfft:()=>om,round:()=>_f,rsqrt:()=>Ef,scalar:()=>Zp,scatterND:()=>eg,scatter_util:()=>Tm,searchSorted:()=>Sd,selu:()=>$f,separableConv2d:()=>Ff,sequential:()=>bC,serialization:()=>kb,setBackend:()=>Lo,setPlatform:()=>jo,setThreadsCount:()=>nae,setWasmPath:()=>Zre,setWasmPaths:()=>Qre,setWebGLContext:()=>nH,setdiff1dAsync:()=>Mf,shared:()=>TO,sigmoid:()=>ru,sign:()=>Pf,signal:()=>gb,sin:()=>zf,sinh:()=>Wf,slice:()=>su,slice1d:()=>Vf,slice2d:()=>Hf,slice3d:()=>qf,slice4d:()=>Xf,slice_util:()=>Tx,softmax:()=>Yf,softplus:()=>sd,spaceToBatchND:()=>gh,sparse:()=>vb,sparseToDense:()=>rg,spectral:()=>mb,split:()=>sm,sqrt:()=>ec,square:()=>nc,squaredDifference:()=>um,squeeze:()=>cm,stack:()=>hm,step:()=>mm,stridedSlice:()=>ym,string:()=>wb,sub:()=>ud,sum:()=>ac,sumOutType:()=>Es,tan:()=>xm,tanh:()=>ou,tensor:()=>li,tensor1d:()=>vm,tensor2d:()=>wm,tensor3d:()=>km,tensor4d:()=>Im,tensor5d:()=>Sm,tensor6d:()=>Nm,tensorScatterUpdate:()=>$m,tensor_util:()=>Ts,test_util:()=>Dh,tidy:()=>Do,tile:()=>yc,time:()=>Po,topk:()=>Fm,train:()=>Xx,transpose:()=>Jm,truncatedNormal:()=>Mm,unique:()=>Pm,unregisterGradient:()=>wa,unregisterKernel:()=>va,unsortedSegmentSum:()=>zm,unstack:()=>Wm,upcastType:()=>Cs,upperBound:()=>Um,util:()=>Sa,valueAndGrad:()=>Yc,valueAndGrads:()=>Zc,variable:()=>Vm,variableGrads:()=>Qc,version:()=>cae,version_converter:()=>rM,version_core:()=>qx,version_cpu:()=>rz,version_layers:()=>D_,version_wasm:()=>aae,version_webgl:()=>AX,webgl:()=>RX,webgl_util:()=>JG,where:()=>Np,whereAsync:()=>jm,zeros:()=>Od,zerosLike:()=>_p});var u=Object.create,p=Object.defineProperty,c=Object.getOwnPropertyDescriptor,d=Object.getOwnPropertyNames,h=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty,m=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),g=(e,t)=>{for(var n in t)p(e,n,{get:t[n],enumerable:!0})},y=(e,t,n,r)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let a of d(t))!f.call(e,a)&&a!==n&&p(e,a,{get:()=>t[a],enumerable:!(r=c(t,a))||r.enumerable});return e},b=(e,t,n)=>(n=null!=e?u(h(e)):{},y(!t&&e&&e.__esModule?n:p(n,"default",{value:e,enumerable:!0}),e)),x=m(((e,t)=>{t.exports=r;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(C){}function r(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function a(e){return!0===(e&&e.__isLong__)}r.prototype.__isLong__,Object.defineProperty(r.prototype,"__isLong__",{value:!0}),r.isLong=a;var s={},i={};function o(e,t){var n,r,a;return t?(e>>>=0,(a=0<=e&&e<256)&&(r=i[e],r)?r:(n=u(e,(0|e)<0?-1:0,!0),a&&(i[e]=n),n)):(e|=0,(a=-128<=e&&e<128)&&(r=s[e],r)?r:(n=u(e,e<0?-1:0,!1),a&&(s[e]=n),n))}function l(e,t){if(isNaN(e))return t?v:x;if(t){if(e<0)return v;if(e>=g)return N}else{if(e<=-y)return T;if(e+1>=y)return S}return e<0?l(-e,t).neg():u(e%m|0,e/m|0,t)}function u(e,t,n){return new r(e,t,n)}r.fromInt=o,r.fromNumber=l,r.fromBits=u;var p=Math.pow;function c(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return x;if("number"==typeof t?(n=t,t=!1):t=!!t,n=n||10,n<2||36<n)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return c(e.substring(1),t,n).neg();for(var a=l(p(n,8)),s=x,i=0;i<e.length;i+=8){var o=Math.min(8,e.length-i),u=parseInt(e.substring(i,i+o),n);if(o<8){var d=l(p(n,o));s=s.mul(d).add(l(u))}else s=s.mul(a),s=s.add(l(u))}return s.unsigned=t,s}function d(e,t){return"number"==typeof e?l(e,t):"string"==typeof e?c(e,t):u(e.low,e.high,"boolean"==typeof t?t:e.unsigned)}r.fromString=c,r.fromValue=d;var h=65536,f=1<<24,m=h*h,g=m*m,y=g/2,b=o(f),x=o(0);r.ZERO=x;var v=o(0,!0);r.UZERO=v;var w=o(1);r.ONE=w;var k=o(1,!0);r.UONE=k;var I=o(-1);r.NEG_ONE=I;var S=u(-1,2147483647,!1);r.MAX_VALUE=S;var N=u(-1,-1,!0);r.MAX_UNSIGNED_VALUE=N;var T=u(0,-2147483648,!1);r.MIN_VALUE=T;var _=r.prototype;_.toInt=function(){return this.unsigned?this.low>>>0:this.low},_.toNumber=function(){return this.unsigned?(this.high>>>0)*m+(this.low>>>0):this.high*m+(this.low>>>0)},_.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(T)){var t=l(e),n=this.div(t),r=n.mul(t).sub(this);return n.toString(e)+r.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var a=l(p(e,6),this.unsigned),s=this,i="";;){var o=s.div(a),u=s.sub(o.mul(a)).toInt()>>>0,c=u.toString(e);if(s=o,s.isZero())return c+i;for(;c.length<6;)c="0"+c;i=""+c+i}},_.getHighBits=function(){return this.high},_.getHighBitsUnsigned=function(){return this.high>>>0},_.getLowBits=function(){return this.low},_.getLowBitsUnsigned=function(){return this.low>>>0},_.getNumBitsAbs=function(){if(this.isNegative())return this.eq(T)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&!(e&1<<t);t--);return 0!=this.high?t+33:t+1},_.isZero=function(){return 0===this.high&&0===this.low},_.eqz=_.isZero,_.isNegative=function(){return!this.unsigned&&this.high<0},_.isPositive=function(){return this.unsigned||this.high>=0},_.isOdd=function(){return 1===(1&this.low)},_.isEven=function(){return 0===(1&this.low)},_.equals=function(e){return a(e)||(e=d(e)),(this.unsigned===e.unsigned||this.high>>>31!==1||e.high>>>31!==1)&&(this.high===e.high&&this.low===e.low)},_.eq=_.equals,_.notEquals=function(e){return!this.eq(e)},_.neq=_.notEquals,_.ne=_.notEquals,_.lessThan=function(e){return this.comp(e)<0},_.lt=_.lessThan,_.lessThanOrEqual=function(e){return this.comp(e)<=0},_.lte=_.lessThanOrEqual,_.le=_.lessThanOrEqual,_.greaterThan=function(e){return this.comp(e)>0},_.gt=_.greaterThan,_.greaterThanOrEqual=function(e){return this.comp(e)>=0},_.gte=_.greaterThanOrEqual,_.ge=_.greaterThanOrEqual,_.compare=function(e){if(a(e)||(e=d(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},_.comp=_.compare,_.negate=function(){return!this.unsigned&&this.eq(T)?T:this.not().add(w)},_.neg=_.negate,_.add=function(e){a(e)||(e=d(e));var t=this.high>>>16,n=65535&this.high,r=this.low>>>16,s=65535&this.low,i=e.high>>>16,o=65535&e.high,l=e.low>>>16,p=65535&e.low,c=0,h=0,f=0,m=0;return m+=s+p,f+=m>>>16,m&=65535,f+=r+l,h+=f>>>16,f&=65535,h+=n+o,c+=h>>>16,h&=65535,c+=t+i,c&=65535,u(f<<16|m,c<<16|h,this.unsigned)},_.subtract=function(e){return a(e)||(e=d(e)),this.add(e.neg())},_.sub=_.subtract,_.multiply=function(e){if(this.isZero())return x;if(a(e)||(e=d(e)),n){var t=n.mul(this.low,this.high,e.low,e.high);return u(t,n.get_high(),this.unsigned)}if(e.isZero())return x;if(this.eq(T))return e.isOdd()?T:x;if(e.eq(T))return this.isOdd()?T:x;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(b)&&e.lt(b))return l(this.toNumber()*e.toNumber(),this.unsigned);var r=this.high>>>16,s=65535&this.high,i=this.low>>>16,o=65535&this.low,p=e.high>>>16,c=65535&e.high,h=e.low>>>16,f=65535&e.low,m=0,g=0,y=0,v=0;return v+=o*f,y+=v>>>16,v&=65535,y+=i*f,g+=y>>>16,y&=65535,y+=o*h,g+=y>>>16,y&=65535,g+=s*f,m+=g>>>16,g&=65535,g+=i*h,m+=g>>>16,g&=65535,g+=o*c,m+=g>>>16,g&=65535,m+=r*f+s*h+i*c+o*p,m&=65535,u(y<<16|v,m<<16|g,this.unsigned)},_.mul=_.multiply,_.divide=function(e){if(a(e)||(e=d(e)),e.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&-2147483648===this.high&&-1===e.low&&-1===e.high)return this;var t=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,e.low,e.high);return u(t,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?v:x;var r,s,i;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return v;if(e.gt(this.shru(1)))return k;i=v}else{if(this.eq(T)){if(e.eq(w)||e.eq(I))return T;if(e.eq(T))return w;var o=this.shr(1);return r=o.div(e).shl(1),r.eq(x)?e.isNegative()?w:I:(s=this.sub(e.mul(r)),i=r.add(s.div(e)),i)}if(e.eq(T))return this.unsigned?v:x;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();i=x}for(s=this;s.gte(e);){r=Math.max(1,Math.floor(s.toNumber()/e.toNumber()));for(var c=Math.ceil(Math.log(r)/Math.LN2),h=c<=48?1:p(2,c-48),f=l(r),m=f.mul(e);m.isNegative()||m.gt(s);)r-=h,f=l(r,this.unsigned),m=f.mul(e);f.isZero()&&(f=w),i=i.add(f),s=s.sub(m)}return i},_.div=_.divide,_.modulo=function(e){if(a(e)||(e=d(e)),n){var t=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,e.low,e.high);return u(t,n.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))},_.mod=_.modulo,_.rem=_.modulo,_.not=function(){return u(~this.low,~this.high,this.unsigned)},_.and=function(e){return a(e)||(e=d(e)),u(this.low&e.low,this.high&e.high,this.unsigned)},_.or=function(e){return a(e)||(e=d(e)),u(this.low|e.low,this.high|e.high,this.unsigned)},_.xor=function(e){return a(e)||(e=d(e)),u(this.low^e.low,this.high^e.high,this.unsigned)},_.shiftLeft=function(e){return a(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?u(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):u(0,this.low<<e-32,this.unsigned)},_.shl=_.shiftLeft,_.shiftRight=function(e){return a(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?u(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):u(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},_.shr=_.shiftRight,_.shiftRightUnsigned=function(e){if(a(e)&&(e=e.toInt()),e&=63,0===e)return this;var t=this.high;if(e<32){var n=this.low;return u(n>>>e|t<<32-e,t>>>e,this.unsigned)}return u(32===e?t:t>>>e-32,0,this.unsigned)},_.shru=_.shiftRightUnsigned,_.shr_u=_.shiftRightUnsigned,_.toSigned=function(){return this.unsigned?u(this.low,this.high,!1):this},_.toUnsigned=function(){return this.unsigned?this:u(this.low,this.high,!0)},_.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},_.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},_.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},r.fromBytes=function(e,t,n){return n?r.fromBytesLE(e,t):r.fromBytesBE(e,t)},r.fromBytesLE=function(e,t){return new r(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},r.fromBytesBE=function(e,t){return new r(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}})),v=m((()=>{})),w=m((()=>{})),k=m(((e,t)=>{(function(e,t,n){function r(e){var t=this,n=i();t.next=function(){var e=2091639*t.s0+2.3283064365386963e-10*t.c;return t.s0=t.s1,t.s1=t.s2,t.s2=e-(t.c=0|e)},t.c=1,t.s0=n(" "),t.s1=n(" "),t.s2=n(" "),t.s0-=n(e),t.s0<0&&(t.s0+=1),t.s1-=n(e),t.s1<0&&(t.s1+=1),t.s2-=n(e),t.s2<0&&(t.s2+=1),n=null}function a(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function s(e,t){var n=new r(e),s=t&&t.state,i=n.next;return i.int32=function(){return 4294967296*n.next()|0},i.double=function(){return i()+11102230246251565e-32*(2097152*i()|0)},i.quick=i,s&&("object"==typeof s&&a(s,n),i.state=function(){return a(n,{})}),i}function i(){var e=4022871197,t=function(t){t=String(t);for(var n=0;n<t.length;n++){e+=t.charCodeAt(n);var r=.02519603282416938*e;e=r>>>0,r-=e,r*=e,e=r>>>0,r-=e,e+=4294967296*r}return 2.3283064365386963e-10*(e>>>0)};return t}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.alea=s})(0,"object"==typeof t&&t,"function"==typeof define&&define)})),I=m(((e,t)=>{(function(e,t,n){function r(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function a(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function s(e,t){var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21)}while(0===r);return r},i.int32=n.next,i.quick=i,s&&("object"==typeof s&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xor128=s})(0,"object"==typeof t&&t,"function"==typeof define&&define)})),S=m(((e,t)=>{(function(e,t,n){function r(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function a(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function s(e,t){var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21)}while(0===r);return r},i.int32=n.next,i.quick=i,s&&("object"==typeof s&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xorwow=s})(0,"object"==typeof t&&t,"function"==typeof define&&define)})),N=m(((e,t)=>{(function(e,t,n){function r(e){var t=this;function n(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}t.next=function(){var e,n,r=t.x,a=t.i;return e=r[a],e^=e>>>7,n=e^e<<24,e=r[a+1&7],n^=e^e>>>10,e=r[a+3&7],n^=e^e>>>3,e=r[a+4&7],n^=e^e<<7,e=r[a+7&7],e^=e<<13,n^=e^e<<9,r[a]=n,t.i=a+1&7,n},n(t,e)}function a(e,t){return t.x=e.x.slice(),t.i=e.i,t}function s(e,t){null==e&&(e=+new Date);var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21)}while(0===r);return r},i.int32=n.next,i.quick=i,s&&(s.x&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xorshift7=s})(0,"object"==typeof t&&t,"function"==typeof define&&define)})),T=m(((e,t)=>{(function(e,t,n){function r(e){var t=this;function n(e,t){var n,r,a,s,i,o=[],l=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,l=Math.max(l,t.length)),a=0,s=-32;s<l;++s)t&&(r^=t.charCodeAt((s+32)%t.length)),0===s&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,s>=0&&(i=i+1640531527|0,n=o[127&s]^=r+i,a=0==n?a+1:0);for(a>=128&&(o[127&(t&&t.length||0)]=-1),a=127,s=512;s>0;--s)r=o[a+34&127],n=o[a=a+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,o[a]=r^n;e.w=i,e.X=o,e.i=a}t.next=function(){var e,n,r=t.w,a=t.X,s=t.i;return t.w=r=r+1640531527|0,n=a[s+34&127],e=a[s=s+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=a[s]=n^e,t.i=s,n+(r^r>>>16)|0},n(t,e)}function a(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function s(e,t){null==e&&(e=+new Date);var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21)}while(0===r);return r},i.int32=n.next,i.quick=i,s&&(s.X&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xor4096=s})(0,"object"==typeof t&&t,"function"==typeof define&&define)})),_=m(((e,t)=>{(function(e,t,n){function r(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,a=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^a,a=a-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^a,t.a=a-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function a(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function s(e,t){var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21)}while(0===r);return r},i.int32=n.next,i.quick=i,s&&("object"==typeof s&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.tychei=s})(0,"object"==typeof t&&t,"function"==typeof define&&define)})),C=m((()=>{})),E=m(((e,t)=>{(function(e,r,a){var s,i=256,o=6,l=52,u="random",p=a.pow(i,o),c=a.pow(2,l),d=2*c,h=i-1;function f(e,t,n){var s=[];t=1==t?{entropy:!0}:t||{};var l=b(y(t.entropy?[e,v(r)]:null==e?x():e,3),s),h=new m(s),f=function(){for(var e=h.g(o),t=p,n=0;e<c;)e=(e+n)*i,t*=i,n=h.g(1);for(;e>=d;)e/=2,t/=2,n>>>=1;return(e+n)/t};return f.int32=function(){return 0|h.g(4)},f.quick=function(){return h.g(4)/4294967296},f.double=f,b(v(h.S),r),(t.pass||n||function(e,t,n,r){return r&&(r.S&&g(r,h),e.state=function(){return g(h,{})}),n?(a[u]=e,t):e})(f,l,"global"in t?t.global:this==a,t.state)}function m(e){var t,n=e.length,r=this,a=0,s=r.i=r.j=0,o=r.S=[];for(n||(e=[n++]);a<i;)o[a]=a++;for(a=0;a<i;a++)o[a]=o[s=h&s+e[a%n]+(t=o[a])],o[s]=t;(r.g=function(e){for(var t,n=0,a=r.i,s=r.j,o=r.S;e--;)t=o[a=h&a+1],n=n*i+o[h&(o[a]=o[s=h&s+t])+(o[s]=t)];return r.i=a,r.j=s,n})(i)}function g(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function y(e,t){var n,r=[],a=typeof e;if(t&&"object"==a)for(n in e)try{r.push(y(e[n],t-1))}catch(s){}return r.length?r:"string"==a?e:e+"\0"}function b(e,t){for(var n,r=e+"",a=0;a<r.length;)t[h&a]=h&(n^=19*t[h&a])+r.charCodeAt(a++);return v(t)}function x(){try{var t;return s&&(t=s.randomBytes)?t=t(i):(t=new Uint8Array(i),(e.crypto||e.msCrypto).getRandomValues(t)),v(t)}catch(o){var n=e.navigator,a=n&&n.plugins;return[+new Date,e,a,e.screen,v(r)]}}function v(e){return String.fromCharCode.apply(0,e)}if(b(a.random(),r),"object"==typeof t&&t.exports){t.exports=f;try{s=C()}catch(w){}}else"function"==typeof define&&n.amdO?define((function(){return f})):a["seed"+u]=f})("undefined"!=typeof self?self:e,[],Math)})),A=m(((e,t)=>{var n=k(),r=I(),a=S(),s=N(),i=T(),o=_(),l=E();l.alea=n,l.xor128=r,l.xorwow=a,l.xorshift7=s,l.xor4096=i,l.tychei=o,t.exports=l})),$=m((()=>{})),R=m((()=>{})),F=m((()=>{})),D=m((()=>{})),M=m((()=>{})),O=m((()=>{})),P=m(((e,t)=>{var s=(()=>{var e="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0;return e=e||r,function(t){function r(){return z.buffer!=G&&te(z.buffer),H}function s(){return z.buffer!=G&&te(z.buffer),j}function i(){return z.buffer!=G&&te(z.buffer),q}function o(){return z.buffer!=G&&te(z.buffer),K}function l(){return z.buffer!=G&&te(z.buffer),X}t=t||{};var u,p,c,d="undefined"!=typeof t?t:{};d.ready=new Promise((function(e,t){u=e,p=t})),"undefined"!=typeof process&&process.listeners&&(c={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var h,f,m,g=Object.assign({},d),y=[],b=(e,t)=>{throw t},x="object"==typeof window,v="function"==typeof importScripts,w="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,k=d.ENVIRONMENT_IS_PTHREAD||!1,I="";function S(e){return d.locateFile?d.locateFile(e,I):I+e}function N(e){e instanceof Ce||$("exiting due to exception: "+e)}if(w){var T=R(),_=F();let e;I=v?_.dirname(I)+"/":a+"/",h=(e,t)=>(e=Ie(e)?new URL(e):_.normalize(e),T.readFileSync(e,t?void 0:"utf8")),m=e=>{var t=h(e,!0);return t.buffer||(t=new Uint8Array(t)),t},f=(e,t,n)=>{e=Ie(e)?new URL(e):_.normalize(e),T.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),y=process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof Ce))throw e})),process.on("unhandledRejection",(function(e){throw e})),b=(e,t)=>{if(oe())throw process.exitCode=e,t;N(t),process.exit(e)},d.inspect=function(){return"[Emscripten Module object]"};try{e=D()}catch(Vt){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),Vt}n.g.Worker=e.Worker}else(x||v)&&(v?I=self.location.href:"undefined"!=typeof document&&document.currentScript&&(I=document.currentScript.src),"undefined"!=typeof e&&e&&(I=e),I=0!==I.indexOf("blob:")?I.substr(0,I.replace(/[?#].*/,"").lastIndexOf("/")+1):"",w||(h=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},v&&(m=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),f=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)}),e=>document.title=e);w&&"undefined"==typeof performance&&(n.g.performance=M().performance);var C=console.log.bind(console),E=console.warn.bind(console);w&&(C=e=>T.writeSync(1,e+"\n"),E=e=>T.writeSync(2,e+"\n"));var A=d.print||C,$=d.printErr||E;Object.assign(d,g),g=null,d.arguments&&(y=d.arguments),d.thisProgram&&d.thisProgram,d.quit&&(b=d.quit);var P;Atomics.load,Atomics.store,Atomics.compareExchange;d.wasmBinary&&(P=d.wasmBinary);var L=d.noExitRuntime||!0;"object"!=typeof WebAssembly&&xe("no native wasm support detected");var z,B,W,U=!1;function V(e,t){e||xe(t)}var G,H,j,q,K,X,J="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function Y(e,t,n){for(var r=t+n,a=t;e[a]&&!(a>=r);)++a;if(a-t>16&&e.buffer&&J)return J.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,a):e.subarray(t,a));for(var s="";t<a;){var i=e[t++];if(128&i){var o=63&e[t++];if(192!=(224&i)){var l=63&e[t++];if(i=224==(240&i)?(15&i)<<12|o<<6|l:(7&i)<<18|o<<12|l<<6|63&e[t++],i<65536)s+=String.fromCharCode(i);else{var u=i-65536;s+=String.fromCharCode(55296|u>>10,56320|1023&u)}}else s+=String.fromCharCode((31&i)<<6|o)}else s+=String.fromCharCode(i)}return s}function Z(e,t){return e?Y(s(),e,t):""}function Q(e,t,n,r){if(!(r>0))return 0;for(var a=n,s=n+r-1,i=0;i<e.length;++i){var o=e.charCodeAt(i);if(o>=55296&&o<=57343){var l=e.charCodeAt(++i);o=65536+((1023&o)<<10)|1023&l}if(o<=127){if(n>=s)break;t[n++]=o}else if(o<=2047){if(n+1>=s)break;t[n++]=192|o>>6,t[n++]=128|63&o}else if(o<=65535){if(n+2>=s)break;t[n++]=224|o>>12,t[n++]=128|o>>6&63,t[n++]=128|63&o}else{if(n+3>=s)break;t[n++]=240|o>>18,t[n++]=128|o>>12&63,t[n++]=128|o>>6&63,t[n++]=128|63&o}}return t[n]=0,n-a}function ee(e,t,n){return Q(e,s(),t,n)}function te(e){G=e,d.HEAP8=H=new Int8Array(e),d.HEAP16=new Int16Array(e),d.HEAP32=q=new Int32Array(e),d.HEAPU8=j=new Uint8Array(e),d.HEAPU16=new Uint16Array(e),d.HEAPU32=K=new Uint32Array(e),d.HEAPF32=new Float32Array(e),d.HEAPF64=X=new Float64Array(e)}k&&(G=d.buffer);var ne=d.INITIAL_MEMORY||16777216;if(k)z=d.wasmMemory,G=d.buffer;else if(d.wasmMemory)z=d.wasmMemory;else if(z=new WebAssembly.Memory({initial:ne/65536,maximum:32768,shared:!0}),!(z.buffer instanceof SharedArrayBuffer))throw $("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),w&&$("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");z&&(G=z.buffer),ne=G.byteLength,te(G);var re,ae=[],se=[],ie=[];function oe(){return L}function le(){if(d.preRun)for("function"==typeof d.preRun&&(d.preRun=[d.preRun]);d.preRun.length;)ce(d.preRun.shift());Le(ae)}function ue(){!0,!k&&Le(se)}function pe(){if(!k){if(d.postRun)for("function"==typeof d.postRun&&(d.postRun=[d.postRun]);d.postRun.length;)he(d.postRun.shift());Le(ie)}}function ce(e){ae.unshift(e)}function de(e){se.unshift(e)}function he(e){ie.unshift(e)}var fe=0,me=null,ge=null;function ye(e){fe++,d.monitorRunDependencies&&d.monitorRunDependencies(fe)}function be(e){if(fe--,d.monitorRunDependencies&&d.monitorRunDependencies(fe),0==fe&&(null!==me&&(clearInterval(me),me=null),ge)){var t=ge;ge=null,t()}}function xe(e){d.onAbort&&d.onAbort(e),e="Aborted("+e+")",$(e),U=!0,W=1,e+=". Build with -sASSERTIONS for more info.";var t=new WebAssembly.RuntimeError(e);throw p(t),t}var ve,we="data:application/octet-stream;base64,";function ke(e){return e.startsWith(we)}function Ie(e){return e.startsWith("file://")}function Se(e){try{if(e==ve&&P)return new Uint8Array(P);if(m)return m(e);throw"both async and sync fetching of the wasm failed"}catch(Vt){xe(Vt)}}function Ne(){if(!P&&(x||v)){if("function"==typeof fetch&&!Ie(ve))return fetch(ve,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at '"+ve+"'";return e.arrayBuffer()})).catch((function(){return Se(ve)}));if(f)return new Promise((function(e,t){f(ve,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return Se(ve)}))}function Te(){var e={env:At,wasi_snapshot_preview1:At};function t(e,t){var n=e.exports;if(d.asm=n,Ge(d.asm._emscripten_tls_init),re=d.asm.__indirect_function_table,de(d.asm.__wasm_call_ctors),B=t,!k){var r=Pe.unusedWorkers.length;Pe.unusedWorkers.forEach((function(e){Pe.loadWasmModuleToWorker(e,(function(){--r||be("wasm-instantiate")}))}))}}function n(e){t(e.instance,e.module)}function r(t){return Ne().then((function(t){return WebAssembly.instantiate(t,e)})).then((function(e){return e})).then(t,(function(e){$("failed to asynchronously prepare wasm: "+e),xe(e)}))}function a(){return P||"function"!=typeof WebAssembly.instantiateStreaming||ke(ve)||Ie(ve)||w||"function"!=typeof fetch?r(n):fetch(ve,{credentials:"same-origin"}).then((function(t){var a=WebAssembly.instantiateStreaming(t,e);return a.then(n,(function(e){return $("wasm streaming compile failed: "+e),$("falling back to ArrayBuffer instantiation"),r(n)}))}))}if(k||ye("wasm-instantiate"),d.instantiateWasm)try{var s=d.instantiateWasm(e,t);return s}catch(i){$("Module.instantiateWasm callback failed with error: "+i),p(i)}return a().catch(p),{}}ve="tfjs-backend-wasm-threaded-simd.wasm",ke(ve)||(ve=S(ve));var _e={};function Ce(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function Ee(e){var t=Pe.pthreads[e];delete Pe.pthreads[e],t.terminate(),Mt(e),Pe.runningWorkers.splice(Pe.runningWorkers.indexOf(t),1),t.pthread_ptr=0}function Ae(e){var t=Pe.pthreads[e];t.postMessage({cmd:"cancel"})}function $e(e){var t=Pe.pthreads[e];V(t),Pe.returnWorkerToPool(t)}function Re(e){var t=Pe.getNewWorker();if(!t)return 6;Pe.runningWorkers.push(t),Pe.pthreads[e.pthread_ptr]=t,t.pthread_ptr=e.pthread_ptr;var n={cmd:"run",start_routine:e.startRoutine,arg:e.arg,pthread_ptr:e.pthread_ptr};return t.runPthread=()=>{w&&t.ref(),t.postMessage(n,e.transferList),delete t.runPthread},t.loaded&&t.runPthread(),0}function Fe(e){if(k)return ct(1,1,e);W=e,oe()||(Pe.terminateAllThreads(),d.onExit&&d.onExit(e),U=!0),b(e,new Ce(e))}function De(e,t){if(W=e,!t&&k)throw Be(e),"unwind";Fe(e)}var Me=De;function Oe(e){if(e instanceof Ce||"unwind"==e)return W;b(1,e)}var Pe={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init:function(){k?Pe.initWorker():Pe.initMainThread()},initMainThread:function(){for(var e=8;e--;)Pe.allocateUnusedWorker()},initWorker:function(){L=!1},setExitStatus:function(e){W=e},terminateAllThreads:function(){for(var e of Object.values(Pe.pthreads))Pe.returnWorkerToPool(e);for(var e of Pe.unusedWorkers)e.terminate();Pe.unusedWorkers=[]},returnWorkerToPool:function(e){var t=e.pthread_ptr;delete Pe.pthreads[t],Pe.unusedWorkers.push(e),Pe.runningWorkers.splice(Pe.runningWorkers.indexOf(e),1),e.pthread_ptr=0,w&&e.unref(),Mt(t)},receiveObjectTransfer:function(e){},threadInitTLS:function(){Pe.tlsInitFunctions.forEach((e=>e()))},loadWasmModuleToWorker:function(t,n){t.onmessage=e=>{var r=e.data,a=r.cmd;if(t.pthread_ptr&&(Pe.currentProxiedOperationCallerThread=t.pthread_ptr),r.targetThread&&r.targetThread!=$t()){var s=Pe.pthreads[r.targetThread];return s?s.postMessage(r,r.transferList):$('Internal error! Worker sent a message "'+a+'" to target pthread '+r.targetThread+", but that thread no longer exists!"),void(Pe.currentProxiedOperationCallerThread=void 0)}"processProxyingQueue"===a?Qe(r.queue):"spawnThread"===a?Re(r):"cleanupThread"===a?$e(r.thread):"killThread"===a?Ee(r.thread):"cancelThread"===a?Ae(r.thread):"loaded"===a?(t.loaded=!0,w&&t.unref(),n&&n(t),t.runPthread&&t.runPthread()):"print"===a?A("Thread "+r.threadId+": "+r.text):"printErr"===a?$("Thread "+r.threadId+": "+r.text):"alert"===a?alert("Thread "+r.threadId+": "+r.text):"setimmediate"===r.target?t.postMessage(r):"callHandler"===a?d[r.handler](...r.args):a&&$("worker sent an unknown command "+a),Pe.currentProxiedOperationCallerThread=void 0},t.onerror=e=>{var t="worker sent an error!";throw $(t+" "+e.filename+":"+e.lineno+": "+e.message),e},w&&(t.on("message",(function(e){t.onmessage({data:e})})),t.on("error",(function(e){t.onerror(e)})),t.on("detachedExit",(function(){})));var r=[],a=["onExit","onAbort","print","printErr"];for(var s of a)d.hasOwnProperty(s)&&r.push(s);t.postMessage({cmd:"load",handlers:r,urlOrBlob:d.mainScriptUrlOrBlob||e,wasmMemory:z,wasmModule:B})},allocateUnusedWorker:function(){var e,t=S("tfjs-backend-wasm-threaded-simd.worker.js");e=new Worker(t),Pe.unusedWorkers.push(e)},getNewWorker:function(){return 0==Pe.unusedWorkers.length&&(Pe.allocateUnusedWorker(),Pe.loadWasmModuleToWorker(Pe.unusedWorkers[0])),Pe.unusedWorkers.pop()}};function Le(e){for(;e.length>0;)e.shift()(d)}function ze(){var e=$t(),t=i()[e+52>>2],n=i()[e+56>>2],r=t-n;Pt(t,r),zt(t)}function Be(e){if(k)return ct(2,0,e);try{Me(e)}catch(Vt){Oe(Vt)}}d.PThread=Pe,d.establishStackSpace=ze;var We=[];function Ue(e){var t=We[e];return t||(e>=We.length&&(We.length=e+1),We[e]=t=re.get(e)),t}function Ve(e,t){var n=Ue(e)(t);oe()?Pe.setExitStatus(n):Ot(n)}function Ge(e){Pe.tlsInitFunctions.push(e)}function He(e){Rt(e,!v,1,!x),Pe.threadInitTLS()}function je(e){k?postMessage({cmd:"cleanupThread",thread:e}):$e(e)}function qe(e,t,n,r){return k?ct(3,1,e,t,n,r):Ke(e,t,n,r)}function Ke(e,t,n,r){if("undefined"==typeof SharedArrayBuffer)return $("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[],s=0;if(k&&(0===a.length||s))return qe(e,t,n,r);if(s)return s;var i={startRoutine:n,pthread_ptr:e,arg:r,transferList:a};return k?(i.cmd="spawnThread",postMessage(i,a),0):Re(i)}function Xe(){return 65536}d.invokeEntryPoint=Ve;var Je,Ye=!0;function Ze(){return Ye}function Qe(e){Atomics.store(i(),e>>2,1),$t()&&Dt(e),Atomics.compareExchange(i(),e>>2,1,0)}function et(e,t,n,r){if(e==t)setTimeout((()=>Qe(r)));else if(k)postMessage({targetThread:e,cmd:"processProxyingQueue",queue:r});else{var a=Pe.pthreads[e];if(!a)return;a.postMessage({cmd:"processProxyingQueue",queue:r})}return 1}function tt(e,t,n){return-1}function nt(){xe("")}function rt(e){rt.shown||(rt.shown={}),rt.shown[e]||(rt.shown[e]=1,w&&(e="warning: "+e),$(e))}function at(){w||v||rt("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")}function st(){return Date.now()}function it(){return 2147483648}function ot(){return it()}function lt(e,t,n){s().copyWithin(e,t,t+n)}function ut(){return w?O().cpus().length:navigator.hardwareConcurrency}function pt(e){var t=Lt(),n=e();return zt(t),n}function ct(e,t){var n=arguments.length-2,r=arguments;return pt((()=>{for(var a=n,s=Bt(8*a),i=s>>3,o=0;o<n;o++){var u=r[2+o];l()[i+o]=u}return Ft(e,a,s,t)}))}d.executeNotifiedProxyingQueue=Qe,Je=w?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:()=>performance.timeOrigin+performance.now();var dt=[];function ht(e,t,n){dt.length=t;for(var r=n>>3,a=0;a<t;a++)dt[a]=l()[r+a];var s=e<0,i=s?_e[-e-1]:Et[e];return i.apply(null,dt)}function ft(e){try{return z.grow(e-G.byteLength+65535>>>16),te(z.buffer),1}catch(Vt){}}function mt(e){var t=s().length;if(e>>>=0,e<=t)return!1;var n=it();if(e>n)return!1;let r=(e,t)=>e+(t-e%t)%t;for(var a=1;a<=4;a*=2){var i=t*(1+.2/a);i=Math.min(i,e+100663296);var o=Math.min(n,r(Math.max(e,i),65536)),l=ft(o);if(l)return!0}return!1}function gt(){throw"unwind"}function yt(e){return k?ct(4,1,e):52}function bt(e,t,n,r,a){return k?ct(5,1,e,t,n,r,a):70}var xt=[null,[],[]];function vt(e,t){var n=xt[e];0===t||10===t?((1===e?A:$)(Y(n,0)),n.length=0):n.push(t)}function wt(e,t,n,r){if(k)return ct(6,1,e,t,n,r);for(var a=0,i=0;i<n;i++){var l=o()[t>>2],u=o()[t+4>>2];t+=8;for(var p=0;p<u;p++)vt(e,s()[l+p]);a+=u}return o()[r>>2]=a,0}function kt(e){var t=d["_"+e];return t}function It(e,t){r().set(e,t)}function St(e,t,n,r,a){var s={string:e=>{var t=0;if(null!=e&&0!==e){var n=1+(e.length<<2);t=Bt(n),ee(e,t,n)}return t},array:e=>{var t=Bt(e.length);return It(e,t),t}};function i(e){return"string"===t?Z(e):"boolean"===t?!!e:e}var o=kt(e),l=[],u=0;if(r)for(var p=0;p<r.length;p++){var c=s[n[p]];c?(0===u&&(u=Lt()),l[p]=c(r[p])):l[p]=r[p]}var d=o.apply(null,l);function h(e){return 0!==u&&zt(u),i(e)}return d=h(d),d}function Nt(e,t,n,r){n=n||[];var a=n.every((e=>"number"===e||"boolean"===e)),s="string"!==t;return s&&a&&!r?kt(e):function(){return St(e,t,n,arguments,r)}}Pe.init();var Tt,_t,Ct,Et=[null,Fe,Be,qe,yt,bt,wt],At={__emscripten_init_main_thread_js:He,__emscripten_thread_cleanup:je,__pthread_create_js:Ke,_emscripten_default_pthread_stack_size:Xe,_emscripten_get_now_is_monotonic:Ze,_emscripten_notify_task_queue:et,_emscripten_set_offscreencanvas_size:tt,abort:nt,emscripten_check_blocking_allowed:at,emscripten_date_now:st,emscripten_get_heap_max:ot,emscripten_get_now:Je,emscripten_memcpy_big:lt,emscripten_num_logical_cores:ut,emscripten_receive_on_main_thread_js:ht,emscripten_resize_heap:mt,emscripten_unwind_to_js_event_loop:gt,exit:Me,fd_close:yt,fd_seek:bt,fd_write:wt,memory:z||d.wasmMemory},$t=(Te(),d.___wasm_call_ctors=function(){return(d.___wasm_call_ctors=d.asm.__wasm_call_ctors).apply(null,arguments)},d._init=function(){return(d._init=d.asm.init).apply(null,arguments)},d._init_with_threads_count=function(){return(d._init_with_threads_count=d.asm.init_with_threads_count).apply(null,arguments)},d._get_threads_count=function(){return(d._get_threads_count=d.asm.get_threads_count).apply(null,arguments)},d._register_tensor=function(){return(d._register_tensor=d.asm.register_tensor).apply(null,arguments)},d._dispose_data=function(){return(d._dispose_data=d.asm.dispose_data).apply(null,arguments)},d._dispose=function(){return(d._dispose=d.asm.dispose).apply(null,arguments)},d._Abs=function(){return(d._Abs=d.asm.Abs).apply(null,arguments)},d._Acos=function(){return(d._Acos=d.asm.Acos).apply(null,arguments)},d._Acosh=function(){return(d._Acosh=d.asm.Acosh).apply(null,arguments)},d._Add=function(){return(d._Add=d.asm.Add).apply(null,arguments)},d._AddN=function(){return(d._AddN=d.asm.AddN).apply(null,arguments)},d._All=function(){return(d._All=d.asm.All).apply(null,arguments)},d._Any=function(){return(d._Any=d.asm.Any).apply(null,arguments)},d._ArgMax=function(){return(d._ArgMax=d.asm.ArgMax).apply(null,arguments)},d._ArgMin=function(){return(d._ArgMin=d.asm.ArgMin).apply(null,arguments)},d._Asin=function(){return(d._Asin=d.asm.Asin).apply(null,arguments)},d._Asinh=function(){return(d._Asinh=d.asm.Asinh).apply(null,arguments)},d._Atan=function(){return(d._Atan=d.asm.Atan).apply(null,arguments)},d._Atan2=function(){return(d._Atan2=d.asm.Atan2).apply(null,arguments)},d._Atanh=function(){return(d._Atanh=d.asm.Atanh).apply(null,arguments)},d._AvgPool=function(){return(d._AvgPool=d.asm.AvgPool).apply(null,arguments)},d._AvgPool3D=function(){return(d._AvgPool3D=d.asm.AvgPool3D).apply(null,arguments)},d._AvgPool3DGrad=function(){return(d._AvgPool3DGrad=d.asm.AvgPool3DGrad).apply(null,arguments)},d._BatchMatMul=function(){return(d._BatchMatMul=d.asm.BatchMatMul).apply(null,arguments)},d._Bincount=function(){return(d._Bincount=d.asm.Bincount).apply(null,arguments)},d._Ceil=function(){return(d._Ceil=d.asm.Ceil).apply(null,arguments)},d._ClipByValue=function(){return(d._ClipByValue=d.asm.ClipByValue).apply(null,arguments)},d._Conv2D=function(){return(d._Conv2D=d.asm.Conv2D).apply(null,arguments)},d._Conv2DBackpropInput=function(){return(d._Conv2DBackpropInput=d.asm.Conv2DBackpropInput).apply(null,arguments)},d._Conv3D=function(){return(d._Conv3D=d.asm.Conv3D).apply(null,arguments)},d._Conv3DBackpropFilterV2=function(){return(d._Conv3DBackpropFilterV2=d.asm.Conv3DBackpropFilterV2).apply(null,arguments)},d._Conv3DBackpropInputV2=function(){return(d._Conv3DBackpropInputV2=d.asm.Conv3DBackpropInputV2).apply(null,arguments)},d._Cos=function(){return(d._Cos=d.asm.Cos).apply(null,arguments)},d._Cosh=function(){return(d._Cosh=d.asm.Cosh).apply(null,arguments)},d._CropAndResize=function(){return(d._CropAndResize=d.asm.CropAndResize).apply(null,arguments)},d._Cumprod=function(){return(d._Cumprod=d.asm.Cumprod).apply(null,arguments)},d._Cumsum=function(){return(d._Cumsum=d.asm.Cumsum).apply(null,arguments)},d._DenseBincount=function(){return(d._DenseBincount=d.asm.DenseBincount).apply(null,arguments)},d._DepthToSpace=function(){return(d._DepthToSpace=d.asm.DepthToSpace).apply(null,arguments)},d._DepthwiseConv2dNative=function(){return(d._DepthwiseConv2dNative=d.asm.DepthwiseConv2dNative).apply(null,arguments)},d._Diag=function(){return(d._Diag=d.asm.Diag).apply(null,arguments)},d._Dilation2D=function(){return(d._Dilation2D=d.asm.Dilation2D).apply(null,arguments)},d._Dilation2DBackpropFilter=function(){return(d._Dilation2DBackpropFilter=d.asm.Dilation2DBackpropFilter).apply(null,arguments)},d._Dilation2DBackpropInput=function(){return(d._Dilation2DBackpropInput=d.asm.Dilation2DBackpropInput).apply(null,arguments)},d._Elu=function(){return(d._Elu=d.asm.Elu).apply(null,arguments)},d._EluGrad=function(){return(d._EluGrad=d.asm.EluGrad).apply(null,arguments)},d._Equal=function(){return(d._Equal=d.asm.Equal).apply(null,arguments)},d._Exp=function(){return(d._Exp=d.asm.Exp).apply(null,arguments)},d._Expm1=function(){return(d._Expm1=d.asm.Expm1).apply(null,arguments)},d._FlipLeftRight=function(){return(d._FlipLeftRight=d.asm.FlipLeftRight).apply(null,arguments)},d._Floor=function(){return(d._Floor=d.asm.Floor).apply(null,arguments)},d._FloorDiv=function(){return(d._FloorDiv=d.asm.FloorDiv).apply(null,arguments)},d._FusedBatchNorm=function(){return(d._FusedBatchNorm=d.asm.FusedBatchNorm).apply(null,arguments)},d._FusedConv2D=function(){return(d._FusedConv2D=d.asm.FusedConv2D).apply(null,arguments)},d._FusedDepthwiseConv2D=function(){return(d._FusedDepthwiseConv2D=d.asm.FusedDepthwiseConv2D).apply(null,arguments)},d._Gather=function(){return(d._Gather=d.asm.Gather).apply(null,arguments)},d._GatherNd=function(){return(d._GatherNd=d.asm.GatherNd).apply(null,arguments)},d._Greater=function(){return(d._Greater=d.asm.Greater).apply(null,arguments)},d._GreaterEqual=function(){return(d._GreaterEqual=d.asm.GreaterEqual).apply(null,arguments)},d._IsFinite=function(){return(d._IsFinite=d.asm.IsFinite).apply(null,arguments)},d._IsInf=function(){return(d._IsInf=d.asm.IsInf).apply(null,arguments)},d._IsNan=function(){return(d._IsNan=d.asm.IsNan).apply(null,arguments)},d._LRN=function(){return(d._LRN=d.asm.LRN).apply(null,arguments)},d._LRNGrad=function(){return(d._LRNGrad=d.asm.LRNGrad).apply(null,arguments)},d._LeakyRelu=function(){return(d._LeakyRelu=d.asm.LeakyRelu).apply(null,arguments)},d._Less=function(){return(d._Less=d.asm.Less).apply(null,arguments)},d._LessEqual=function(){return(d._LessEqual=d.asm.LessEqual).apply(null,arguments)},d._LinSpace=function(){return(d._LinSpace=d.asm.LinSpace).apply(null,arguments)},d._Log=function(){return(d._Log=d.asm.Log).apply(null,arguments)},d._Log1p=function(){return(d._Log1p=d.asm.Log1p).apply(null,arguments)},d._LogicalAnd=function(){return(d._LogicalAnd=d.asm.LogicalAnd).apply(null,arguments)},d._LogicalNot=function(){return(d._LogicalNot=d.asm.LogicalNot).apply(null,arguments)},d._LogicalOr=function(){return(d._LogicalOr=d.asm.LogicalOr).apply(null,arguments)},d._LogicalXor=function(){return(d._LogicalXor=d.asm.LogicalXor).apply(null,arguments)},d._Max=function(){return(d._Max=d.asm.Max).apply(null,arguments)},d._MaxPool=function(){return(d._MaxPool=d.asm.MaxPool).apply(null,arguments)},d._MaxPool3D=function(){return(d._MaxPool3D=d.asm.MaxPool3D).apply(null,arguments)},d._MaxPool3DGrad=function(){return(d._MaxPool3DGrad=d.asm.MaxPool3DGrad).apply(null,arguments)},d._Maximum=function(){return(d._Maximum=d.asm.Maximum).apply(null,arguments)},d._Mean=function(){return(d._Mean=d.asm.Mean).apply(null,arguments)},d._Min=function(){return(d._Min=d.asm.Min).apply(null,arguments)},d._Minimum=function(){return(d._Minimum=d.asm.Minimum).apply(null,arguments)},d._MirrorPad=function(){return(d._MirrorPad=d.asm.MirrorPad).apply(null,arguments)},d._Multinomial=function(){return(d._Multinomial=d.asm.Multinomial).apply(null,arguments)},d._Multiply=function(){return(d._Multiply=d.asm.Multiply).apply(null,arguments)},d._Neg=function(){return(d._Neg=d.asm.Neg).apply(null,arguments)},d._NonMaxSuppressionV3=function(){return(d._NonMaxSuppressionV3=d.asm.NonMaxSuppressionV3).apply(null,arguments)},d._NonMaxSuppressionV4=function(){return(d._NonMaxSuppressionV4=d.asm.NonMaxSuppressionV4).apply(null,arguments)},d._NonMaxSuppressionV5=function(){return(d._NonMaxSuppressionV5=d.asm.NonMaxSuppressionV5).apply(null,arguments)},d._NotEqual=function(){return(d._NotEqual=d.asm.NotEqual).apply(null,arguments)},d._OneHot=function(){return(d._OneHot=d.asm.OneHot).apply(null,arguments)},d._PadV2=function(){return(d._PadV2=d.asm.PadV2).apply(null,arguments)},d._Pow=function(){return(d._Pow=d.asm.Pow).apply(null,arguments)},d._Prelu=function(){return(d._Prelu=d.asm.Prelu).apply(null,arguments)},d._Prod=function(){return(d._Prod=d.asm.Prod).apply(null,arguments)},d._RealDiv=function(){return(d._RealDiv=d.asm.RealDiv).apply(null,arguments)},d._Reciprocal=function(){return(d._Reciprocal=d.asm.Reciprocal).apply(null,arguments)},d._Relu=function(){return(d._Relu=d.asm.Relu).apply(null,arguments)},d._Relu6=function(){return(d._Relu6=d.asm.Relu6).apply(null,arguments)},d._ResizeBilinear=function(){return(d._ResizeBilinear=d.asm.ResizeBilinear).apply(null,arguments)},d._ResizeBilinearGrad=function(){return(d._ResizeBilinearGrad=d.asm.ResizeBilinearGrad).apply(null,arguments)},d._ResizeNearestNeighbor=function(){return(d._ResizeNearestNeighbor=d.asm.ResizeNearestNeighbor).apply(null,arguments)},d._ResizeNearestNeighborGrad=function(){return(d._ResizeNearestNeighborGrad=d.asm.ResizeNearestNeighborGrad).apply(null,arguments)},d._Reverse=function(){return(d._Reverse=d.asm.Reverse).apply(null,arguments)},d._RotateWithOffset=function(){return(d._RotateWithOffset=d.asm.RotateWithOffset).apply(null,arguments)},d._Round=function(){return(d._Round=d.asm.Round).apply(null,arguments)},d._Rsqrt=function(){return(d._Rsqrt=d.asm.Rsqrt).apply(null,arguments)},d._ScatterNd=function(){return(d._ScatterNd=d.asm.ScatterNd).apply(null,arguments)},d._SearchSorted=function(){return(d._SearchSorted=d.asm.SearchSorted).apply(null,arguments)},d._SelectV2=function(){return(d._SelectV2=d.asm.SelectV2).apply(null,arguments)},d._Selu=function(){return(d._Selu=d.asm.Selu).apply(null,arguments)},d._Sigmoid=function(){return(d._Sigmoid=d.asm.Sigmoid).apply(null,arguments)},d._Sign=function(){return(d._Sign=d.asm.Sign).apply(null,arguments)},d._Sin=function(){return(d._Sin=d.asm.Sin).apply(null,arguments)},d._Softmax=function(){return(d._Softmax=d.asm.Softmax).apply(null,arguments)},d._Softplus=function(){return(d._Softplus=d.asm.Softplus).apply(null,arguments)},d._SparseFillEmptyRows=function(){return(d._SparseFillEmptyRows=d.asm.SparseFillEmptyRows).apply(null,arguments)},d._SparseReshape=function(){return(d._SparseReshape=d.asm.SparseReshape).apply(null,arguments)},d._SparseSegmentReduction=function(){return(d._SparseSegmentReduction=d.asm.SparseSegmentReduction).apply(null,arguments)},d._SparseToDense=function(){return(d._SparseToDense=d.asm.SparseToDense).apply(null,arguments)},d._Sqrt=function(){return(d._Sqrt=d.asm.Sqrt).apply(null,arguments)},d._Square=function(){return(d._Square=d.asm.Square).apply(null,arguments)},d._SquaredDifference=function(){return(d._SquaredDifference=d.asm.SquaredDifference).apply(null,arguments)},d._Step=function(){return(d._Step=d.asm.Step).apply(null,arguments)},d._StridedSlice=function(){return(d._StridedSlice=d.asm.StridedSlice).apply(null,arguments)},d._Sub=function(){return(d._Sub=d.asm.Sub).apply(null,arguments)},d._Sum=function(){return(d._Sum=d.asm.Sum).apply(null,arguments)},d._Tan=function(){return(d._Tan=d.asm.Tan).apply(null,arguments)},d._Tanh=function(){return(d._Tanh=d.asm.Tanh).apply(null,arguments)},d._TensorScatterUpdate=function(){return(d._TensorScatterUpdate=d.asm.TensorScatterUpdate).apply(null,arguments)},d._Tile=function(){return(d._Tile=d.asm.Tile).apply(null,arguments)},d._TopK=function(){return(d._TopK=d.asm.TopK).apply(null,arguments)},d._Transform=function(){return(d._Transform=d.asm.Transform).apply(null,arguments)},d._Transpose=function(){return(d._Transpose=d.asm.Transpose).apply(null,arguments)},d.__FusedMatMul=function(){return(d.__FusedMatMul=d.asm._FusedMatMul).apply(null,arguments)},d._malloc=function(){return(d._malloc=d.asm.malloc).apply(null,arguments)},d._free=function(){return(d._free=d.asm.free).apply(null,arguments)},d.__emscripten_tls_init=function(){return(d.__emscripten_tls_init=d.asm._emscripten_tls_init).apply(null,arguments)},d._pthread_self=function(){return($t=d._pthread_self=d.asm.pthread_self).apply(null,arguments)}),Rt=(d.___errno_location=function(){return(d.___errno_location=d.asm.__errno_location).apply(null,arguments)},d.__emscripten_thread_init=function(){return(Rt=d.__emscripten_thread_init=d.asm._emscripten_thread_init).apply(null,arguments)}),Ft=(d.__emscripten_thread_crashed=function(){return(d.__emscripten_thread_crashed=d.asm._emscripten_thread_crashed).apply(null,arguments)},d._emscripten_main_thread_process_queued_calls=function(){return(d._emscripten_main_thread_process_queued_calls=d.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},d._emscripten_main_browser_thread_id=function(){return(d._emscripten_main_browser_thread_id=d.asm.emscripten_main_browser_thread_id).apply(null,arguments)},d._emscripten_run_in_main_runtime_thread_js=function(){return(Ft=d._emscripten_run_in_main_runtime_thread_js=d.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)}),Dt=(d._emscripten_dispatch_to_thread_=function(){return(d._emscripten_dispatch_to_thread_=d.asm.emscripten_dispatch_to_thread_).apply(null,arguments)},d.__emscripten_proxy_execute_task_queue=function(){return(Dt=d.__emscripten_proxy_execute_task_queue=d.asm._emscripten_proxy_execute_task_queue).apply(null,arguments)}),Mt=d.__emscripten_thread_free_data=function(){return(Mt=d.__emscripten_thread_free_data=d.asm._emscripten_thread_free_data).apply(null,arguments)},Ot=d.__emscripten_thread_exit=function(){return(Ot=d.__emscripten_thread_exit=d.asm._emscripten_thread_exit).apply(null,arguments)},Pt=d._emscripten_stack_set_limits=function(){return(Pt=d._emscripten_stack_set_limits=d.asm.emscripten_stack_set_limits).apply(null,arguments)},Lt=d.stackSave=function(){return(Lt=d.stackSave=d.asm.stackSave).apply(null,arguments)},zt=d.stackRestore=function(){return(zt=d.stackRestore=d.asm.stackRestore).apply(null,arguments)},Bt=d.stackAlloc=function(){return(Bt=d.stackAlloc=d.asm.stackAlloc).apply(null,arguments)};d.dynCall_iijjiiii=function(){return(d.dynCall_iijjiiii=d.asm.dynCall_iijjiiii).apply(null,arguments)},d.dynCall_jiji=function(){return(d.dynCall_jiji=d.asm.dynCall_jiji).apply(null,arguments)};function Wt(e){if(e=e||y,!(fe>0)){if(k)return u(d),ue(),void startWorker(d);le(),fe>0||(d.setStatus?(d.setStatus("Running..."),setTimeout((function(){setTimeout((function(){d.setStatus("")}),1),t()}),1)):t())}function t(){Tt||(Tt=!0,d.calledRun=!0,!U&&(ue(),u(d),d.onRuntimeInitialized&&d.onRuntimeInitialized(),pe()))}}if(d.keepRuntimeAlive=oe,d.wasmMemory=z,d.cwrap=Nt,d.ExitStatus=Ce,d.PThread=Pe,ge=function e(){Tt||Wt(),Tt||(ge=e)},d.preInit)for("function"==typeof d.preInit&&(d.preInit=[d.preInit]);d.preInit.length>0;)d.preInit.pop()();if(Wt(),c&&(_t={uncaughtException:process.listeners("uncaughtException").filter((function(e){return!c.uncaughtException.indexOf(e)>-1})),unhandledRejection:process.listeners("unhandledRejection").filter((function(e){return!c.unhandledRejection.indexOf(e)>-1}))}),"undefined"!=typeof WasmBackendModule)Ct=WasmBackendModule;else{if("undefined"==typeof t)throw new Error("Could not find wasm module in post.js");Ct=t}if(_t){var Ut=Ct._dispose;Ct._dispose=function(){Ut(),_t.uncaughtException.forEach((function(e){process.removeListener("uncaughtException",e)})),_t.unhandledRejection.forEach((function(e){process.removeListener("unhandledRejection",e)}))}}return t.ready}})();"object"==typeof e&&"object"==typeof t?t.exports=s:"function"==typeof define&&n.amdO?define([],(function(){return s})):"object"==typeof e&&(e.WasmBackendModuleThreadedSimd=s)})),L=m(((e,t)=>{t.exports.wasmWorkerContents='"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8")+"//# sourceURL="+f)},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"\n");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.startWorker=instance=>{Module=instance;postMessage({"cmd":"loaded"})};self.onmessage=e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=function(){postMessage({cmd:"callHandler",handler:handler,args:[...arguments]})}}Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module)}else if(e.data.cmd==="run"){Module["__emscripten_thread_init"](e.data.pthread_ptr,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module["executeNotifiedProxyingQueue"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processProxyingQueue"){if(initializedJS){Module["executeNotifiedProxyingQueue"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}};'})),z=m(((e,t)=>{var s=(()=>{var e="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0;return e=e||r,function(t){t=t||{};var n,r,s,i="undefined"!=typeof t?t:{};i.ready=new Promise((function(e,t){n=e,r=t})),"undefined"!=typeof process&&process.listeners&&(s={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var o,l,u,p=Object.assign({},i),c=[],d="object"==typeof window,h="function"==typeof importScripts,f="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,m="";function g(e){return i.locateFile?i.locateFile(e,m):m+e}function y(e){e instanceof oe||w("exiting due to exception: "+e)}if(f){var b=R(),x=F();m=h?x.dirname(m)+"/":a+"/",o=(e,t)=>(e=re(e)?new URL(e):x.normalize(e),b.readFileSync(e,t?void 0:"utf8")),u=e=>{var t=o(e,!0);return t.buffer||(t=new Uint8Array(t)),t},l=(e,t,n)=>{e=re(e)?new URL(e):x.normalize(e),b.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),c=process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof oe))throw e})),process.on("unhandledRejection",(function(e){throw e})),(e,t)=>{if(W())throw process.exitCode=e,t;y(t),process.exit(e)},i.inspect=function(){return"[Emscripten Module object]"}}else(d||h)&&(h?m=self.location.href:"undefined"!=typeof document&&document.currentScript&&(m=document.currentScript.src),e&&(m=e),m=0!==m.indexOf("blob:")?m.substr(0,m.replace(/[?#].*/,"").lastIndexOf("/")+1):"",o=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},h&&(u=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),l=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)},e=>document.title=e);var v=i.print||console.log.bind(console),w=i.printErr||console.warn.bind(console);Object.assign(i,p),p=null,i.arguments&&(c=i.arguments),i.thisProgram&&i.thisProgram,i.quit&&i.quit;var k;i.wasmBinary&&(k=i.wasmBinary);var I=i.noExitRuntime||!0;"object"!=typeof WebAssembly&&Q("no native wasm support detected");var S,N=!1;var T,_,C,E,A="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function $(e,t,n){for(var r=t+n,a=t;e[a]&&!(a>=r);)++a;if(a-t>16&&e.buffer&&A)return A.decode(e.subarray(t,a));for(var s="";t<a;){var i=e[t++];if(128&i){var o=63&e[t++];if(192!=(224&i)){var l=63&e[t++];if(i=224==(240&i)?(15&i)<<12|o<<6|l:(7&i)<<18|o<<12|l<<6|63&e[t++],i<65536)s+=String.fromCharCode(i);else{var u=i-65536;s+=String.fromCharCode(55296|u>>10,56320|1023&u)}}else s+=String.fromCharCode((31&i)<<6|o)}else s+=String.fromCharCode(i)}return s}function D(e,t){return e?$(C,e,t):""}function M(e,t,n,r){if(!(r>0))return 0;for(var a=n,s=n+r-1,i=0;i<e.length;++i){var o=e.charCodeAt(i);if(o>=55296&&o<=57343){var l=e.charCodeAt(++i);o=65536+((1023&o)<<10)|1023&l}if(o<=127){if(n>=s)break;t[n++]=o}else if(o<=2047){if(n+1>=s)break;t[n++]=192|o>>6,t[n++]=128|63&o}else if(o<=65535){if(n+2>=s)break;t[n++]=224|o>>12,t[n++]=128|o>>6&63,t[n++]=128|63&o}else{if(n+3>=s)break;t[n++]=240|o>>18,t[n++]=128|o>>12&63,t[n++]=128|o>>6&63,t[n++]=128|63&o}}return t[n]=0,n-a}function O(e,t,n){return M(e,C,t,n)}function P(e){T=e,i.HEAP8=_=new Int8Array(e),i.HEAP16=new Int16Array(e),i.HEAP32=new Int32Array(e),i.HEAPU8=C=new Uint8Array(e),i.HEAPU16=new Uint16Array(e),i.HEAPU32=E=new Uint32Array(e),i.HEAPF32=new Float32Array(e),i.HEAPF64=new Float64Array(e)}i.INITIAL_MEMORY;var L=[],z=[],B=[];function W(){return I}function U(){if(i.preRun)for("function"==typeof i.preRun&&(i.preRun=[i.preRun]);i.preRun.length;)H(i.preRun.shift());le(L)}function V(){!0,le(z)}function G(){if(i.postRun)for("function"==typeof i.postRun&&(i.postRun=[i.postRun]);i.postRun.length;)q(i.postRun.shift());le(B)}function H(e){L.unshift(e)}function j(e){z.unshift(e)}function q(e){B.unshift(e)}var K=0,X=null,J=null;function Y(e){K++,i.monitorRunDependencies&&i.monitorRunDependencies(K)}function Z(e){if(K--,i.monitorRunDependencies&&i.monitorRunDependencies(K),0==K&&(null!==X&&(clearInterval(X),X=null),J)){var t=J;J=null,t()}}function Q(e){i.onAbort&&i.onAbort(e),e="Aborted("+e+")",w(e),N=!0,1,e+=". Build with -sASSERTIONS for more info.";var t=new WebAssembly.RuntimeError(e);throw r(t),t}var ee,te="data:application/octet-stream;base64,";function ne(e){return e.startsWith(te)}function re(e){return e.startsWith("file://")}function ae(e){try{if(e==ee&&k)return new Uint8Array(k);if(u)return u(e);throw"both async and sync fetching of the wasm failed"}catch(t){Q(t)}}function se(){if(!k&&(d||h)){if("function"==typeof fetch&&!re(ee))return fetch(ee,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at '"+ee+"'";return e.arrayBuffer()})).catch((function(){return ae(ee)}));if(l)return new Promise((function(e,t){l(ee,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return ae(ee)}))}function ie(){var e={env:_e,wasi_snapshot_preview1:_e};function t(e,t){var n=e.exports;i.asm=n,S=i.asm.memory,P(S.buffer),i.asm.__indirect_function_table,j(i.asm.__wasm_call_ctors),Z("wasm-instantiate")}function n(e){t(e.instance)}function a(t){return se().then((function(t){return WebAssembly.instantiate(t,e)})).then((function(e){return e})).then(t,(function(e){w("failed to asynchronously prepare wasm: "+e),Q(e)}))}function s(){return k||"function"!=typeof WebAssembly.instantiateStreaming||ne(ee)||re(ee)||f||"function"!=typeof fetch?a(n):fetch(ee,{credentials:"same-origin"}).then((function(t){var r=WebAssembly.instantiateStreaming(t,e);return r.then(n,(function(e){return w("wasm streaming compile failed: "+e),w("falling back to ArrayBuffer instantiation"),a(n)}))}))}if(Y("wasm-instantiate"),i.instantiateWasm)try{var o=i.instantiateWasm(e,t);return o}catch(l){w("Module.instantiateWasm callback failed with error: "+l),r(l)}return s().catch(r),{}}function oe(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function le(e){for(;e.length>0;)e.shift()(i)}function ue(){Q("")}function pe(){return 2147483648}function ce(){return pe()}function de(e,t,n){C.copyWithin(e,t,t+n)}function he(e){try{return S.grow(e-T.byteLength+65535>>>16),P(S.buffer),1}catch(t){}}function fe(e){var t=C.length;e>>>=0;var n=pe();if(e>n)return!1;let r=(e,t)=>e+(t-e%t)%t;for(var a=1;a<=4;a*=2){var s=t*(1+.2/a);s=Math.min(s,e+100663296);var i=Math.min(n,r(Math.max(e,s),65536)),o=he(i);if(o)return!0}return!1}ee="tfjs-backend-wasm.wasm",ne(ee)||(ee=g(ee));function me(e){return 52}function ge(e,t,n,r,a){return 70}var ye=[null,[],[]];function be(e,t){var n=ye[e];0===t||10===t?((1===e?v:w)($(n,0)),n.length=0):n.push(t)}function xe(e,t,n,r){for(var a=0,s=0;s<n;s++){var i=E[t>>2],o=E[t+4>>2];t+=8;for(var l=0;l<o;l++)be(e,C[i+l]);a+=o}return E[r>>2]=a,0}function ve(e){var t=i["_"+e];return t}function we(e,t){_.set(e,t)}function ke(e,t,n,r,a){var s={string:e=>{var t=0;if(null!=e&&0!==e){var n=1+(e.length<<2);t=Ae(n),O(e,t,n)}return t},array:e=>{var t=Ae(e.length);return we(e,t),t}};function i(e){return"string"===t?D(e):"boolean"===t?!!e:e}var o=ve(e),l=[],u=0;if(r)for(var p=0;p<r.length;p++){var c=s[n[p]];c?(0===u&&(u=Ce()),l[p]=c(r[p])):l[p]=r[p]}var d=o.apply(null,l);function h(e){return 0!==u&&Ee(u),i(e)}return d=h(d),d}function Ie(e,t,n,r){n=n||[];var a=n.every((e=>"number"===e||"boolean"===e)),s="string"!==t;return s&&a&&!r?ve(e):function(){return ke(e,t,n,arguments,r)}}var Se,Ne,Te,_e={abort:ue,emscripten_get_heap_max:ce,emscripten_memcpy_big:de,emscripten_resize_heap:fe,fd_close:me,fd_seek:ge,fd_write:xe},Ce=(ie(),i.___wasm_call_ctors=function(){return(i.___wasm_call_ctors=i.asm.__wasm_call_ctors).apply(null,arguments)},i._init=function(){return(i._init=i.asm.init).apply(null,arguments)},i._init_with_threads_count=function(){return(i._init_with_threads_count=i.asm.init_with_threads_count).apply(null,arguments)},i._get_threads_count=function(){return(i._get_threads_count=i.asm.get_threads_count).apply(null,arguments)},i._register_tensor=function(){return(i._register_tensor=i.asm.register_tensor).apply(null,arguments)},i._dispose_data=function(){return(i._dispose_data=i.asm.dispose_data).apply(null,arguments)},i._dispose=function(){return(i._dispose=i.asm.dispose).apply(null,arguments)},i._Abs=function(){return(i._Abs=i.asm.Abs).apply(null,arguments)},i._Acos=function(){return(i._Acos=i.asm.Acos).apply(null,arguments)},i._Acosh=function(){return(i._Acosh=i.asm.Acosh).apply(null,arguments)},i._Add=function(){return(i._Add=i.asm.Add).apply(null,arguments)},i._AddN=function(){return(i._AddN=i.asm.AddN).apply(null,arguments)},i._All=function(){return(i._All=i.asm.All).apply(null,arguments)},i._Any=function(){return(i._Any=i.asm.Any).apply(null,arguments)},i._ArgMax=function(){return(i._ArgMax=i.asm.ArgMax).apply(null,arguments)},i._ArgMin=function(){return(i._ArgMin=i.asm.ArgMin).apply(null,arguments)},i._Asin=function(){return(i._Asin=i.asm.Asin).apply(null,arguments)},i._Asinh=function(){return(i._Asinh=i.asm.Asinh).apply(null,arguments)},i._Atan=function(){return(i._Atan=i.asm.Atan).apply(null,arguments)},i._Atan2=function(){return(i._Atan2=i.asm.Atan2).apply(null,arguments)},i._Atanh=function(){return(i._Atanh=i.asm.Atanh).apply(null,arguments)},i._AvgPool=function(){return(i._AvgPool=i.asm.AvgPool).apply(null,arguments)},i._AvgPool3D=function(){return(i._AvgPool3D=i.asm.AvgPool3D).apply(null,arguments)},i._AvgPool3DGrad=function(){return(i._AvgPool3DGrad=i.asm.AvgPool3DGrad).apply(null,arguments)},i._BatchMatMul=function(){return(i._BatchMatMul=i.asm.BatchMatMul).apply(null,arguments)},i._Bincount=function(){return(i._Bincount=i.asm.Bincount).apply(null,arguments)},i._Ceil=function(){return(i._Ceil=i.asm.Ceil).apply(null,arguments)},i._ClipByValue=function(){return(i._ClipByValue=i.asm.ClipByValue).apply(null,arguments)},i._Conv2D=function(){return(i._Conv2D=i.asm.Conv2D).apply(null,arguments)},i._Conv2DBackpropInput=function(){return(i._Conv2DBackpropInput=i.asm.Conv2DBackpropInput).apply(null,arguments)},i._Conv3D=function(){return(i._Conv3D=i.asm.Conv3D).apply(null,arguments)},i._Conv3DBackpropFilterV2=function(){return(i._Conv3DBackpropFilterV2=i.asm.Conv3DBackpropFilterV2).apply(null,arguments)},i._Conv3DBackpropInputV2=function(){return(i._Conv3DBackpropInputV2=i.asm.Conv3DBackpropInputV2).apply(null,arguments)},i._Cos=function(){return(i._Cos=i.asm.Cos).apply(null,arguments)},i._Cosh=function(){return(i._Cosh=i.asm.Cosh).apply(null,arguments)},i._CropAndResize=function(){return(i._CropAndResize=i.asm.CropAndResize).apply(null,arguments)},i._Cumprod=function(){return(i._Cumprod=i.asm.Cumprod).apply(null,arguments)},i._Cumsum=function(){return(i._Cumsum=i.asm.Cumsum).apply(null,arguments)},i._DenseBincount=function(){return(i._DenseBincount=i.asm.DenseBincount).apply(null,arguments)},i._DepthToSpace=function(){return(i._DepthToSpace=i.asm.DepthToSpace).apply(null,arguments)},i._DepthwiseConv2dNative=function(){return(i._DepthwiseConv2dNative=i.asm.DepthwiseConv2dNative).apply(null,arguments)},i._Diag=function(){return(i._Diag=i.asm.Diag).apply(null,arguments)},i._Dilation2D=function(){return(i._Dilation2D=i.asm.Dilation2D).apply(null,arguments)},i._Dilation2DBackpropFilter=function(){return(i._Dilation2DBackpropFilter=i.asm.Dilation2DBackpropFilter).apply(null,arguments)},i._Dilation2DBackpropInput=function(){return(i._Dilation2DBackpropInput=i.asm.Dilation2DBackpropInput).apply(null,arguments)},i._Elu=function(){return(i._Elu=i.asm.Elu).apply(null,arguments)},i._EluGrad=function(){return(i._EluGrad=i.asm.EluGrad).apply(null,arguments)},i._Equal=function(){return(i._Equal=i.asm.Equal).apply(null,arguments)},i._Exp=function(){return(i._Exp=i.asm.Exp).apply(null,arguments)},i._Expm1=function(){return(i._Expm1=i.asm.Expm1).apply(null,arguments)},i._FlipLeftRight=function(){return(i._FlipLeftRight=i.asm.FlipLeftRight).apply(null,arguments)},i._Floor=function(){return(i._Floor=i.asm.Floor).apply(null,arguments)},i._FloorDiv=function(){return(i._FloorDiv=i.asm.FloorDiv).apply(null,arguments)},i._FusedBatchNorm=function(){return(i._FusedBatchNorm=i.asm.FusedBatchNorm).apply(null,arguments)},i._FusedConv2D=function(){return(i._FusedConv2D=i.asm.FusedConv2D).apply(null,arguments)},i._FusedDepthwiseConv2D=function(){return(i._FusedDepthwiseConv2D=i.asm.FusedDepthwiseConv2D).apply(null,arguments)},i._Gather=function(){return(i._Gather=i.asm.Gather).apply(null,arguments)},i._GatherNd=function(){return(i._GatherNd=i.asm.GatherNd).apply(null,arguments)},i._Greater=function(){return(i._Greater=i.asm.Greater).apply(null,arguments)},i._GreaterEqual=function(){return(i._GreaterEqual=i.asm.GreaterEqual).apply(null,arguments)},i._IsFinite=function(){return(i._IsFinite=i.asm.IsFinite).apply(null,arguments)},i._IsInf=function(){return(i._IsInf=i.asm.IsInf).apply(null,arguments)},i._IsNan=function(){return(i._IsNan=i.asm.IsNan).apply(null,arguments)},i._LRN=function(){return(i._LRN=i.asm.LRN).apply(null,arguments)},i._LRNGrad=function(){return(i._LRNGrad=i.asm.LRNGrad).apply(null,arguments)},i._LeakyRelu=function(){return(i._LeakyRelu=i.asm.LeakyRelu).apply(null,arguments)},i._Less=function(){return(i._Less=i.asm.Less).apply(null,arguments)},i._LessEqual=function(){return(i._LessEqual=i.asm.LessEqual).apply(null,arguments)},i._LinSpace=function(){return(i._LinSpace=i.asm.LinSpace).apply(null,arguments)},i._Log=function(){return(i._Log=i.asm.Log).apply(null,arguments)},i._Log1p=function(){return(i._Log1p=i.asm.Log1p).apply(null,arguments)},i._LogicalAnd=function(){return(i._LogicalAnd=i.asm.LogicalAnd).apply(null,arguments)},i._LogicalNot=function(){return(i._LogicalNot=i.asm.LogicalNot).apply(null,arguments)},i._LogicalOr=function(){return(i._LogicalOr=i.asm.LogicalOr).apply(null,arguments)},i._LogicalXor=function(){return(i._LogicalXor=i.asm.LogicalXor).apply(null,arguments)},i._Max=function(){return(i._Max=i.asm.Max).apply(null,arguments)},i._MaxPool=function(){return(i._MaxPool=i.asm.MaxPool).apply(null,arguments)},i._MaxPool3D=function(){return(i._MaxPool3D=i.asm.MaxPool3D).apply(null,arguments)},i._MaxPool3DGrad=function(){return(i._MaxPool3DGrad=i.asm.MaxPool3DGrad).apply(null,arguments)},i._Maximum=function(){return(i._Maximum=i.asm.Maximum).apply(null,arguments)},i._Mean=function(){return(i._Mean=i.asm.Mean).apply(null,arguments)},i._Min=function(){return(i._Min=i.asm.Min).apply(null,arguments)},i._Minimum=function(){return(i._Minimum=i.asm.Minimum).apply(null,arguments)},i._MirrorPad=function(){return(i._MirrorPad=i.asm.MirrorPad).apply(null,arguments)},i._Multinomial=function(){return(i._Multinomial=i.asm.Multinomial).apply(null,arguments)},i._Multiply=function(){return(i._Multiply=i.asm.Multiply).apply(null,arguments)},i._Neg=function(){return(i._Neg=i.asm.Neg).apply(null,arguments)},i._NonMaxSuppressionV3=function(){return(i._NonMaxSuppressionV3=i.asm.NonMaxSuppressionV3).apply(null,arguments)},i._NonMaxSuppressionV4=function(){return(i._NonMaxSuppressionV4=i.asm.NonMaxSuppressionV4).apply(null,arguments)},i._NonMaxSuppressionV5=function(){return(i._NonMaxSuppressionV5=i.asm.NonMaxSuppressionV5).apply(null,arguments)},i._NotEqual=function(){return(i._NotEqual=i.asm.NotEqual).apply(null,arguments)},i._OneHot=function(){return(i._OneHot=i.asm.OneHot).apply(null,arguments)},i._PadV2=function(){return(i._PadV2=i.asm.PadV2).apply(null,arguments)},i._Pow=function(){return(i._Pow=i.asm.Pow).apply(null,arguments)},i._Prelu=function(){return(i._Prelu=i.asm.Prelu).apply(null,arguments)},i._Prod=function(){return(i._Prod=i.asm.Prod).apply(null,arguments)},i._RealDiv=function(){return(i._RealDiv=i.asm.RealDiv).apply(null,arguments)},i._Reciprocal=function(){return(i._Reciprocal=i.asm.Reciprocal).apply(null,arguments)},i._Relu=function(){return(i._Relu=i.asm.Relu).apply(null,arguments)},i._Relu6=function(){return(i._Relu6=i.asm.Relu6).apply(null,arguments)},i._ResizeBilinear=function(){return(i._ResizeBilinear=i.asm.ResizeBilinear).apply(null,arguments)},i._ResizeBilinearGrad=function(){return(i._ResizeBilinearGrad=i.asm.ResizeBilinearGrad).apply(null,arguments)},i._ResizeNearestNeighbor=function(){return(i._ResizeNearestNeighbor=i.asm.ResizeNearestNeighbor).apply(null,arguments)},i._ResizeNearestNeighborGrad=function(){return(i._ResizeNearestNeighborGrad=i.asm.ResizeNearestNeighborGrad).apply(null,arguments)},i._Reverse=function(){return(i._Reverse=i.asm.Reverse).apply(null,arguments)},i._RotateWithOffset=function(){return(i._RotateWithOffset=i.asm.RotateWithOffset).apply(null,arguments)},i._Round=function(){return(i._Round=i.asm.Round).apply(null,arguments)},i._Rsqrt=function(){return(i._Rsqrt=i.asm.Rsqrt).apply(null,arguments)},i._ScatterNd=function(){return(i._ScatterNd=i.asm.ScatterNd).apply(null,arguments)},i._SearchSorted=function(){return(i._SearchSorted=i.asm.SearchSorted).apply(null,arguments)},i._SelectV2=function(){return(i._SelectV2=i.asm.SelectV2).apply(null,arguments)},i._Selu=function(){return(i._Selu=i.asm.Selu).apply(null,arguments)},i._Sigmoid=function(){return(i._Sigmoid=i.asm.Sigmoid).apply(null,arguments)},i._Sign=function(){return(i._Sign=i.asm.Sign).apply(null,arguments)},i._Sin=function(){return(i._Sin=i.asm.Sin).apply(null,arguments)},i._Softmax=function(){return(i._Softmax=i.asm.Softmax).apply(null,arguments)},i._Softplus=function(){return(i._Softplus=i.asm.Softplus).apply(null,arguments)},i._SparseFillEmptyRows=function(){return(i._SparseFillEmptyRows=i.asm.SparseFillEmptyRows).apply(null,arguments)},i._SparseReshape=function(){return(i._SparseReshape=i.asm.SparseReshape).apply(null,arguments)},i._SparseSegmentReduction=function(){return(i._SparseSegmentReduction=i.asm.SparseSegmentReduction).apply(null,arguments)},i._SparseToDense=function(){return(i._SparseToDense=i.asm.SparseToDense).apply(null,arguments)},i._Sqrt=function(){return(i._Sqrt=i.asm.Sqrt).apply(null,arguments)},i._Square=function(){return(i._Square=i.asm.Square).apply(null,arguments)},i._SquaredDifference=function(){return(i._SquaredDifference=i.asm.SquaredDifference).apply(null,arguments)},i._Step=function(){return(i._Step=i.asm.Step).apply(null,arguments)},i._StridedSlice=function(){return(i._StridedSlice=i.asm.StridedSlice).apply(null,arguments)},i._Sub=function(){return(i._Sub=i.asm.Sub).apply(null,arguments)},i._Sum=function(){return(i._Sum=i.asm.Sum).apply(null,arguments)},i._Tan=function(){return(i._Tan=i.asm.Tan).apply(null,arguments)},i._Tanh=function(){return(i._Tanh=i.asm.Tanh).apply(null,arguments)},i._TensorScatterUpdate=function(){return(i._TensorScatterUpdate=i.asm.TensorScatterUpdate).apply(null,arguments)},i._Tile=function(){return(i._Tile=i.asm.Tile).apply(null,arguments)},i._TopK=function(){return(i._TopK=i.asm.TopK).apply(null,arguments)},i._Transform=function(){return(i._Transform=i.asm.Transform).apply(null,arguments)},i._Transpose=function(){return(i._Transpose=i.asm.Transpose).apply(null,arguments)},i.__FusedMatMul=function(){return(i.__FusedMatMul=i.asm._FusedMatMul).apply(null,arguments)},i._malloc=function(){return(i._malloc=i.asm.malloc).apply(null,arguments)},i._free=function(){return(i._free=i.asm.free).apply(null,arguments)},i.___errno_location=function(){return(i.___errno_location=i.asm.__errno_location).apply(null,arguments)},i.stackSave=function(){return(Ce=i.stackSave=i.asm.stackSave).apply(null,arguments)}),Ee=i.stackRestore=function(){return(Ee=i.stackRestore=i.asm.stackRestore).apply(null,arguments)},Ae=i.stackAlloc=function(){return(Ae=i.stackAlloc=i.asm.stackAlloc).apply(null,arguments)};i.dynCall_iijjiiii=function(){return(i.dynCall_iijjiiii=i.asm.dynCall_iijjiiii).apply(null,arguments)},i.dynCall_jiji=function(){return(i.dynCall_jiji=i.asm.dynCall_jiji).apply(null,arguments)};function $e(e){function t(){Se||(Se=!0,i.calledRun=!0,!N&&(V(),n(i),i.onRuntimeInitialized&&i.onRuntimeInitialized(),G()))}e=e||c,K>0||(U(),K>0)||(i.setStatus?(i.setStatus("Running..."),setTimeout((function(){setTimeout((function(){i.setStatus("")}),1),t()}),1)):t())}if(i.cwrap=Ie,J=function e(){Se||$e(),Se||(J=e)},i.preInit)for("function"==typeof i.preInit&&(i.preInit=[i.preInit]);i.preInit.length>0;)i.preInit.pop()();if($e(),s&&(Ne={uncaughtException:process.listeners("uncaughtException").filter((function(e){return!s.uncaughtException.indexOf(e)>-1})),unhandledRejection:process.listeners("unhandledRejection").filter((function(e){return!s.unhandledRejection.indexOf(e)>-1}))}),"undefined"!=typeof t)Te=t;else{if("undefined"==typeof WasmBackendModuleThreadedSimd)throw new Error("Could not find wasm module in post.js");Te=WasmBackendModuleThreadedSimd}if(Ne){var Re=Te._dispose;Te._dispose=function(){Re(),Ne.uncaughtException.forEach((function(e){process.removeListener("uncaughtException",e)})),Ne.unhandledRejection.forEach((function(e){process.removeListener("unhandledRejection",e)}))}}return t.ready}})();"object"==typeof e&&"object"==typeof t?t.exports=s:"function"==typeof define&&n.amdO?define([],(function(){return s})):"object"==typeof e&&(e.WasmBackendModule=s)})),B=class{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},W=class{refCount(e){return U("refCount")}incRef(e){return U("incRef")}timerAvailable(){return!0}time(e){return U("time")}read(e){return U("read")}readSync(e){return U("readSync")}readToGPU(e,t){return U("readToGPU")}numDataIds(){return U("numDataIds")}disposeData(e,t){return U("disposeData")}write(e,t,n){return U("write")}move(e,t,n,r,a){return U("move")}createTensorFromGPUData(e,t,n){return U("createTensorFromGPUData")}memory(){return U("memory")}floatPrecision(){return U("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return U("dispose")}};function U(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function V(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,q(e,t,n)}function G(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,q(e,n,r),q(t,n,r)}function H(e,t,n){return Math.max(e,Math.min(t,n))}function j(e){return e%2===0?e:e+1}function q(e,t,n){let r=e[t];e[t]=e[n],e[n]=r}function K(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function X(e,t){let n=Math.random();return t*n+(1-n)*e}function J(e,t){let n=0;for(let r=0;r<e.length;r++){let a=Number(e[r])-Number(t[r]);n+=a*a}return n}function Y(e,t){if(!e)throw new Error("string"==typeof t?t:t())}function Z(e,t,n=""){Y(ne(e,t),(()=>n+` Shapes ${e} and ${t} must match`))}function Q(e){Y(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function ee(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function te(e){return 0===e.length}function ne(e,t){if(e===t)return!0;if(null==e||null==t||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function re(e){return e%1===0}function ae(e){if(null!=Math.tanh)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{let t=Math.exp(2*e);return(t-1)/(t+1)}}function se(e){let t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function ie(e){let t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return V(t),t}function oe(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function le(e,t=(e=>0),n,r){return new Promise(((a,s)=>{let i=0,o=()=>{if(e())return void a();i++;let l=t(i);null!=n&&i>=n?s():null!=r?r(o,l):setTimeout(o,l)};o()}))}function ue(e,t){let n=1,r=-1;for(let s=0;s<e.length;++s)if(e[s]>=0)n*=e[s];else if(-1===e[s]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${s}`);r=s}else if(e[s]<0)throw Error(`Shapes can not be < 0. Found ${e[s]} at dim ${s}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);let a=e.slice();return a[r]=t/n,a}function pe(e,t){let n=t.length;return e=null==e?t.map(((e,t)=>t)):[].concat(e),Y(e.every((e=>e>=-n&&e<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`)),Y(e.every((e=>re(e))),(()=>`All values in axis param must be integers but got axis ${e}`)),e.map((e=>e<0?n+e:e))}function ce(e,t){let n=[],r=[],a=null!=t&&Array.isArray(t)&&0===t.length,s=null==t||a?null:pe(t,e).sort(),i=0;for(let o=0;o<e.length;++o){if(null!=s){if(s[i]===o&&1!==e[o])throw new Error(`Can't squeeze axis ${o} since its dim '${e[o]}' is not 1`);(null==s[i]||s[i]>o)&&1===e[o]&&(n.push(e[o]),r.push(o)),s[i]<=o&&i++}1!==e[o]&&(n.push(e[o]),r.push(o))}return{newShape:n,keptDims:r}}function de(e,t){return he(e,t)}function he(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function fe(e,t){for(let n=0;n<e.length;n++){let r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function me(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}function ge(e,t){return!("complex64"===t||"float32"===t&&"complex64"!==e||"int32"===t&&"float32"!==e&&"complex64"!==e||"bool"===t&&"bool"===e)}function ye(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function be(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}function xe(e){return"string"==typeof e||e instanceof String}function ve(e){return"boolean"==typeof e}function we(e){return"number"==typeof e}function ke(e){return Array.isArray(e)?ke(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":we(e)?"float32":xe(e)?"string":ve(e)?"bool":"float32"}function Ie(e){return!!(e&&e.constructor&&e.call&&e.apply)}function Se(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function Ne(e){let t=e.length;if(t<2)return[];let n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function Te(e,t,n,r=!1){let a=new Array;if(1===t.length){let s=t[0]*(r?2:1);for(let t=0;t<s;t++)a[t]=n[e+t]}else{let s=t[0],i=t.slice(1),o=i.reduce(((e,t)=>e*t))*(r?2:1);for(let t=0;t<s;t++)a[t]=Te(e+t*o,i,n,r)}return a}function _e(e,t,n=!1){if(0===e.length)return t[0];let r=e.reduce(((e,t)=>e*t))*(n?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return Te(0,e,t,n)}function Ce(e,t){if(Array.isArray(e))return e;if("float32"===t)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===t)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function Ee(e,t){let n=Ae(e,t);for(let r=0;r<n.length;r++)n[r]=1;return n}function Ae(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function $e(e,t){let n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return _e(e,new Float32Array(n));if("int32"===t)return _e(e,new Int32Array(n));if("bool"===t)return _e(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function Re(e){e.forEach((t=>{Y(Number.isInteger(t)&&t>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`))}))}function Fe(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let a=0;a<e.length-1;++a)r+=n[a]*e[a];return r}function De(e,t,n){if(0===t)return[];if(1===t)return[e];let r=new Array(t);for(let a=0;a<r.length-1;++a)r[a]=Math.floor(e/n[a]),e-=r[a]*n[a];return r[r.length-1]=e,r}function Me(e){return e&&e.then&&"function"==typeof e.then}var Oe="tfjsflags",Pe=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Le,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(We().getBool("IS_TEST")||We().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){let t=this.urlFlags[e];We().getBool("IS_TEST")||We().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if(Me(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if("undefined"==typeof this.global||"undefined"==typeof this.global.location||"undefined"==typeof this.global.location.search)return;let e=this.getQueryParams(this.global.location.search);Oe in e&&e[Oe].split(",").forEach((e=>{let[t,n]=e.split(":");this.urlFlags[t]=Be(t,n)}))}};function Le(e){let t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,((e,...n)=>(ze(t,n[0],n[1]),n.join("=")))),t}function ze(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}function Be(e,t){if(t=t.toLowerCase(),"true"===t||"false"===t)return"true"===t;if(""+ +t===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${e}.`)}function We(){return Ve}var Ue,Ve=null;function Ge(e){Ve=e}function He(){if(null==Ue){let e;if("undefined"!=typeof window)e=window;else if("undefined"!=typeof n.g)e=n.g;else if("undefined"!=typeof process)e=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");e=self}Ue=e}return Ue}function je(){let e=He();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}function qe(e,t){let n=je();if(n.has(e))return n.get(e);{let r=t();return n.set(e,r),n.get(e)}}var Ke="Abs",Xe="Acos",Je="Acosh",Ye="Add",Ze="AddN",Qe="All",et="Any",tt="ArgMax",nt="ArgMin",rt="Asin",at="Asinh",st="Atan",it="Atanh",ot="Atan2",lt="AvgPool",ut="AvgPoolGrad",pt="AvgPool3D",ct="AvgPool3DGrad",dt="BatchMatMul",ht="BatchToSpaceND",ft="Bincount",mt="BroadcastTo",gt="BroadcastArgs",yt="Cast",bt="Ceil",xt="ClipByValue",vt="Complex",wt="ComplexAbs",kt="Concat",It="Conv2D",St="Conv2DBackpropFilter",Nt="Conv2DBackpropInput",Tt="Conv3D",_t="Conv3DBackpropFilterV2",Ct="Conv3DBackpropInputV2",Et="Cos",At="Cosh",$t="Cumprod",Rt="Cumsum",Ft="CropAndResize",Dt="DenseBincount",Mt="DepthToSpace",Ot="DepthwiseConv2dNative",Pt="DepthwiseConv2dNativeBackpropFilter",Lt="DepthwiseConv2dNativeBackpropInput",zt="Diag",Bt="Dilation2D",Wt="Dilation2DBackpropInput",Ut="Dilation2DBackpropFilter",Vt="RealDiv",Gt="Einsum",Ht="Elu",jt="EluGrad",qt="Erf",Kt="Equal",Xt="Exp",Jt="ExpandDims",Yt="Expm1",Zt="FFT",Qt="Fill",en="FlipLeftRight",tn="Floor",nn="FloorDiv",rn="FusedBatchNorm",an="GatherV2",sn="GatherNd",on="Greater",ln="GreaterEqual",un="Identity",pn="IFFT",cn="Imag",dn="IsFinite",hn="IsInf",fn="IsNan",mn="LeakyRelu",gn="Less",yn="LessEqual",bn="LinSpace",xn="Log",vn="Log1p",wn="LogicalAnd",kn="LogicalNot",In="LogicalOr",Sn="LogicalXor",Nn="LogSoftmax",Tn="LowerBound",_n="LRN",Cn="LRNGrad",En="MatrixBandPart",An="Max",$n="Maximum",Rn="MaxPool",Fn="MaxPoolGrad",Dn="MaxPool3D",Mn="MaxPool3DGrad",On="MaxPoolWithArgmax",Pn="Mean",Ln="Min",zn="Minimum",Bn="MirrorPad",Wn="Mod",Un="Multinomial",Vn="Multiply",Gn="Neg",Hn="NotEqual",jn="NonMaxSuppressionV3",qn="NonMaxSuppressionV4",Kn="NonMaxSuppressionV5",Xn="OnesLike",Jn="OneHot",Yn="Pack",Zn="PadV2",Qn="Pool",er="Pow",tr="Prelu",nr="Prod",rr="RaggedGather",ar="RaggedRange",sr="RaggedTensorToTensor",ir="Range",or="Real",lr="Reciprocal",ur="Relu",pr="Reshape",cr="ResizeNearestNeighbor",dr="ResizeNearestNeighborGrad",hr="ResizeBilinear",fr="ResizeBilinearGrad",mr="Relu6",gr="Reverse",yr="Round",br="Rsqrt",xr="ScatterNd",vr="TensorScatterUpdate",wr="SearchSorted",kr="Select",Ir="Selu",Sr="Slice",Nr="Sin",Tr="Sinh",_r="Sign",Cr="Sigmoid",Er="Softplus",Ar="Sqrt",$r="Sum",Rr="SpaceToBatchND",Fr="SplitV",Dr="Softmax",Mr="SparseFillEmptyRows",Or="SparseReshape",Pr="SparseSegmentMean",Lr="SparseSegmentSum",zr="SparseToDense",Br="SquaredDifference",Wr="Square",Ur="StaticRegexReplace",Vr="StridedSlice",Gr="StringNGrams",Hr="StringSplit",jr="StringToHashBucketFast",qr="Sub",Kr="Tan",Xr="Tanh",Jr="Tile",Yr="TopK",Zr="Transform",Qr="Transpose",ea="Unique",ta="Unpack",na="UnsortedSegmentSum",ra="UpperBound",aa="ZerosLike",sa="Step",ia="FromPixels",oa="RotateWithOffset",la="_FusedMatMul",ua="FusedConv2D",pa="FusedDepthwiseConv2D";function ca(...e){We().getBool("IS_TEST")||We().getBool("PROD")||console.warn(...e)}function da(...e){We().getBool("IS_TEST")||We().getBool("PROD")||console.log(...e)}var ha=qe("kernelRegistry",(()=>new Map)),fa=qe("gradRegistry",(()=>new Map));function ma(e,t){let n=Ia(e,t);return ha.get(n)}function ga(e){return fa.get(e)}function ya(e){let t=ha.entries(),n=[];for(;;){let{done:r,value:a}=t.next();if(r)break;let[s,i]=a,[o]=s.split("_");o===e&&n.push(i)}return n}function ba(e){let{kernelName:t,backendName:n}=e,r=Ia(t,n);ha.has(r)&&ca(`The kernel '${t}' for backend '${n}' is already registered`),ha.set(r,e)}function xa(e){let{kernelName:t}=e;fa.has(t)&&We().getBool("DEBUG")&&ca(`Overriding the gradient for '${t}'`),fa.set(t,e)}function va(e,t){let n=Ia(e,t);if(!ha.has(n))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);ha.delete(n)}function wa(e){if(!fa.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);fa.delete(e)}function ka(e,t){ya(e).forEach((e=>{let n=Object.assign({},e,{backendName:t});ba(n)}))}function Ia(e,t){return`${t}_${e}`}var Sa={};g(Sa,{arraysEqual:()=>ne,assert:()=>Y,assertNonNegativeIntegerDimensions:()=>Re,assertNonNull:()=>Q,assertShapesMatch:()=>Z,bytesFromStringArray:()=>be,bytesPerElement:()=>ye,checkConversionForErrors:()=>fe,clamp:()=>H,computeStrides:()=>Ne,convertBackendValuesAndArrayBuffer:()=>Ce,createScalarValue:()=>Va,createShuffledIndices:()=>ie,decodeString:()=>Xa,distSquared:()=>J,encodeString:()=>Ka,fetch:()=>qa,fingerPrint64:()=>Ua,flatten:()=>Ya,getArrayFromDType:()=>he,getTypedArrayFromDType:()=>de,hasEncodingLoss:()=>ge,hexToLong:()=>_a,indexToLoc:()=>De,inferDtype:()=>ke,inferFromImplicitShape:()=>ue,isBoolean:()=>ve,isFunction:()=>Ie,isInt:()=>re,isNumber:()=>we,isPromise:()=>Me,isScalarShape:()=>te,isString:()=>xe,isTypedArray:()=>Ja,isValidDtype:()=>me,locToIndex:()=>Fe,makeOnesTypedArray:()=>Ee,makeZerosNestedTypedArray:()=>$e,makeZerosTypedArray:()=>Ae,nearestDivisor:()=>Se,nearestLargerEven:()=>j,now:()=>ja,parseAxisParam:()=>pe,randUniform:()=>X,repeatedTry:()=>le,rightPad:()=>oe,shuffle:()=>V,shuffleCombo:()=>G,sizeFromShape:()=>ee,sizeToSquarishShape:()=>se,squeezeShape:()=>ce,sum:()=>K,swap:()=>q,tanh:()=>ae,toNestedArray:()=>_e,toTypedArray:()=>Ha});var Na=b(x()),Ta=Na.default||Na;function _a(e){return Ta.fromString(e,!0,16)}var Ca=_a("c3a5c85c97cb3127"),Ea=_a("b492b66fbe98f273"),Aa=_a("9ae16a3b2f90404f");function $a(e){return e.xor(e.shru(47))}function Ra(e,t,n){let r=e.slice(t,t+n);return Ta.fromBytes(Array.from(r),!0,!0)}function Fa(e,t){return Ra(e,t,8)}function Da(e,t){return Ra(e,t,4)}function Ma(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function Oa(e,t,n=_a("9ddfea08eb382d69")){let r=e.xor(t).mul(n);r=r.xor(r.shru(47));let a=t.xor(r).mul(n);return a=a.xor(a.shru(47)),a=a.mul(n),a}function Pa(e,t,n,r,a,s){a=a.add(e),s=Ma(s.add(a).add(r),21);let i=a;return a=a.add(t),a=a.add(n),s=s.add(Ma(a,44)),[a.add(r),s.add(i)]}function La(e,t,n,r){return Pa(Fa(e,t),Fa(e,t+8),Fa(e,t+16),Fa(e,t+24),n,r)}function za(e,t=e.length){if(t>=8){let n=Aa.add(2*t),r=Fa(e,0).add(Aa),a=Fa(e,t-8),s=Ma(a,37).mul(n).add(r),i=Ma(r,25).add(a).mul(n);return Oa(s,i,n)}if(t>=4){let n=Aa.add(2*t),r=Da(e,0);return Oa(r.shl(3).add(t),Da(e,t-4),n)}if(t>0){let n=e[0],r=e[t>>1],a=e[t-1],s=n+(r<<8),i=t+(a<<2);return $a(Aa.mul(s).xor(Ca.mul(i))).mul(Aa)}return Aa}function Ba(e,t=e.length){let n=Aa.add(2*t),r=Fa(e,0).mul(Ea),a=Fa(e,8),s=Fa(e,t-8).mul(n),i=Fa(e,t-16).mul(Aa);return Oa(Ma(r.add(a),43).add(Ma(s,30)).add(i),r.add(Ma(a.add(Aa),18)).add(s),n)}function Wa(e,t=e.length){let n=Aa.add(2*t),r=Fa(e,0).mul(Aa),a=Fa(e,8),s=Fa(e,t-8).mul(n),i=Fa(e,t-16).mul(Aa),o=Ma(r.add(a),43).add(Ma(s,30)).add(i),l=Oa(o,r.add(Ma(a.add(Aa),18)).add(s),n),u=Fa(e,16).mul(n),p=Fa(e,24),c=o.add(Fa(e,t-32)).mul(n),d=l.add(Fa(e,t-24)).mul(n);return Oa(Ma(u.add(p),43).add(Ma(c,30)).add(d),u.add(Ma(p.add(r),18)).add(c),n)}function Ua(e,t=e.length){let n=Ta.fromNumber(81,!0);if(t<=32)return t<=16?za(e,t):Ba(e,t);if(t<=64)return Wa(e,t);let r=n,a=n.mul(Ea).add(113),s=$a(a.mul(Aa).add(113)).mul(Aa),i=[Ta.UZERO,Ta.UZERO],o=[Ta.UZERO,Ta.UZERO];r=r.mul(Aa).add(Fa(e,0));let l=0,u=64*(t-1>>6),p=u+(t-1&63)-63;do{r=Ma(r.add(a).add(i[0]).add(Fa(e,l+8)),37).mul(Ea),a=Ma(a.add(i[1]).add(Fa(e,l+48)),42).mul(Ea),r=r.xor(o[1]),a=a.add(i[0]).add(Fa(e,l+40)),s=Ma(s.add(o[0]),33).mul(Ea),i=La(e,l,i[1].mul(Ea),r.add(o[0])),o=La(e,l+32,s.add(o[1]),a.add(Fa(e,l+16))),[s,r]=[r,s],l+=64}while(l!==u);let c=Ea.add(s.and(255).shl(1));return l=p,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),r=Ma(r.add(a).add(i[0]).add(Fa(e,l+8)),37).mul(c),a=Ma(a.add(i[1]).add(Fa(e,l+48)),42).mul(c),r=r.xor(o[1].mul(9)),a=a.add(i[0].mul(9).add(Fa(e,l+40))),s=Ma(s.add(o[0]),33).mul(c),i=La(e,l,i[1].mul(c),r.add(o[0])),o=La(e,l+32,s.add(o[1]),a.add(Fa(e,l+16))),[s,r]=[r,s],Oa(Oa(i[0],o[0],c).add($a(a).mul(Ca)).add(s),Oa(i[1],o[1],c).add(r),c)}function Va(e,t){return"string"===t?Ka(e):Ha([e],t)}function Ga(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}function Ha(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=Ya(e)),We().getBool("DEBUG")&&fe(e,t),Ga(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){let t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error(`Unknown data type ${t}`)}function ja(){return We().platform.now()}function qa(e,t){return We().platform.fetch(e,t)}function Ka(e,t="utf-8"){return t=t||"utf-8",We().platform.encode(e,t)}function Xa(e,t="utf-8"){return t=t||"utf-8",We().platform.decode(e,t)}function Ja(e){return We().platform.isTypedArray(e)}function Ya(e,t=[],n=!1){if(null==t&&(t=[]),"boolean"==typeof e||"number"==typeof e||"string"==typeof e||Me(e)||null==e||Ja(e)&&n)t.push(e);else if(Array.isArray(e)||Ja(e))for(let r=0;r<e.length;++r)Ya(e[r],t,n);else{let r=-1;for(let t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(r=Math.max(r,Number(t)));for(let a=0;a<=r;a++)Ya(e[a],t,n)}return t}var Za=class{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new es)}profileKernel(e,t,n){let r,a,s=()=>{r=n()},i=ja();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(s);else{s();for(let e of r)e.dataSync();a=Promise.resolve({kernelMs:ja()-i})}if(We().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let o=0;o<r.length;o++){let t=r[o];t.data().then((n=>{Qa(n,t.dtype,e)}))}return{kernelName:e,outputs:r,inputs:t,timeMs:a.then((e=>e.kernelMs)),extraInfo:a.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){let{kernelName:t,outputs:n,timeMs:r,inputs:a,extraInfo:s}=e;n.forEach((e=>{Promise.all([e.data(),r,s]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],a,n[2])}))}))}};function Qa(e,t,n){if("float32"!==t)return!1;for(let r=0;r<e.length;r++){let t=e[r];if(isNaN(t)||!isFinite(t))return console.warn(`Found ${t} in the result of '${n}'`),!0}return!1}var es=class{logKernelProfile(e,t,n,r,a,s){let i="number"==typeof r?oe(`${r}ms`,9):r.error,o=oe(e,25),l=t.rank,u=t.size,p=oe(t.shape.toString(),14),c="";for(let d in a){let e=a[d];if(null!=e){let n=e.shape||t.shape,r=n.length;c+=`${d}: ${r}D ${r>0?n:""} `}}console.log(`%c${o}\t%c${i}\t%c${l}D ${p}\t%c${u}\t%c${c}\t%c${s}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function ts(e,t,n){let r={},a={};for(let l=0;l<t.length;l++)r[t[l].id]=!0;for(let l=0;l<e.length;l++){let n=e[l],s=n.inputs;for(let e in s){let i=s[e],o=!1;for(let e=0;e<t.length;e++)if(r[i.id]){n.outputs.forEach((e=>r[e.id]=!0)),o=!0,a[n.id]=!0;break}if(o)break}}let s={};s[n.id]=!0;let i={};for(let l=e.length-1;l>=0;l--){let t=e[l],n=t.inputs;for(let e=0;e<t.outputs.length;e++)if(s[t.outputs[e].id]){for(let e in n)s[n[e].id]=!0,i[t.id]=!0;break}}let o=[];for(let l=0;l<e.length;l++){let t=e[l];if(a[t.id]&&i[t.id]){let e={};for(let a in t.inputs){let n=t.inputs[a];r[n.id]&&(e[a]=n)}let n=Object.assign({},t);n.inputs=e,n.outputs=t.outputs,o.push(n)}}return o}function ns(e,t,n,r){for(let a=t.length-1;a>=0;a--){let s=t[a],i=[];if(s.outputs.forEach((t=>{let n=e[t.id];null!=n?i.push(n):i.push(null)})),null==s.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);let o=s.gradient(i);for(let t in s.inputs){if(!(t in o))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(o)}.`);let a=n((()=>o[t]()));if("float32"!==a.dtype)throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${a.dtype}'`);let i=s.inputs[t];if(!ne(a.shape,i.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${t}' has shape '${a.shape}', which does not match the shape of the input '${i.shape}'`);if(null==e[i.id])e[i.id]=a;else{let t=e[i.id];e[i.id]=r(t,a),t.dispose()}}}}var rs=20,as=3,ss=7;function is(e,t,n,r){let a=Ne(t),s=os(e,t,n,a),i=t.length,o=ps(e,t,n,a,s),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${i}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(o.map((e=>"    "+e)).join("\n")),l.join("\n")}function os(e,t,n,r){let a=ee(t),s=r[r.length-1],i=new Array(s).fill(0),o=t.length,l="complex64"===n?cs(e):e;if(o>1)for(let u=0;u<a/s;u++){let e=u*s;for(let t=0;t<s;t++)i[t]=Math.max(i[t],ls(l[e+t],0,n).length)}return i}function ls(e,t,n){let r;return r=Array.isArray(e)?`${parseFloat(e[0].toFixed(ss))} + ${parseFloat(e[1].toFixed(ss))}j`:xe(e)?`'${e}'`:"bool"===n?us(e):parseFloat(e.toFixed(ss)).toString(),oe(r,t)}function us(e){return 0===e?"false":"true"}function ps(e,t,n,r,a,s=!0){let i="complex64"===n?2:1,o=t[0],l=t.length;if(0===l){if("complex64"===n){let t=cs(e);return[ls(t[0],0,n)]}return"bool"===n?[us(e[0])]:[e[0].toString()]}if(1===l){if(o>rs){let t=as*i,r=Array.from(e.slice(0,t)),s=Array.from(e.slice((o-as)*i,o*i));return"complex64"===n&&(r=cs(r),s=cs(s)),["["+r.map(((e,t)=>ls(e,a[t],n))).join(", ")+", ..., "+s.map(((e,t)=>ls(e,a[o-as+t],n))).join(", ")+"]"]}return["["+("complex64"===n?cs(e):Array.from(e)).map(((e,t)=>ls(e,a[t],n))).join(", ")+"]"]}let u=t.slice(1),p=r.slice(1),c=r[0]*i,d=[];if(o>rs){for(let t=0;t<as;t++){let r=t*c,s=r+c;d.push(...ps(e.slice(r,s),u,n,p,a,!1))}d.push("...");for(let t=o-as;t<o;t++){let r=t*c,s=r+c;d.push(...ps(e.slice(r,s),u,n,p,a,t===o-1))}}else for(let m=0;m<o;m++){let t=m*c,r=t+c;d.push(...ps(e.slice(t,r),u,n,p,a,m===o-1))}let h=2===l?",":"";d[0]="["+(o>0?d[0]+h:"");for(let m=1;m<d.length-1;m++)d[m]=" "+d[m]+h;let f=",\n";for(let m=2;m<l;m++)f+="\n";return d[d.length-1]=" "+d[d.length-1]+"]"+(s?"":f),d}function cs(e){let t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}var ds=class{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=ee(e),null!=n){let e=n.length;Y(e===this.size,(()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||he(t,this.size),this.strides=Ne(e)}set(e,...t){0===t.length&&(t=[0]),Y(t.length===this.rank,(()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`));let n=this.locToIndex(t);this.values[n]=e}get(...e){0===e.length&&(e=[0]);let t=0;for(let r of e){if(r<0||r>=this.shape[t]){let t=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(t)}t++}let n=e[e.length-1];for(let r=0;r<e.length-1;++r)n+=this.strides[r]*e[r];return this.values[n]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];let t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return hs().makeTensor(this.values,this.shape,this.dtype)}},hs=null,fs=null;function ms(e){hs=e}function gs(e){fs=e}function ys(e){e}var bs=class{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=ee(e),this.strides=Ne(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let e=await this.data();return fs.buffer(this.shape,this.dtype,e)}bufferSync(){return fs.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return _e(this.shape,e,"complex64"===this.dtype)}arraySync(){return _e(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();let e=hs().read(this.dataId);if("string"===this.dtype){let n=await e;try{return n.map((e=>Xa(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),hs().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();let e=hs().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>Xa(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();let e=await hs().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(hs().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return fs.print(this,e)}clone(){return this.throwIfDisposed(),fs.clone(this)}toString(e=!1){let t=this.dataSync();return is(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),fs.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),hs().makeVariable(this,e,t,n)}};function xs(){return qe("Tensor",(()=>bs))}Object.defineProperty(bs,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),xs();var vs=class extends bs{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!ne(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);hs().disposeTensor(this),this.dataId=e.dataId,hs().incRef(this,null)}dispose(){hs().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(vs,Symbol.hasInstance,{value:e=>e instanceof bs&&null!=e.assign&&e.assign instanceof Function});var ws,ks,Is,Ss,Ns,Ts={};g(Ts,{assertTypesMatch:()=>Fs,getTensorsInContainer:()=>Ms,isTensorInList:()=>Ds,makeTypesMatch:()=>Rs}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(ws||(ws={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(ks||(ks={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(Is||(Is={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(Ss||(Ss={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(Ns||(Ns={}));var _s={float32:Ss,int32:ks,bool:Is,complex64:Ns};function Cs(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return _s[e][t]}function Es(e){return Cs(e,"int32")}function As(e){return null!=e&&"object"==typeof e&&"texture"in e&&e.texture instanceof WebGLTexture}function $s(e){return"undefined"!=typeof GPUBuffer&&null!=e&&"object"==typeof e&&"buffer"in e&&e.buffer instanceof GPUBuffer}function Rs(e,t){if(e.dtype===t.dtype)return[e,t];let n=Cs(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function Fs(e,t){Y(e.dtype===t.dtype,(()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`))}function Ds(e,t){return t.some((t=>t.id===e.id))}function Ms(e){let t=[];return Os(e,t,new Set),t}function Os(e,t,n){if(null==e)return;if(e instanceof bs)return void t.push(e);if(!Ps(e))return;let r=e;for(let a in r){let e=r[a];n.has(e)||(n.add(e),Os(e,t,n))}}function Ps(e){return Array.isArray(e)||"object"==typeof e}function Ls(e){return null!=e.kernelName}var zs=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}},Bs=class{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new zs}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){let{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{let{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(ca(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;let{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new Za(this.backendInstance),!0}setupRegisteredKernels(){ya(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){ya(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){let t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{let n=t.factory();if(!n||n instanceof W||"function"!=typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{let t=++this.pendingBackendInitId,r=n.then((n=>!(t<this.pendingBackendInitId)&&(this.registry[e]=n,this.pendingBackendInit=null,!0))).catch((n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,ca(`Initialization of backend ${e} failed`),ca(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(n){return ca(`Initialization of backend ${e} failed`),ca(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t],{success:r,asyncInit:a}=this.initializeBackend(n);if(a||r)return{name:n,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){let n=this.state.tensorInfo.get(t),r=n.backend,a=this.readSync(t),s=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,a,n.shape,n.dtype,s),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,r=null;if(null==t){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{let e=n();return t(),e}catch(r){throw t(),r}}nextTensorId(){return Bs.nextTensorId++}nextVariableId(){return Bs.nextVariableId++}clone(e){let t=Vs.runKernel(un,{x:e}),n={x:e},r=e=>({x:()=>{let t="float32",n={x:e},r={dtype:t};return Vs.runKernel(yt,n,r)}}),a=[];return this.addTapeNode(this.state.activeScope.name,n,[t],r,a,{}),t}runKernel(e,t,n){if(null==this.backendName&&this.backend,null==ma(e,this.backendName))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){let r=this.backend.numDataIds(),a=0;n.forEach((e=>{a+="complex64"===e.dtype?3:1}));let s=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-t-a-s;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let t,n,r=[],a=this.isTapeOn(),s=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;let o,l=Ls(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(Ls(e)){let{kernelName:t,inputs:s,attrs:i}=e;null==this.backendName&&this.backend;let l=ma(t,this.backendName);Y(null!=l,(()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`)),n=()=>{let e=this.backend.numDataIds();o=l.kernelFunc({inputs:s,attrs:i,backend:this.backend});let n=Array.isArray(o)?o:[o];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,n);let u=n.map((e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e)));if(a){let e=this.getTensorsForGradient(t,s,u);r=this.saveTensorsForBackwardMode(e)}return u}}else{let{forwardFunc:t}=e,s=e=>{a&&(r=e.map((e=>this.keep(this.clone(e)))))};n=()=>{let e=this.backend.numDataIds();o=this.tidy((()=>t(this.backend,s)));let n=Array.isArray(o)?o:[o];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,e,n),n}}let u,{inputs:p,attrs:c}=e,d=Ls(e)?null:e.backwardsFunc;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(u=this.profiler.profileKernel(l,p,(()=>n())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(u),t=u.outputs):t=n()})),a&&this.addTapeNode(l,p,t,d,r,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(p).map((e=>null!=p[e]?p[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:u.timeMs,extraInfo:u.extraInfo}),Array.isArray(o)?t:t[0]}saveTensorsForBackwardMode(e){return e.map((e=>this.keep(this.clone(e))))}getTensorsForGradient(e,t,n){let r=ga(e);if(null!=r){let e,a=r.inputsToSave||[],s=r.outputsToSave||[];r.saveAllInputs?(Y(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),e=Object.keys(t).map((e=>t[e]))):e=a.map((e=>t[e]));let i=n.filter(((e,t)=>s[t]));return e.concat(i)}return[]}makeTensor(e,t,n,r){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let a=e;"string"===n&&xe(e[0])&&(a=e.map((e=>Ka(e))));let s=r.write(a,t,n),i=new bs(t,n,s,this.nextTensorId());if(this.trackTensor(i,r),"string"===n){let e=this.state.tensorInfo.get(s),t=be(a);this.state.numBytes+=t-e.bytes,e.bytes=t}return i}makeTensorFromDataId(e,t,n,r){n=n||"float32";let a={dataId:e,shape:t,dtype:n};return this.makeTensorFromTensorInfo(a,r)}makeTensorFromTensorInfo(e,t){let{dataId:n,shape:r,dtype:a}=e,s=new bs(r,a,n,this.nextTensorId());return this.trackTensor(s,t),s}makeVariable(e,t=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==e.dtype&&(e=e.cast(r));let a=new vs(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[a.name])throw new Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*ye(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof vs||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;let t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){let t=e.size*ye(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(let e in this.state.registeredVariables){let t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){let e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;let t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(let r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,r,a,s){let i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:a},o=ga(e);null!=o&&(r=o.gradFunc),null!=r&&(i.gradient=e=>(e=e.map(((e,t)=>{if(null==e){let e=n[t],r=Ae(e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e})),r(e.length>1?e:e[0],a,s))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){let t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){let t=Ms(e),n=new Set(t.map((e=>e.id)));for(let a=0;a<this.state.activeScope.track.length;a++){let e=this.state.activeScope.track[a];!e.kept&&!n.has(e.id)&&e.dispose()}let r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{!e.kept&&e.scopeId===r.id&&this.track(e)}))}gradients(e,t,n,r=!1){if(Y(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);let a=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));Y(a instanceof bs,(()=>"The result y returned by f() must be a tensor."));let s=ts(this.state.activeTape,t,a);if(!r&&0===s.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{let e={};e[a.id]=null==n?Ws(a.shape):n,ns(e,s,(e=>this.tidy(e)),Gs);let r=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(let t of e.saved)t.dispose()})),this.state.activeTape=null),{value:a,grads:r}}))}customGrad(e){return Y(Ie(e),(()=>"The f passed in customGrad(f) must be a function.")),(...t)=>{Y(t.every((e=>e instanceof bs)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));let n,r={};t.forEach(((e,t)=>{r[t]=e}));let a=(r,a)=>(n=e(...t,a),Y(n.value instanceof bs,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),Y(Ie(n.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),n.value),s=(e,r)=>{let a=n.gradFunc(e,r),s=Array.isArray(a)?a:[a];Y(s.length===t.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),Y(s.every((e=>e instanceof bs)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));let i={};return s.forEach(((e,t)=>{i[t]=()=>e})),i};return this.runKernelFunc({forwardFunc:a,backwardsFunc:s,inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){let t=ja(),n=await this.backend.time(e);return n.wallMs=ja()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new zs;for(let e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};function Ws(e){let t=Ee(ee(e),"float32");return Vs.makeTensor(t,e,"float32")}function Us(){let e=He();if(null==e._tfengine){let t=new Pe(e);e._tfengine=new Bs(t)}return Ge(e._tfengine.ENV),ms((()=>e._tfengine)),e._tfengine}Bs.nextTensorId=0,Bs.nextVariableId=0;var Vs=Us();function Gs(e,t){let n={a:e,b:t};return Vs.runKernel(Ye,n)}var Hs,js={};function qs(){return"undefined"!=typeof navigator&&null!=navigator}function Ks(e){Hs=e}function Xs(e){if(void 0!==Hs)return Hs;if(e||qs()){if(e||(e=navigator),"ReactNative"===e.product)return!0;let t=e.userAgent||e.vendor||("undefined"!=typeof window?window.opera:"");if(!t){let t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function Js(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}g(js,{isBrowser:()=>Js,isMobile:()=>Xs,mockIsMobile:()=>Ks});var Ys=We();function Zs(e,t){let n=e;if(Ja(e))return"string"===t?[]:[e.length];if(As(e)){let t=e.channels||"RGBA";return[e.height,e.width*t.length]}if($s(e))return[e.buffer.size/(null==t?4:ye(t))];if(!Array.isArray(e))return[];let r=[];for(;Array.isArray(n)||Ja(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&We().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Qs(e,r,[]),r}function Qs(e,t,n){if(n=n||[],!Array.isArray(e)&&!Ja(e))return void Y(0===t.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`));Y(t.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`)),Y(e.length===t[0],(()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`));let r=t.slice(1);for(let a=0;a<e.length;++a)Qs(e[a],r,n.concat(a))}function ei(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function ti(e,t,n,r="numeric"){if(e instanceof bs)return ei(r,e.dtype,t,n),e;let a=ke(e);if("string"!==a&&["bool","int32","float32"].indexOf(r)>=0&&(a=r),ei(r,a,t,n),null==e||!Ja(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e){let r=null==e?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}let s=Zs(e,a);!Ja(e)&&!Array.isArray(e)&&(e=[e]);let i="string"!==a?Ha(e,a):Ya(e,[],!0);return Vs.makeTensor(i,s,a)}function ni(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map(((e,a)=>ti(e,`${t}[${a}]`,n,r)))}Ys.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),Ys.registerFlag("IS_BROWSER",(()=>Js())),Ys.registerFlag("IS_NODE",(()=>"undefined"!=typeof process&&"undefined"!=typeof process.versions&&"undefined"!=typeof process.versions.node)),Ys.registerFlag("IS_CHROME",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),Ys.registerFlag("IS_SAFARI",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor))),Ys.registerFlag("PROD",(()=>!1)),Ys.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>Ys.getBool("DEBUG"))),Ys.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),Ys.registerFlag("IS_TEST",(()=>!1)),Ys.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>Ys.getBool("DEBUG"))),Ys.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),Ys.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),Ys.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));var ri="__op";function ai(e){let t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0],r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=ri;let a=(...e)=>{Vs.startScope(n);try{let t=r(...e);return Me(t)&&console.error("Cannot return a Promise inside of tidy."),Vs.endScope(t),t}catch(t){throw Vs.endScope(null),t}};return Object.defineProperty(a,"name",{value:n,configurable:!0}),a}function si(e,t){let n=ti(e,"real","complex"),r=ti(t,"imag","complex");Z(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);let a={real:n,imag:r};return Vs.runKernel(vt,a)}var ii=ai({complex_:si});function oi(e,t,n,r){if(null==r)r=ke(e);else if("complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if($s(e)||As(e)){if("float32"!==r&&"int32"!==r)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return Vs.backend.createTensorFromGPUData(e,t||n,r)}if(!Ja(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){Re(t);let e=ee(t),r=ee(n);Y(e===r,(()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`));for(let a=0;a<n.length;++a){let e=n[a],r=a!==n.length-1||e!==ee(t.slice(a));Y(n[a]===t[a]||!r,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `))}}return!Ja(e)&&!Array.isArray(e)&&(e=[e]),t=t||n,e="string"!==r?Ha(e,r):Ya(e,[],!0),Vs.makeTensor(e,t,r)}function li(e,t,n){let r=Zs(e,n);return oi(e,t,r,n)}var ui={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},pi=4;async function ci(e,t){let n=[],r=[],a=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);for(let i=0;i<a.length;++i){let s=a[i],o=Array.isArray(e)?e[i].tensor:e[s];if("float32"!==o.dtype&&"int32"!==o.dtype&&"bool"!==o.dtype&&"string"!==o.dtype&&"complex64"!==o.dtype)throw new Error(`Unsupported dtype in weight '${s}': ${o.dtype}`);let l={name:s,shape:o.shape,dtype:o.dtype};if("string"===o.dtype){let e=new Promise((async e=>{let t=await o.bytes(),n=t.reduce(((e,t)=>e+t.length),0)+pi*t.length,r=new Uint8Array(n),a=0;for(let s=0;s<t.length;s++){let e=t[s],n=new Uint8Array(new Uint32Array([e.length]).buffer);r.set(n,a),a+=pi,r.set(e,a),a+=e.length}e(r)}));r.push(e)}else r.push(o.data());null!=t&&(l.group=t),n.push(l)}let s=await Promise.all(r);return{data:hi(s),specs:n}}function di(e,t){let n,r={},a=0;for(let s of t){let t,i=s.name,o=s.dtype,l=s.shape,u=ee(l);if("quantization"in s){let r=s.quantization;if("uint8"===r.dtype||"uint16"===r.dtype){if(!("min"in r)||!("scale"in r))throw new Error(`Weight ${s.name} with quantization ${r.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==r.dtype)throw new Error(`Weight ${s.name} has unknown quantization dtype ${r.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==o)throw new Error(`Weight ${s.name} is quantized with ${r.dtype} which only supports weights of type float32 not ${o}.`)}let l=ui[r.dtype],p=e.slice(a,a+u*l),c="uint8"===r.dtype?new Uint8Array(p):new Uint16Array(p);if("float32"===o)if("uint8"===r.dtype||"uint16"===r.dtype){t=new Float32Array(c.length);for(let e=0;e<c.length;e++){let n=c[e];t[e]=n*r.scale+r.min}}else{if("float16"!==r.dtype)throw new Error(`Unsupported quantization type ${r.dtype} for weight type float32.`);void 0===n&&(n=Ci()),t=n(c)}else{if("int32"!==o)throw new Error(`Unsupported dtype in weight '${i}': ${o}`);if("uint8"!==r.dtype&&"uint16"!==r.dtype)throw new Error(`Unsupported quantization type ${r.dtype} for weight type int32.`);t=new Int32Array(c.length);for(let e=0;e<c.length;e++){let n=c[e];t[e]=Math.round(n*r.scale+r.min)}}a+=u*l}else if("string"===o){let n=ee(s.shape);t=[];for(let r=0;r<n;r++){let n=new Uint32Array(e.slice(a,a+pi))[0];a+=pi;let r=new Uint8Array(e.slice(a,a+n));t.push(r),a+=n}}else{let n=ui[o],s=e.slice(a,a+u*n);if("float32"===o)t=new Float32Array(s);else if("int32"===o)t=new Int32Array(s);else if("bool"===o)t=new Uint8Array(s);else{if("complex64"!==o)throw new Error(`Unsupported dtype in weight '${i}': ${o}`);{t=new Float32Array(s);let e=new Float32Array(t.length/2),n=new Float32Array(t.length/2);for(let r=0;r<e.length;r++)e[r]=t[2*r],n[r]=t[2*r+1];let a=li(e,l,"float32"),o=li(n,l,"float32");r[i]=ii(a,o),a.dispose(),o.dispose()}}a+=u*n}"complex64"!==o&&(r[i]=li(t,l,o))}return r}function hi(e){if(null===e)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0,n=[];e.forEach((e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)}));let r=new Uint8Array(t),a=0;return n.forEach((e=>{r.set(new Uint8Array(e.buffer),a),a+=e.byteLength})),r.buffer}var fi="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function mi(e){return fi?Buffer.byteLength(e):new Blob([e]).size}function gi(e){if(fi)return Buffer.from(e).toString("base64");let t=new Uint8Array(e),n="";for(let r=0,a=t.length;r<a;r++)n+=String.fromCharCode(t[r]);return btoa(n)}function yi(e){if(fi){let t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}let t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;++r)n.set([t.charCodeAt(r)],r);return n.buffer}function bi(e){if(1===e.length)return e[0];let t=0;e.forEach((e=>{t+=e.byteLength}));let n=new Uint8Array(t),r=0;return e.forEach((e=>{n.set(new Uint8Array(e),r),r+=e.byteLength})),n.buffer}function xi(e){let t="/";for(e=e.trim();e.endsWith(t);)e=e.slice(0,e.length-1);let n=e.split(t);return n[n.length-1]}function vi(e,t){let n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(n.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}function wi(e,t,n){let r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(r.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=n}return null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(r.initializerSignature=e.initializerSignature),r}async function ki(e,t){let n,r;return null!=e.weightsManifest&&([n,r]=await t(e.weightsManifest)),wi(e,n,r)}function Ii(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:mi(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:mi(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:e.weightData.byteLength}}function Si(e){let t=[];for(let n of e)t.push(...n.weights);return t}function Ni(){let e=e=>{let t=e<<13,n=0;for(;!(8388608&t);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}function Ti(){let e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}function _i(){let e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}function Ci(){let e=Ni(),t=Ti(),n=_i();return r=>{let a=new ArrayBuffer(4*r.length),s=new Uint32Array(a);for(let i=0;i<r.length;i++){let a=r[i],o=e[n[a>>10]+(1023&a)]+t[a>>10];s[i]=o}return new Float32Array(a)}}var Ei=class{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==Ei.instance&&(Ei.instance=new Ei),Ei.instance}static registerSaveRouter(e){Ei.getInstance().saveRouters.push(e)}static registerLoadRouter(e){Ei.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return Ei.getHandlers(e,"save")}static getLoadHandlers(e,t){return Ei.getHandlers(e,"load",t)}static getHandlers(e,t,n){let r=[];return("load"===t?Ei.getInstance().loadRouters:Ei.getInstance().saveRouters).forEach((t=>{let a=t(e,n);null!==a&&r.push(a)})),r}},Ai=e=>Ei.registerSaveRouter(e),$i=e=>Ei.registerLoadRouter(e),Ri=e=>Ei.getSaveHandlers(e),Fi=(e,t)=>Ei.getLoadHandlers(e,t),Di="tensorflowjs",Mi=1,Oi="models_store",Pi="model_info_store";function Li(){if(!We().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let e="undefined"==typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function zi(e){let t=e.result;t.createObjectStore(Oi,{keyPath:"modelPath"}),t.createObjectStore(Pi,{keyPath:"modelPath"})}var Bi=class{constructor(e){if(this.indexedDB=Li(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{let r=this.indexedDB.open(Di,Mi);r.onupgradeneeded=()=>zi(r),r.onsuccess=()=>{let a=r.result;if(null==t){let t=a.transaction(Oi,"readonly"),r=t.objectStore(Oi).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return a.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(r.result.modelArtifacts)},r.onerror=e=>(a.close(),n(r.error)),t.oncomplete=()=>a.close()}else{let r,i,o=Ii(t),l=a.transaction(Pi,"readwrite"),u=l.objectStore(Pi);try{r=u.put({modelPath:this.modelPath,modelArtifactsInfo:o})}catch(s){return n(s)}r.onsuccess=()=>{i=a.transaction(Oi,"readwrite");let r,s=i.objectStore(Oi);try{r=s.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:o})}catch(p){return n(p)}r.onsuccess=()=>e({modelArtifactsInfo:o}),r.onerror=e=>{u=l.objectStore(Pi);let t=u.delete(this.modelPath);t.onsuccess=()=>(a.close(),n(r.error)),t.onerror=e=>(a.close(),n(r.error))}},r.onerror=e=>(a.close(),n(r.error)),l.oncomplete=()=>{null==i?a.close():i.oncomplete=()=>a.close()}}},r.onerror=e=>n(r.error)}))}};Bi.URL_SCHEME="indexeddb://";var Wi=e=>We().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Bi.URL_SCHEME)?Ui(e.slice(Bi.URL_SCHEME.length)):null;function Ui(e){return new Bi(e)}function Vi(e){return e.startsWith(Bi.URL_SCHEME)?e.slice(Bi.URL_SCHEME.length):e}Ei.registerSaveRouter(Wi),Ei.registerLoadRouter(Wi);var Gi=class{constructor(){this.indexedDB=Li()}async listModels(){return new Promise(((e,t)=>{let n=this.indexedDB.open(Di,Mi);n.onupgradeneeded=()=>zi(n),n.onsuccess=()=>{let r=n.result,a=r.transaction(Pi,"readonly"),s=a.objectStore(Pi).getAll();s.onsuccess=()=>{let t={};for(let e of s.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},s.onerror=e=>(r.close(),t(s.error)),a.oncomplete=()=>r.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){return e=Vi(e),new Promise(((t,n)=>{let r=this.indexedDB.open(Di,Mi);r.onupgradeneeded=()=>zi(r),r.onsuccess=()=>{let a,s=r.result,i=s.transaction(Pi,"readwrite"),o=i.objectStore(Pi),l=o.get(e);l.onsuccess=()=>{if(null==l.result)return s.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{let r=o.delete(e),i=()=>{a=s.transaction(Oi,"readwrite");let r=a.objectStore(Oi).delete(e);r.onsuccess=()=>t(l.result.modelArtifactsInfo),r.onerror=e=>n(l.error)};r.onsuccess=i,r.onerror=e=>(i(),s.close(),n(l.error))}},l.onerror=e=>(s.close(),n(l.error)),i.oncomplete=()=>{null==a?s.close():a.oncomplete=()=>s.close()}},r.onerror=e=>n(r.error)}))}},Hi="/",ji="tensorflowjs_models",qi="info",Ki="model_topology",Xi="weight_specs",Ji="weight_data",Yi="model_metadata";function Zi(e){return{info:[ji,e,qi].join(Hi),topology:[ji,e,Ki].join(Hi),weightSpecs:[ji,e,Xi].join(Hi),weightData:[ji,e,Ji].join(Hi),modelMetadata:[ji,e,Yi].join(Hi)}}function Qi(e){for(let t of Object.values(e))window.localStorage.removeItem(t)}function eo(e){let t=e.split(Hi);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(Hi)}function to(e){return e.startsWith(no.URL_SCHEME)?e.slice(no.URL_SCHEME.length):e}var no=class{constructor(e){if(!We().getBool("IS_BROWSER")||"undefined"==typeof window||"undefined"==typeof window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=Zi(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let n=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),a=Ii(e);try{this.LS.setItem(this.keys.info,JSON.stringify(a)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,gi(e.weightData));let t={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(t)),{modelArtifactsInfo:a}}catch(t){throw Qi(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${a.modelTopologyBytes}, weightSpecsBytes=${a.weightSpecsBytes}, weightDataBytes=${a.weightDataBytes}.`)}}}async load(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;let r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;let a=this.LS.getItem(this.keys.modelMetadata);if(null!=a){let e=JSON.parse(a);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(t.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}let s=this.LS.getItem(this.keys.weightData);if(null==s)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=yi(s),t}};no.URL_SCHEME="localstorage://";var ro=e=>We().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(no.URL_SCHEME)?ao(e.slice(no.URL_SCHEME.length)):null;function ao(e){return new no(e)}Ei.registerSaveRouter(ro),Ei.registerLoadRouter(ro);var so=class{constructor(){Y(We().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),Y("undefined"==typeof window||"undefined"!=typeof window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){let e={},t=ji+Hi,n=Hi+qi;for(let r=0;r<this.LS.length;++r){let a=this.LS.key(r);if(a.startsWith(t)&&a.endsWith(n)){let t=eo(a);e[t]=JSON.parse(this.LS.getItem(a))}}return e}async removeModel(e){e=to(e);let t=Zi(e);if(null==this.LS.getItem(t.info))throw new Error(`Cannot find model at path '${e}'`);let n=JSON.parse(this.LS.getItem(t.info));return Qi(t),n}},io="://",oo=class{constructor(){this.managers={}}static getInstance(){return null==oo.instance&&(oo.instance=new oo),oo.instance}static registerManager(e,t){Y(null!=e,(()=>"scheme must not be undefined or null.")),e.endsWith(io)&&(e=e.slice(0,e.indexOf(io))),Y(e.length>0,(()=>"scheme must not be an empty string."));let n=oo.getInstance();Y(null==n.managers[e],(()=>`A model store manager is already registered for scheme '${e}'.`)),n.managers[e]=t}static getManager(e){let t=oo.getInstance().managers[e];if(null==t)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(oo.getInstance().managers)}};function lo(e){if(-1===e.indexOf(io))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${oo.getSchemes().join(",")}`);return{scheme:e.split(io)[0],path:e.split(io)[1]}}async function uo(e,t,n=!1){Y(e!==t,(()=>`Old path and new path are the same: '${e}'`));let r=Ei.getLoadHandlers(e);Y(r.length>0,(()=>`Copying failed because no load handler is found for source URL ${e}.`)),Y(r.length<2,(()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`));let a=r[0],s=Ei.getSaveHandlers(t);Y(s.length>0,(()=>`Copying failed because no save handler is found for destination URL ${t}.`)),Y(s.length<2,(()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`));let i=s[0],o=lo(e).scheme,l=lo(e).path,u=o===lo(e).scheme,p=await a.load();n&&u&&await oo.getManager(o).removeModel(l);let c=await i.save(p);return n&&!u&&await oo.getManager(o).removeModel(l),c.modelArtifactsInfo}async function po(){let e=oo.getSchemes(),t={};for(let n of e){let e=await oo.getManager(n).listModels();for(let r in e){let a=n+io+r;t[a]=e[r]}}return t}async function co(e){let t=lo(e);return oo.getManager(t.scheme).removeModel(t.path)}async function ho(e,t){return uo(e,t,!1)}async function fo(e,t){return uo(e,t,!0)}var mo=class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){"undefined"!=typeof window&&We().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(e=>{if(e.source===window&&e.data.name===this.messageName){e.stopPropagation();let t=this.functionRefs[e.data.index];t(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}}),!0))):setTimeout(e,t)}isTypedArray(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}};if(We().get("IS_BROWSER")){We().setPlatform("browser",new mo);try{oo.registerManager(no.URL_SCHEME,new so)}catch(ple){}try{oo.registerManager(Bi.URL_SCHEME,new Gi)}catch(ple){}}var go,yo={importFetch:()=>v()},bo=class{constructor(){this.util=w(),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=We().global.fetch?We().global.fetch(e,t):(null==go&&(go=yo.importFetch()),go(e,t))}now(){let e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}};function xo(e,t="float32",n){return t=t||"float32",Re(e),new ds(e,t,n)}function vo(e,t){let n=ti(e,"x","cast");if(!me(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");let r={x:n},a={dtype:t};return Vs.runKernel(yt,r,a)}We().get("IS_NODE")&&!We().get("IS_BROWSER")&&We().setPlatform("node",new bo);var wo=ai({cast_:vo});function ko(e){let t={x:ti(e,"x","clone","string_or_numeric")};return Vs.runKernel(un,t)}var Io=ai({clone_:ko});function So(e,t=!1){console.log(e.toString(t))}Us();var No={buffer:xo,cast:wo,clone:Io,print:So};function To(){We().set("PROD",!0)}function _o(){We().set("DEBUG",!0)}function Co(){We().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function Eo(e){We().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function Ao(){Vs.disposeVariables()}function $o(){return Vs}function Ro(){return Vs.memory()}function Fo(e){return Vs.profile(e)}function Do(e,t){return Vs.tidy(e,t)}function Mo(e){Ms(e).forEach((e=>e.dispose()))}function Oo(e){return Vs.keep(e)}function Po(e){return Vs.time(e)}function Lo(e){return Vs.setBackend(e)}function zo(){return Vs.ready()}function Bo(){return Vs.backendName}function Wo(e){Vs.removeBackend(e)}function Uo(e){return Vs.findBackend(e)}function Vo(e){return Vs.findBackendFactory(e)}function Go(e,t,n=1){return Vs.registerBackend(e,t,n)}function Ho(){return Vs.backend}function jo(e,t){We().setPlatform(e,t)}function qo(e,t){let n=ti(e,"a","add"),r=ti(t,"b","add");[n,r]=Rs(n,r);let a={a:n,b:r};return Vs.runKernel(Ye,a)}gs(No),ys(Eo);var Ko=ai({add_:qo});function Xo(e,t){let n=ti(e,"a","floorDiv"),r=ti(t,"b","floorDiv");[n,r]=Rs(n,r);let a={a:n,b:r};return Vs.runKernel(nn,a)}var Jo=ai({floorDiv_:Xo});function Yo(e,t){let n=ti(e,"a","div"),r=ti(t,"b","div");if([n,r]=Rs(n,r),"int32"===n.dtype&&"int32"===r.dtype)return Jo(n,r);let a={a:n,b:r},s={};return Vs.runKernel(Vt,a,s)}var Zo=ai({div_:Yo});function Qo(e,t){let n=ti(e,"a","mul"),r=ti(t,"b","mul");[n,r]=Rs(n,r);let a={a:n,b:r};return Vs.runKernel(Vn,a)}var el=ai({mul_:Qo});function tl(e){let t=ti(e,"x","abs");if("complex64"===t.dtype){let e={x:t};return Vs.runKernel(wt,e)}{let e={x:t};return Vs.runKernel(Ke,e)}}var nl=ai({abs_:tl});function rl(e){let t={x:ti(e,"x","acos")};return Vs.runKernel(Xe,t)}var al=ai({acos_:rl});function sl(e){let t={x:ti(e,"x","acosh")};return Vs.runKernel(Je,t)}var il=ai({acosh_:sl});function ol(e){Y(Array.isArray(e),(()=>"The argument passed to tf.addN() must be a list of tensors")),Y(e.length>=1,(()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`));let t=e.map(((e,t)=>ti(e,`tensors${t}`,"addN"))),n=t[0];t.forEach((e=>{if(e.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")})),t.forEach((e=>{if(!ne(e.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}));let r=t;return Vs.runKernel(Ze,r)}var ll=ai({addN_:ol});function ul(e,t=null,n=!1){let r={x:ti(e,"x","all","bool")},a={axis:t,keepDims:n};return Vs.runKernel(Qe,r,a)}var pl=ai({all_:ul});function cl(e,t=null,n=!1){let r={x:ti(e,"x","any","bool")},a={axis:t,keepDims:n};return Vs.runKernel(et,r,a)}var dl=ai({any_:cl});function hl(e,t=0){let n={x:ti(e,"x","argMax")},r={axis:t};return Vs.runKernel(tt,n,r)}var fl=ai({argMax_:hl});function ml(e,t=0){let n={x:ti(e,"x","argMin")},r={axis:t};return Vs.runKernel(nt,n,r)}var gl=ai({argMin_:ml});function yl(e){let t={x:ti(e,"x","asin")};return Vs.runKernel(rt,t)}var bl=ai({asin_:yl});function xl(e){let t={x:ti(e,"x","asinh")};return Vs.runKernel(at,t)}var vl=ai({asinh_:xl});function wl(e){let t={x:ti(e,"x","atan")};return Vs.runKernel(st,t)}var kl=ai({atan_:wl});function Il(e,t){let n=ti(e,"a","atan2"),r=ti(t,"b","atan2");[n,r]=Rs(n,r);let a={a:n,b:r};return Vs.runKernel(ot,a)}var Sl=ai({atan2_:Il});function Nl(e){let t={x:ti(e,"x","atanh")};return Vs.runKernel(it,t)}var Tl=ai({atanh_:Nl});function _l(e,t,n,r,a="NHWC",s){let i=e[3],o=[...t,i],l=Gl(a);return Al(e,o,n,s,r,null,null,l)}function Cl(e,t,n,r,a,s,i="channelsLast"){let o,[l,u]=Ml(t);if("channelsLast"===i)o=[l,u,e[3],e[3]];else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);o=[l,u,e[1],e[1]]}return Al(e,o,n,r,a,s,!1,i)}function El(e,t,n,r,a,s,i="NDHWC"){let o,l,[u,p,c]=Ol(t);if("NDHWC"===i)l="channelsLast",o=[u,p,c,e[4],e[4]];else{if("NCDHW"!==i)throw new Error(`Unknown dataFormat ${i}`);l="channelsFirst",o=[u,p,c,e[1],e[1]]}return $l(e,o,n,r,a,!1,l,s)}function Al(e,t,n,r,a,s,i=!1,o="channelsLast"){let[l,u,p,c]=[-1,-1,-1,-1];if("channelsLast"===o)[l,u,p,c]=e;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,c,u,p]=e}let d,[h,f,,m]=t,[g,y]=Ml(n),[b,x]=Ml(r),v=Pl(h,b),w=Pl(f,x),{padInfo:k,outHeight:I,outWidth:S}=Ll(a,u,p,g,y,v,w,s,o),N=i?m*c:m;return"channelsFirst"===o?d=[l,N,I,S]:"channelsLast"===o&&(d=[l,I,S,N]),{batchSize:l,dataFormat:o,inHeight:u,inWidth:p,inChannels:c,outHeight:I,outWidth:S,outChannels:N,padInfo:k,strideHeight:g,strideWidth:y,filterHeight:h,filterWidth:f,effectiveFilterHeight:v,effectiveFilterWidth:w,dilationHeight:b,dilationWidth:x,inShape:e,outShape:d,filterShape:t}}function $l(e,t,n,r,a,s=!1,i="channelsLast",o){let[l,u,p,c,d]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[l,u,p,c,d]=e;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[l,d,u,p,c]=e}let h,[f,m,g,,y]=t,[b,x,v]=Ol(n),[w,k,I]=Ol(r),S=Pl(f,w),N=Pl(m,k),T=Pl(g,I),{padInfo:_,outDepth:C,outHeight:E,outWidth:A}=zl(a,u,p,c,b,x,v,S,N,T,o),$=s?y*d:y;return"channelsFirst"===i?h=[l,$,C,E,A]:"channelsLast"===i&&(h=[l,C,E,A,$]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:p,inWidth:c,inChannels:d,outDepth:C,outHeight:E,outWidth:A,outChannels:$,padInfo:_,strideDepth:b,strideHeight:x,strideWidth:v,filterDepth:f,filterHeight:m,filterWidth:g,effectiveFilterDepth:S,effectiveFilterHeight:N,effectiveFilterWidth:T,dilationDepth:w,dilationHeight:k,dilationWidth:I,inShape:e,outShape:h,filterShape:t}}function Rl(e,t,n,r,a){null==r&&(r=Dl(e,t,n));let s=e[0],i=e[1],o=Bl((s-t+2*r)/n+1,a),l=Bl((i-t+2*r)/n+1,a);return[o,l]}function Fl(e,t,n,r,a,s){null==a&&(a=Dl(e,t[0],r[0]));let i=[0,0,0,n];for(let o=0;o<3;o++)e[o]+2*a>=t[o]&&(i[o]=Bl((e[o]-t[o]+2*a)/r[o]+1,s));return i}function Dl(e,t,n,r=1){let a=Pl(t,r);return Math.floor((e[0]*(n-1)-n+a)/2)}function Ml(e){return"number"==typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function Ol(e){return"number"==typeof e?[e,e,e]:e}function Pl(e,t){return t<=1?e:e+(e-1)*(t-1)}function Ll(e,t,n,r,a,s,i,o,l){let u,p,c;if("number"==typeof e){u={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};let a=Rl([t,n],s,r,e,o);p=a[0],c=a[1]}else if("same"===e){p=Math.ceil(t/r),c=Math.ceil(n/a);let e=Math.max(0,(p-1)*r+s-t),o=Math.max(0,(c-1)*a+i-n),l=Math.floor(e/2),d=e-l,h=Math.floor(o/2),f=o-h;u={top:l,bottom:d,left:h,right:f,type:"SAME"}}else if("valid"===e)u={top:0,bottom:0,left:0,right:0,type:"VALID"},p=Math.ceil((t-s+1)/r),c=Math.ceil((n-i+1)/a);else{if("object"!=typeof e)throw Error(`Unknown padding parameter: ${e}`);{let d="channelsLast"===l?e[1][0]:e[2][0],h="channelsLast"===l?e[1][1]:e[2][1],f="channelsLast"===l?e[2][0]:e[3][0],m="channelsLast"===l?e[2][1]:e[3][1];u={top:d,bottom:h,left:f,right:m,type:0===d&&0===h&&0===f&&0===m?"VALID":"EXPLICIT"},p=Bl((t-s+d+h)/r+1,o),c=Bl((n-i+f+m)/a+1,o)}}return{padInfo:u,outHeight:p,outWidth:c}}function zl(e,t,n,r,a,s,i,o,l,u,p){let c,d,h,f;if("valid"===e&&(e=0),"number"==typeof e){c={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};let m=Fl([t,n,r,1],[o,l,u],1,[a,s,i],e,p);d=m[0],h=m[1],f=m[2]}else{if("same"!==e)throw Error(`Unknown padding parameter: ${e}`);{d=Math.ceil(t/a),h=Math.ceil(n/s),f=Math.ceil(r/i);let e=(d-1)*a+o-t,p=(h-1)*s+l-n,m=(f-1)*i+u-r,g=Math.floor(e/2),y=e-g,b=Math.floor(p/2),x=p-b,v=Math.floor(m/2),w=m-v;c={top:b,bottom:x,left:v,right:w,front:g,back:y,type:"SAME"}}}return{padInfo:c,outDepth:d,outHeight:h,outWidth:f}}function Bl(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function Wl(e){let[t,n,r]=Ml(e);return 1===t&&1===n&&1===r}function Ul(e,t){return Wl(e)||Wl(t)}function Vl(e){return Ml(e).every((e=>e>0))}function Gl(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function Hl(e,t,n){if(null!=n){if("string"==typeof t)throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if("number"==typeof t)Y(re(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`));else{if("object"!=typeof t)throw Error(`Error in ${e}: Unknown padding parameter: ${t}`);t.forEach((t=>{t.forEach((t=>{Y(re(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`))}))}))}}}function jl(e,t){let n={x:ti(e,"x","reshape","string_or_numeric")},r={shape:t};return Vs.runKernel(pr,n,r)}var ql=ai({reshape_:jl});function Kl(e,t,n,r,a){let s=ti(e,"x","avgPool","float32"),i=1;Y(Ul(n,i),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`));let o=s,l=!1;3===s.rank&&(l=!0,o=ql(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Y(4===o.rank,(()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`)),Hl("avgPool",r,a);let u={x:o},p={filterSize:t,strides:n,pad:r,dimRoundingMode:a},c=Vs.runKernel(lt,u,p);return c=wo(c,s.dtype),l?ql(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var Xl=ai({avgPool_:Kl});function Jl(e,t,n,r,a,s="NDHWC"){let i=ti(e,"x","avgPool3d","float32"),o=i,l=!1;4===i.rank&&(l=!0,o=ql(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Y(5===o.rank,(()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`)),Y("NDHWC"===s,(()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`)),Y("number"==typeof n&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,(()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`)),Hl("avgPool3d",r,a);let u={x:o},p={filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:s},c=Vs.runKernel(pt,u,p);return c=wo(c,o.dtype),l?ql(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}var Yl=ai({avgPool3d_:Jl});function Zl(e,t=0){Y(e.length>=1,(()=>"Pass at least one tensor to concat"));let n=ni(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)})),1===n.length)return Io(n[0]);let r=n,a={axis:t};return Vs.runKernel(kt,r,a)}var Ql=ai({concat_:Zl});function eu(e,t,n=!1,r=!1){let a=ti(e,"a","matMul"),s=ti(t,"b","matMul");[a,s]=Rs(a,s);let i={a:a,b:s},o={transposeA:n,transposeB:r};return Vs.runKernel(dt,i,o)}var tu=ai({matMul_:eu});function nu(e){let t={x:ti(e,"x","sigmoid","float32")};return Vs.runKernel(Cr,t)}var ru=ai({sigmoid_:nu});function au(e,t,n){let r=ti(e,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");let a={x:r},s={begin:t,size:n};return Vs.runKernel(Sr,a,s)}var su=ai({slice_:au});function iu(e){let t={x:ti(e,"x","tanh","float32")};return Vs.runKernel(Xr,t)}var ou=ai({tanh_:iu});function lu(e,t,n,r,a,s){let i=ti(e,"forgetBias","basicLSTMCell"),o=ti(t,"lstmKernel","basicLSTMCell"),l=ti(n,"lstmBias","basicLSTMCell"),u=ti(r,"data","basicLSTMCell"),p=ti(a,"c","basicLSTMCell"),c=ti(s,"h","basicLSTMCell"),d=Ql([u,c],1),h=tu(d,o),f=Ko(h,l),m=f.shape[0],g=f.shape[1]/4,y=[m,g],b=su(f,[0,0],y),x=su(f,[0,g],y),v=su(f,[0,2*g],y),w=su(f,[0,3*g],y),k=Ko(el(ru(b),ou(x)),el(p,ru(Ko(i,v)))),I=el(ou(k),ru(w));return[k,I]}var uu=ai({basicLSTMCell_:lu});function pu(e,t,n){let r=ti(e,"x","batchToSpaceND"),a=t.reduce(((e,t)=>e*t));Y(r.rank>=1+t.length,(()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`)),Y(n.length===t.length,(()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`)),Y(r.shape[0]%a===0,(()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${a}`));let s={x:r},i={blockShape:t,crops:n};return Vs.runKernel(ht,s,i)}var cu=ai({batchToSpaceND_:pu});function du(e){let t;return t=0===e.rank||1===e.rank?ql(e,[1,1,1,e.size]):2===e.rank?ql(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?ql(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}function hu(e,t,n,r,a,s){null==s&&(s=.001);let i,o,l=ti(e,"x","batchNorm"),u=ti(t,"mean","batchNorm"),p=ti(n,"variance","batchNorm");null!=a&&(i=ti(a,"scale","batchNorm")),null!=r&&(o=ti(r,"offset","batchNorm")),Y(u.rank===p.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Y(null==o||u.rank===o.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Y(null==i||u.rank===i.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let c={x:du(l),scale:i,offset:o,mean:u,variance:p},d={varianceEpsilon:s},h=Vs.runKernel(rn,c,d);return ql(h,l.shape)}var fu=ai({batchNorm_:hu});function mu(e,t,n,r,a,s){let i,o,l=ti(e,"x","batchNorm"),u=ti(t,"mean","batchNorm"),p=ti(n,"variance","batchNorm");return null!=a&&(i=ti(a,"scale","batchNorm")),null!=r&&(o=ti(r,"offset","batchNorm")),Y(2===l.rank,(()=>`Error in batchNorm2D: x must be rank 2 but got rank ${l.rank}.`)),Y(2===u.rank||1===u.rank,(()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${u.rank}.`)),Y(2===p.rank||1===p.rank,(()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${p.rank}.`)),null!=i&&Y(2===i.rank||1===i.rank,(()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${i.rank}.`)),null!=o&&Y(2===o.rank||1===o.rank,(()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${o.rank}.`)),fu(l,u,p,o,i,s)}var gu=ai({batchNorm2d_:mu});function yu(e,t,n,r,a,s){let i,o,l=ti(e,"x","batchNorm"),u=ti(t,"mean","batchNorm"),p=ti(n,"variance","batchNorm");return null!=a&&(i=ti(a,"scale","batchNorm")),null!=r&&(o=ti(r,"offset","batchNorm")),Y(3===l.rank,(()=>`Error in batchNorm3D: x must be rank 3 but got rank ${l.rank}.`)),Y(3===u.rank||1===u.rank,(()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${u.rank}.`)),Y(3===p.rank||1===p.rank,(()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${p.rank}.`)),null!=i&&Y(3===i.rank||1===i.rank,(()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${i.rank}.`)),null!=o&&Y(3===o.rank||1===o.rank,(()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${o.rank}.`)),fu(l,u,p,o,i,s)}var bu=ai({batchNorm3d_:yu});function xu(e,t,n,r,a,s){let i,o,l=ti(e,"x","batchNorm"),u=ti(t,"mean","batchNorm"),p=ti(n,"variance","batchNorm");return null!=a&&(i=ti(a,"scale","batchNorm")),null!=r&&(o=ti(r,"offset","batchNorm")),Y(4===l.rank,(()=>`Error in batchNorm4D: x must be rank 4 but got rank ${l.rank}.`)),Y(4===u.rank||1===u.rank,(()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${u.rank}.`)),Y(4===p.rank||1===p.rank,(()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${p.rank}.`)),null!=i&&Y(4===i.rank||1===i.rank,(()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${i.rank}.`)),null!=o&&Y(4===o.rank||1===o.rank,(()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${o.rank}.`)),fu(l,u,p,o,i,s)}var vu=ai({batchNorm4d_:xu});function wu(e,t,n){let r=ti(e,"x","bincount"),a=ti(t,"weights","bincount");Y("int32"===r.dtype,(()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`)),Y(n>=0,(()=>`size must be non-negative, but got ${n}.`)),Y(a.size===r.size||0===a.size,(()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${a.shape}.`));let s={x:r,weights:a},i={size:n};return Vs.runKernel(ft,s,i)}var ku=ai({bincount_:wu});function Iu(e,t){let n=ti(e,"s0","broadcastArgs","int32"),r=ti(t,"s1","broadcastArgs","int32");if(1!==n.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(1!==r.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);let a={s0:n,s1:r};return Vs.runKernel(gt,a)}var Su=ai({broadcastArgs_:Iu});function Nu(e,t){let n=ti(e,"broadcastTo","x"),r=n.shape;if(Re(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){let e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=ql(n,e)}let a=n.shape,s=Array.from(t);for(let l=t.length-1;l>=0;l--)if(a[l]===t[l])s[l]=1;else if(1!==n.shape[l])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(0===s.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0)).length)return Io(n);let i={x:n},o={reps:s};return Vs.runKernel(Jr,i,o)}var Tu=ai({broadcastTo_:Nu});function _u(e){let t={x:ti(e,"x","ceil","float32")};return Vs.runKernel(bt,t)}var Cu=ai({ceil_:_u});function Eu(e,t,n){Re(e),n=n||ke(t);let r={shape:e,value:t,dtype:n};return Vs.runKernel(Qt,{},r)}function Au(e,t,n){let r=ti(e,"x","clipByValue");if(Y(t<=n,(()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`)),t===n)return Eu(r.shape,t,r.dtype);let a={x:r},s={clipValueMin:t,clipValueMax:n};return Vs.runKernel(xt,a,s)}var $u=ai({clipByValue_:Au});function Ru(e){return Ql(e,0)}var Fu=ai({concat1d_:Ru});function Du(e,t){return Ql(e,t)}var Mu=ai({concat2d_:Du});function Ou(e,t){return Ql(e,t)}var Pu=ai({concat3d_:Ou});function Lu(e,t){return Ql(e,t)}var zu=ai({concat4d_:Lu});function Bu(e,t,n,r,a="NHWC",s=[1,1],i){let o=ti(e,"x","conv2d","float32"),l=ti(t,"filter","conv2d","float32"),u=o,p=!1;3===o.rank&&(p=!0,u=ql(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Y(4===u.rank,(()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`)),Y(4===l.rank,(()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`)),Hl("conv2d",r,i);let c="NHWC"===a?u.shape[3]:u.shape[1];Y(c===l.shape[2],(()=>`Error in conv2d: depth of input (${c}) must match input depth for filter ${l.shape[2]}.`)),Y(Ul(n,s),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`)),Y(Vl(s),(()=>"Error in conv2D: Dilated rates should be larger than 0.")),Y(Vl(n),(()=>"Error in conv2D: Strides should be larger than 0."));let d={x:u,filter:l},h={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i},f=Vs.runKernel(It,d,h);return p?ql(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var Wu=ai({conv2d_:Bu});function Uu(e,t,n,r,a="NWC",s=1,i){let o=ti(e,"x","conv1d"),l=ti(t,"filter","conv1d"),u=o,p=!1;2===o.rank&&(p=!0,u=ql(o,[1,o.shape[0],o.shape[1]])),Y(3===u.rank,(()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`)),Y(3===l.rank,(()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`)),Hl("conv1d",r,i),Y(u.shape[2]===l.shape[1],(()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`)),Y(Ul(n,s),(()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${s}'`)),Y(Vl(s),(()=>"Error in conv1D: Dilated rates should be larger than 0.")),Y(Vl(n),(()=>"Error in conv1D: Stride should be larger than 0.")),Y("NWC"===a,(()=>`Error in conv1d: got dataFormat of ${a} but only NWC is currently supported.`));let c=ql(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=ql(u,[u.shape[0],1,u.shape[1],u.shape[2]]),h=Wu(d,c,[1,n],r,"NHWC",[1,s],i);return ql(h,p?[h.shape[2],h.shape[3]]:[h.shape[0],h.shape[2],h.shape[3]])}var Vu=ai({conv1d_:Uu});function Gu(e,t,n,r,a,s="NHWC",i){Y(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let o=e,l=t,u=!1;3===t.rank&&(u=!0,l=ql(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),Y(4===o.length,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`)),Y(4===l.rank,(()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`)),Y(4===n.rank,(()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`));let p="NHWC"===s?o[3]:o[1],c="NHWC"===s?l.shape[3]:l.shape[1];Y(p===n.shape[2],(()=>`Error in conv2dDerInput: depth of input (${p}) must match input depth for filter ${n.shape[2]}.`)),Y(c===n.shape[3],(()=>`Error in conv2dDerInput: depth of output (${c}) must match output depth for filter ${n.shape[3]}.`)),Hl("conv2dDerInput",a,i);let d={dy:l,filter:n},h={strides:r,pad:a,dataFormat:s,dimRoundingMode:i,inputShape:o},f=Vs.runKernel(Nt,d,h);return u?ql(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var Hu=ai({conv2DBackpropInput_:Gu});function ju(e,t,n,r,a,s){let i=ti(e,"x","conv2dTranspose"),o=ti(t,"filter","conv2dTranspose");return Hu(n,i,o,r,a,"NHWC",s)}var qu=ai({conv2dTranspose_:ju});function Ku(e,t,n,r,a="NDHWC",s=[1,1,1]){let i=ti(e,"x","conv3d"),o=ti(t,"filter","conv3d"),l=i,u=!1;4===i.rank&&(u=!0,l=ql(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Y(5===l.rank,(()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`)),Y(5===o.rank,(()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`)),Y(l.shape[4]===o.shape[3],(()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`)),Y(Ul(n,s),(()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`)),Y("NDHWC"===a,(()=>`Error in conv3d: got dataFormat of ${a} but only NDHWC is currently supported.`)),Y(Vl(s),(()=>"Error in conv3D: Dilated rates should be larger than 0.")),Y(Vl(n),(()=>"Error in conv3D: Strides should be larger than 0."));let p={x:l,filter:o},c={strides:n,pad:r,dataFormat:a,dilations:s},d=Vs.runKernel(Tt,p,c);return u?ql(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var Xu=ai({conv3d_:Ku});function Ju(e,t,n,r,a){Y(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let s=e,i=t,o=!1;4===t.rank&&(o=!0,i=ql(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),s=[1,e[0],e[1],e[2],e[3]]);let l=s[4],u=i.shape[4];Y(5===s.length,(()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`)),Y(5===i.rank,(()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`)),Y(5===n.rank,(()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`)),Y(l===n.shape[3],(()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`)),Y(u===n.shape[4],(()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`));let p={dy:i,filter:n},c={pad:a,strides:r,inputShape:s},d=Vs.runKernel(Ct,p,c);return o?ql(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var Yu=ai({conv3DBackpropInput_:Ju});function Zu(e,t,n,r,a){let s=ti(e,"x","conv3dTranspose"),i=ti(t,"filter","conv3dTranspose");return Yu(n,s,i,r,a)}var Qu=ai({conv3dTranspose_:Zu});function ep(e){let t={x:ti(e,"x","cos","float32")};return Vs.runKernel(Et,t)}var tp=ai({cos_:ep});function np(e){let t={x:ti(e,"x","cosh","float32")};return Vs.runKernel(At,t)}var rp=ai({cosh_:np});function ap(e,t=0,n=!1,r=!1){let a={x:ti(e,"x","cumprod")},s={axis:t,exclusive:n,reverse:r};return Vs.runKernel($t,a,s)}var sp=ai({cumprod_:ap});function ip(e,t=0,n=!1,r=!1){let a={x:ti(e,"x","cumsum")},s={axis:t,exclusive:n,reverse:r};return Vs.runKernel(Rt,a,s)}var op=ai({cumsum_:ip});function lp(e,t,n,r=!1){let a=ti(e,"x","denseBincount"),s=ti(t,"weights","denseBincount");Y("int32"===a.dtype,(()=>`Error in denseBincount: input dtype must be int32, but got ${a.dtype}`)),Y(a.rank<=2,(()=>`Error in denseBincount: input must be at most rank 2, but got rank ${a.rank}.`)),Y(n>=0,(()=>`size must be non-negative, but got ${n}.`)),Y(s.size===a.size||0===s.size,(()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${a.shape}, weights shape: ${s.shape}.`));let i={x:a,weights:s},o={size:n,binaryOutput:r};return Vs.runKernel(Dt,i,o)}var up=ai({denseBincount_:lp});function pp(e,t,n="NHWC"){let r=ti(e,"x","depthToSpace","float32"),a="NHWC"===n?r.shape[1]:r.shape[2],s="NHWC"===n?r.shape[2]:r.shape[3],i="NHWC"===n?r.shape[3]:r.shape[1];Y(t>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`)),Y(a*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${a} and ${t}  for depthToSpace with input shape\n    ${r.shape}`)),Y(s*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${t} for depthToSpace with input shape\n        ${r.shape}`)),Y(i%(t*t)===0,(()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${r.shape}`));let o={x:r},l={blockSize:t,dataFormat:n};return Vs.runKernel(Mt,o,l)}var cp=ai({depthToSpace_:pp});function dp(e,t,n,r,a="NHWC",s=[1,1],i){let o=ti(e,"x","depthwiseConv2d","float32"),l=ti(t,"filter","depthwiseConv2d","float32"),u=o,p=!1;3===o.rank&&(p=!0,u=ql(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Y(4===u.rank,(()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`)),Y(4===l.rank,(()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`));let c="NHWC"===a?u.shape[3]:u.shape[1];Y(c===l.shape[2],(()=>`Error in depthwiseConv2d: number of input channels (${c}) must match the inChannels dimension in filter ${l.shape[2]}.`)),Hl("depthwiseConv2d",r,i);let d={x:u,filter:l},h={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i},f=Vs.runKernel(Ot,d,h);return p?ql(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var hp=ai({depthwiseConv2d_:dp});function fp(e){let t={x:ti(e,"x","diag")};return Vs.runKernel(zt,t)}var mp=ai({diag_:fp});function gp(e,t,n,r,a=[1,1],s="NHWC"){let i=ti(e,"x","dilation2d"),o=ti(t,"filter","dilation2d");Y(3===i.rank||4===i.rank,(()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`)),Y(3===o.rank,(()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`)),Y("NHWC"===s,(()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`));let l=i,u=!1;3===i.rank&&(l=ql(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0),Y(l.shape[3]===o.shape[2],(()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`));let p={x:l,filter:o},c={strides:n,pad:r,dilations:a},d=Vs.runKernel(Bt,p,c);return u?ql(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var yp=ai({dilation2d_:gp}),bp={};function xp(e,t){let n=e.length,r=[];for(let a=0;a<n;a++){let s=n-1-a,i=e[s]||1;(t[t.length-1-a]||1)>1&&1===i&&r.unshift(s)}return r}function vp(e,t){let n=[];for(let r=0;r<t.length;r++){let a=e[e.length-r-1],s=t.length-r-1,i=t[s];(null==a||1===a&&i>1)&&n.unshift(s)}return n}function wp(e,t){let n=Math.max(e.length,t.length),r=new Array(n);for(let a=0;a<n;a++){let s=e[e.length-a-1];null==s&&(s=1);let i=t[t.length-a-1];if(null==i&&(i=1),1===s)r[n-a-1]=i;else if(1===i)r[n-a-1]=s;else{if(s!==i){let n=`Operands could not be broadcast together with shapes ${e} and ${t}.`;throw Error(n)}r[n-a-1]=s}}return r}function kp(e,t){let n=ti(e,"a","equal","string_or_numeric"),r=ti(t,"b","equal","string_or_numeric");[n,r]=Rs(n,r),wp(n.shape,r.shape);let a={a:n,b:r};return Vs.runKernel(Kt,a)}g(bp,{assertAndGetBroadcastShape:()=>wp,getBroadcastDims:()=>xp,getReductionAxes:()=>vp});var Ip=ai({equal_:kp});function Sp(e,t,n){let r=ti(t,"a","where"),a=ti(n,"b","where"),s=ti(e,"condition","where","bool"),i=wp(wp(s.shape,r.shape),a.shape),o=Tu(s,i),l=Tu(r,i),u=Tu(a,i),p={condition:o,t:l,e:u};return Vs.runKernel(kr,p)}var Np=ai({where_:Sp});function Tp(e){let t={x:ti(e,"x","zerosLike")};return Vs.runKernel(aa,t)}var _p=ai({zerosLike_:Tp});function Cp(e,t){let n=ti(e,"a","div"),r=ti(t,"b","div");[n,r]=Rs(n,r);let a=Zo(n,r),s=_p(a),i=Ip(r,s);return Np(i,s,a)}var Ep=ai({divNoNan_:Cp});function Ap(e,t){let n=ti(e,"t1","dot"),r=ti(t,"t2","dot");Y((1===n.rank||2===n.rank)&&(1===r.rank||2===r.rank),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`));let a=1===n.rank?n.size:n.shape[1],s=1===r.rank?r.size:r.shape[0];if(Y(a===s,(()=>`Error in dot: inner dimensions of inputs must match, but got ${a} and ${s}.`)),1===n.rank&&1===r.rank){let e=ql(n,[1,-1]),t=ql(r,[-1,1]),a=tu(e,t);return ql(a,[])}if(1===n.rank&&2===r.rank){let e=ql(n,[1,-1]),t=ql(r,[r.shape[0],r.shape[1]]),a=tu(e,t);return ql(a,[a.size])}if(2===n.rank&&1===r.rank){let e=ql(r,[-1,1]),t=tu(n,e);return ql(t,[t.size])}{let e=ql(r,[r.shape[0],r.shape[1]]);return tu(n,e)}}var $p=ai({dot_:Ap});function Rp(e,...t){let n=t.map(((e,t)=>ti(e,`tensors${t}`,"einsum"))),r={equation:e};return Vs.runKernel(Gt,n,r)}var Fp=ai({einsum_:Rp});function Dp(e){let t={x:ti(e,"x","elu","float32")};return Vs.runKernel(Ht,t)}var Mp=ai({elu_:Dp});function Op(e){let t=ti(e,"x","erf");Y("int32"===t.dtype||"float32"===t.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===t.dtype&&(t=wo(t,"float32"));let n={x:t};return Vs.runKernel(qt,n)}var Pp=ai({erf_:Op});function Lp(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function zp(e,t,n){let r=e.length+t.length,a=[],s=0,i=0;for(let o=0;o<r;o++)-1===n.indexOf(o)?a.push(e[s++]):a.push(t[i++]);return a}function Bp(e,t){let n=[],r=e.length;for(let s=0;s<r;s++)-1===t.indexOf(s)&&n.push(e[s]);let a=t.map((t=>e[t]));return[n,a]}function Wp(e,t){let n=t.map((e=>1));return zp(e,n,t)}function Up(e,t,n){Y(Lp(t,n),(()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`))}function Vp(e,t){if(Lp(e,t))return null;let n=[];for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);return e.forEach((e=>n.push(e))),n}function Gp(e){return e.map(((e,t)=>[t,e])).sort(((e,t)=>e[1]-t[1])).map((e=>e[0]))}function Hp(e,t){let n=[];for(let r=t-e;r<t;++r)n.push(r);return n}function jp(e,t=null,n=!1){let r={x:ti(e,"x","max")},a={reductionIndices:t,keepDims:n};return Vs.runKernel(An,r,a)}var qp=ai({max_:jp});function Kp(e,t=null,n=!1){let r={x:ti(e,"x","min")},a={axis:t,keepDims:n};return Vs.runKernel(Ln,r,a)}var Xp=ai({min_:Kp});function Jp(e,t){let n=ti(e,"base","pow"),r=ti(t,"exp","pow");[n,r]=Rs(n,r);let a={a:n,b:r};return Vs.runKernel(er,a)}var Yp=ai({pow_:Jp});function Zp(e,t){if((Ja(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&Ja(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return oi(e,[],[],t)}function Qp(e){let t={x:ti(e,"x","sqrt","float32")};return Vs.runKernel(Ar,t)}var ec=ai({sqrt_:Qp});function tc(e){let t=ti(e,"x","square"),n={};return Vs.runKernel("Square",{x:t},n)}var nc=ai({square_:tc});function rc(e,t=null,n=!1){let r=ti(e,"x","sum");"bool"===r.dtype&&(r=wo(r,"int32"));let a={x:r},s={axis:t,keepDims:n};return Vs.runKernel($r,a,s)}var ac=ai({sum_:rc});function sc(e,t="euclidean",n=null,r=!1){e=ti(e,"x","norm");let a=ic(e,t,n),s=a.shape;if(r){let t=pe(n,e.shape);s=Wp(a.shape,t)}return ql(a,s)}function ic(e,t,n=null){if(0===e.rank)return nl(e);if(1!==e.rank&&null===n)return ic(ql(e,[-1]),t,n);if(1===e.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===t)return ac(nl(e),n);if(t===1/0)return qp(nl(e),n);if(t===-1/0)return Xp(nl(e),n);if("euclidean"===t||2===t)return ec(ac(Yp(nl(e),Zp(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&2===n.length){if(1===t)return qp(ac(nl(e),n[0]),n[1]-1);if(t===1/0)return qp(ac(nl(e),n[1]),n[0]);if(t===-1/0)return Xp(ac(nl(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return ec(ac(nc(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}var oc=ai({norm_:sc});function lc(e,t=null,n=!1){return oc(e,"euclidean",t,n)}var uc=ai({euclideanNorm_:lc});function pc(e){let t={x:ti(e,"x","exp")};return Vs.runKernel(Xt,t)}var cc=ai({exp_:pc});function dc(e,t=0){let n=ti(e,"x","expandDims","string_or_numeric");Y(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));let r={input:n},a={dim:t};return Vs.runKernel(Jt,r,a)}var hc=ai({expandDims_:dc});function fc(e){let t={x:ti(e,"x","expm1")};return Vs.runKernel(Yt,t)}var mc=ai({expm1_:fc});function gc(e,t){let n=ti(e,"x","tile","string_or_numeric");Y(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`));let r={x:n},a={reps:t};return Vs.runKernel(Jr,r,a)}var yc=ai({tile_:gc});function bc(e,t,n,r="float32"){null==t&&(t=e);let a=xo([e,t],r),s=e<=t?e:t;for(let o=0;o<s;++o)a.set(1,o,o);let i=ql(a.toTensor(),[e,t]);if(null==n)return i;if(1===n.length)return yc(hc(i,0),[n[0],1,1]);if(2===n.length)return yc(hc(hc(i,0),0),[n[0],n[1],1,1]);if(3===n.length)return yc(hc(hc(hc(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}var xc=ai({eye_:bc});function vc(e){let t={x:ti(e,"x","floor","float32")};return Vs.runKernel(tn,t)}var wc=ai({floor_:vc});function kc(e,t,n=0,r=0){let a=ti(e,"x","gather"),s=ti(t,"indices","gather","int32"),i={x:a,indices:s},o={axis:n,batchDims:r};return Vs.runKernel(an,i,o)}var Ic=ai({gather_:kc});function Sc(e,t){let n=ti(e,"a","greater","string_or_numeric"),r=ti(t,"b","greater","string_or_numeric");[n,r]=Rs(n,r),wp(n.shape,r.shape);let a={a:n,b:r};return Vs.runKernel(on,a)}var Nc=ai({greater_:Sc});function Tc(e,t){let n=ti(e,"a","greaterEqual","string_or_numeric"),r=ti(t,"b","greaterEqual","string_or_numeric");[n,r]=Rs(n,r),wp(n.shape,r.shape);let a={a:n,b:r};return Vs.runKernel(ln,a)}var _c=ai({greaterEqual_:Tc});function Cc(e){let t={input:ti(e,"input","imag")};return Vs.runKernel(cn,t)}var Ec=ai({imag_:Cc});function Ac(e){let t={x:ti(e,"x","isFinite")};return Vs.runKernel(dn,t)}var $c=ai({isFinite_:Ac});function Rc(e){let t={x:ti(e,"x","isInf")};return Vs.runKernel(hn,t)}var Fc=ai({isInf_:Rc});function Dc(e){let t={x:ti(e,"x","isNaN")};return Vs.runKernel(fn,t)}var Mc=ai({isNaN_:Dc});function Oc(e,t=.2){let n={x:ti(e,"x","leakyRelu")},r={alpha:t};return Vs.runKernel(mn,n,r)}var Pc=ai({leakyRelu_:Oc});function Lc(e,t){let n=ti(e,"a","less","string_or_numeric"),r=ti(t,"b","less","string_or_numeric");[n,r]=Rs(n,r),wp(n.shape,r.shape);let a={a:n,b:r};return Vs.runKernel(gn,a)}var zc=ai({less_:Lc});function Bc(e,t){let n=ti(e,"a","lessEqual","string_or_numeric"),r=ti(t,"b","lessEqual","string_or_numeric");[n,r]=Rs(n,r),wp(n.shape,r.shape);let a={a:n,b:r};return Vs.runKernel(yn,a)}var Wc=ai({lessEqual_:Bc});function Uc(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");let r={start:e,stop:t,num:n};return Vs.runKernel(bn,{},r)}function Vc(e,t=5,n=1,r=1,a=.5){let s=ti(e,"x","localResponseNormalization");Y(4===s.rank||3===s.rank,(()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${s.rank}.`)),Y(re(t),(()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`));let i=s,o=!1;3===s.rank&&(o=!0,i=ql(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let l={x:i},u={depthRadius:t,bias:n,alpha:r,beta:a},p=Vs.runKernel(_n,l,u);return o?ql(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var Gc=ai({localResponseNormalization_:Vc});function Hc(e){let t={x:ti(e,"x","log","float32")};return Vs.runKernel(xn,t)}var jc=ai({log_:Hc});function qc(e){let t={x:ti(e,"x","log1p")};return Vs.runKernel(vn,t)}var Kc=ai({log1p_:qc});function Xc(e){return Y(Ie(e),(()=>"The f passed in grad(f) must be a function")),(t,n)=>{let r=ti(t,"x","tf.grad","string_or_numeric"),a=null!=n?ti(n,"dy","tf.grad"):null;return Vs.tidy((()=>{let{value:t,grads:n}=Vs.gradients((()=>e(r)),[r],a);return null!=a&&Z(t.shape,a.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),td(n),n[0]}))}}function Jc(e){return Y(Ie(e),(()=>"The f passed in grads(f) must be a function")),(t,n)=>{Y(Array.isArray(t),(()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s"));let r=ni(t,"args","tf.grads","string_or_numeric"),a=null!=n?ti(n,"dy","tf.grads"):null;return Vs.tidy((()=>{let{value:t,grads:n}=Vs.gradients((()=>e(...r)),r,a);return null!=a&&Z(t.shape,a.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),td(n),n}))}}function Yc(e){return Y(Ie(e),(()=>"The f passed in valueAndGrad(f) must be a function")),(t,n)=>{Y(t instanceof bs,(()=>"The x passed in valueAndGrad(f)(x) must be a tensor")),Y(null==n||n instanceof bs,(()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor"));let{grads:r,value:a}=Vs.gradients((()=>e(t)),[t],n);return td(r),{grad:r[0],value:a}}}function Zc(e){return Y(Ie(e),(()=>"The f passed in valueAndGrads(f) must be a function")),(t,n)=>{Y(Array.isArray(t)&&t.every((e=>e instanceof bs)),(()=>"The args passed in valueAndGrads(f)(args) must be array of tensors")),Y(null==n||n instanceof bs,(()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor"));let r=Vs.gradients((()=>e(...t)),t,n);return null!=n&&Z(r.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),td(r.grads),r}}function Qc(e,t){Y(Ie(e),(()=>"The f passed in variableGrads(f) must be a function")),Y(null==t||Array.isArray(t)&&t.every((e=>e instanceof vs)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));let n=null!=t;if(!n){t=[];for(let e in Vs.registeredVariables)t.push(Vs.registeredVariables[e])}let r=n?t.filter((e=>!e.trainable)):null,a=t.length;t=t.filter((e=>e.trainable)),Y(t.length>0,(()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${a} variables is trainable.`));let s=!0,{value:i,grads:o}=Vs.gradients(e,t,null,s);Y(o.some((e=>null!=e)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),Y(0===i.rank,(()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`));let l={};return t.forEach(((e,t)=>{null!=o[t]&&(l[e.name]=o[t])})),null!=r&&r.forEach((e=>l[e.name]=null)),{value:i,grads:l}}function ed(e){return Vs.customGrad(e)}function td(e){if(e.filter((e=>null==e)).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}function nd(e){let t={x:ti(e,"x","neg")};return Vs.runKernel(Gn,t)}var rd=ai({neg_:nd});function ad(e){let t={x:ti(e,"x","softplus")};return Vs.runKernel(Er,t)}var sd=ai({softplus_:ad});function id(e){let t=ti(e,"x","logSigmoid");return ed((e=>({value:rd(sd(rd(e))),gradFunc:t=>el(t,ru(rd(e)))})))(t)}var od=ai({logSigmoid_:id});function ld(e,t){let n=ti(e,"a","sub"),r=ti(t,"b","sub");[n,r]=Rs(n,r);let a={a:n,b:r};return Vs.runKernel(qr,a)}var ud=ai({sub_:ld});function pd(e,t=-1){let n=ti(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return ed(((e,n)=>{let r=qp(e,t,!0),a=ud(e,r),s=ud(wo(a,"float32"),jc(ac(cc(a),t,!0)));return n([s]),{value:s,gradFunc:(e,n)=>{let[r]=n,a=!0,s=cc(r);return ud(e,el(ac(e,t,a),s))}}}))(n)}var cd=ai({logSoftmax_:pd});function dd(e,t=null,n=!1){let r=ti(e,"x","logSumExp"),a=pe(t,r.shape),s=qp(r,a,!0),i=ud(r,s),o=cc(i),l=ac(o,a),u=jc(l),p=Ko(ql(s,u.shape),u);if(n){let e=Wp(p.shape,a);return ql(p,e)}return p}var hd=ai({logSumExp_:dd});function fd(e,t){let n=ti(e,"a","logicalAnd","bool"),r=ti(t,"b","logicalAnd","bool");wp(n.shape,r.shape);let a={a:n,b:r};return Vs.runKernel(wn,a)}var md=ai({logicalAnd_:fd});function gd(e){let t={x:ti(e,"x","logicalNot","bool")};return Vs.runKernel(kn,t)}var yd=ai({logicalNot_:gd});function bd(e,t){let n=ti(e,"a","logicalOr","bool"),r=ti(t,"b","logicalOr","bool");wp(n.shape,r.shape);let a={a:n,b:r};return Vs.runKernel(In,a)}var xd=ai({logicalOr_:bd});function vd(e,t){let n=ti(e,"a","logicalXor","bool"),r=ti(t,"b","logicalXor","bool");return wp(n.shape,r.shape),md(xd(e,t),yd(md(e,t)))}var wd=ai({logicalXor_:vd}),kd=2147483648;function Id(e,t,n="left"){let r=ti(e,"sortedSequence","searchSorted"),a=ti(t,"values","searchSorted"),s=r.shape[r.shape.length-1],i=a.shape[a.shape.length-1],o=ql(r,[-1,s]),l=ql(a,[-1,i]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(ee(l.shape)>=kd)throw new Error(`values tensor size must less than ${kd}`);if(o.shape[1]>=kd)throw new Error(`trailing dim_size must less than ${kd} for int32 output type, was ${o.shape[1]}`);let u={sortedSequence:o,values:l},p={side:n};return Vs.runKernel(wr,u,p)}var Sd=ai({searchSorted_:Id});function Nd(e,t){return Sd(e,t,"left")}function Td(e,t,n,r,a){let s=ti(e,"x","maxPool"),i=1,o=s,l=!1;3===s.rank&&(l=!0,o=ql(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Y(4===o.rank,(()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`)),Y(Ul(n,i),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`)),Hl("maxPool",r,a);let u={x:o},p={filterSize:t,strides:n,pad:r,dimRoundingMode:a},c=Vs.runKernel(Rn,u,p);return l?ql(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var _d=ai({maxPool_:Td});function Cd(e,t=[1,1,1],n,r,a,s="NDHWC"){let i=ti(e,"x","maxPool3d"),o=i,l=!1;4===i.rank&&(l=!0,o=ql(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Y(5===o.rank,(()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`)),Y("NDHWC"===s,(()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`)),Hl("maxPool3d",r,a);let u={x:o},p={filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:s},c=Vs.runKernel(Dn,u,p);return l?ql(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}var Ed=ai({maxPool3d_:Cd});function Ad(e,t,n,r,a=!1){let s={x:ti(e,"x","maxPoolWithArgmax")},i={filterSize:t,strides:n,pad:r,includeBatchInIndex:a},o=Vs.runKernel(On,s,i);return{result:o[0],indexes:o[1]}}var $d=ai({maxPoolWithArgmax_:Ad});function Rd(e,t){let n=ti(e,"a","maximum"),r=ti(t,"b","maximum");[n,r]=Rs(n,r),"bool"===n.dtype&&(n=wo(n,"int32"),r=wo(r,"int32")),wp(n.shape,r.shape);let a={a:n,b:r};return Vs.runKernel($n,a)}var Fd=ai({maximum_:Rd});function Dd(e,t=null,n=!1){let r={x:ti(e,"x","mean")},a={axis:t,keepDims:n};return Vs.runKernel(Pn,r,a)}var Md=ai({mean_:Dd});function Od(e,t="float32"){if(Re(e),"complex64"===t){let t=Od(e,"float32"),n=Od(e,"float32");return ii(t,n)}let n=Ae(ee(e),t);return Vs.makeTensor(n,e,t)}function Pd(e,t="float32"){if(Re(e),"complex64"===t){let t=Pd(e,"float32"),n=Od(e,"float32");return ii(t,n)}let n=Ee(ee(e),t);return Vs.makeTensor(n,e,t)}function Ld(e,t,{indexing:n="xy"}={}){if("xy"!==n&&"ij"!==n)throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(void 0===e)return[];let r=ti(e,"x","meshgrid",e instanceof bs?e.dtype:"float32");if(void 0===t)return[r];let a=ti(t,"y","meshgrid",t instanceof bs?t.dtype:"float32"),s=ee(r.shape),i=ee(a.shape);return"xy"===n?(r=ql(r,[1,-1]),a=ql(a,[-1,1]),[tu(Pd([i,1],r.dtype),r),tu(a,Pd([1,s],a.dtype))]):(r=ql(r,[-1,1]),a=ql(a,[1,-1]),[tu(r,Pd([1,i],r.dtype)),tu(Pd([s,1],a.dtype),a)])}function zd(e,t){let n=ti(e,"a","minimum"),r=ti(t,"b","minimum");[n,r]=Rs(n,r),"bool"===n.dtype&&(n=wo(n,"int32"),r=wo(r,"int32")),wp(n.shape,r.shape);let a={a:n,b:r};return Vs.runKernel(zn,a)}var Bd=ai({minimum_:zd});function Wd(e,t,n){Y("reflect"===n||"symmetric"===n,(()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`));let r=ti(e,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");Y(t.length===r.rank,(()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`));let a="reflect"===n?1:0;for(let o=0;o<r.rank;o++)Y(2===t[o].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Y(t[o][0]>=0&&t[o][0]<=r.shape[o]-a&&t[o][1]>=0&&t[o][1]<=r.shape[o]-a,(()=>`Padding in dimension ${o} cannot be greater than or equal to ${r.shape[o]-a} or less than 0 for input of shape ${r.shape}`));let s={paddings:t,mode:n},i={x:r};return Vs.runKernel(Bn,i,s)}var Ud=ai({mirrorPad_:Wd});function Vd(e,t){let n=ti(e,"a","mod"),r=ti(t,"b","mod");[n,r]=Rs(n,r);let a={a:n,b:r};return Vs.runKernel(Wn,a)}var Gd=ai({mod_:Vd});function Hd(e,t=null,n=!1){e=ti(e,"x","moments");let r=pe(t,e.shape),a=Md(e,r,n),s=a.shape;n||(s=Wp(a.shape,r));let i=nc(ud(wo(e,"float32"),ql(a,s))),o=Md(i,r,n);return{mean:a,variance:o}}var jd=ai({moments_:Hd});function qd(e,t,n,r){let a=ti(t,"data","multiRNNCell"),s=ni(n,"c","multiRNNCell"),i=ni(r,"h","multiRNNCell"),o=a,l=[];for(let c=0;c<e.length;c++){let t=e[c](o,s[c],i[c]);l.push(t[0]),l.push(t[1]),o=t[1]}let u=[],p=[];for(let c=0;c<l.length;c+=2)u.push(l[c]),p.push(l[c+1]);return[u,p]}var Kd=ai({multiRNNCell_:qd});function Xd(e,t,n,r=!1){let a=ti(e,"logits","multinomial"),s=a.size,i=a.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();let o={logits:1===i?ql(a,[1,-1]):a},l={numSamples:t,seed:n,normalized:r},u=Vs.runKernel(Un,o,l);return 1===i?ql(u,[u.size]):u}var Jd=ai({multinomial_:Xd});function Yd(e,t){let n=ti(e,"a","notEqual","string_or_numeric"),r=ti(t,"b","notEqual","string_or_numeric");[n,r]=Rs(n,r),wp(n.shape,r.shape);let a={a:n,b:r};return Vs.runKernel(Hn,a)}var Zd=ai({notEqual_:Yd});function Qd(e,t,n=1,r=0,a="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let s={indices:ti(e,"indices","oneHot","int32")},i={dtype:a,depth:t,onValue:n,offValue:r};return Vs.runKernel(Jn,s,i)}var eh=ai({oneHot_:Qd});function th(e){let t={x:ti(e,"x","onesLike")};return Vs.runKernel(Xn,t)}var nh=ai({onesLike_:th});function rh(e,t){let n=ti(e,"v1","outerProduct"),r=ti(t,"v2","outerProduct");Y(1===n.rank&&1===r.rank,(()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`));let a=ql(n,[-1,1]),s=ql(r,[1,-1]);return tu(a,s)}var ah=ai({outerProduct_:rh});function sh(e,t,n=0){let r=ti(e,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let a={paddings:t,constantValue:n},s={x:r};return Vs.runKernel(Zn,s,a)}var ih=ai({pad_:sh});function oh(e,t,n=0){return Y(2===t.length,(()=>"Invalid number of paddings. Must be length of 2.")),ih(e,[t],n)}var lh=ai({pad1d_:oh});function uh(e,t,n=0){return Y(2===t.length&&2===t[0].length&&2===t[1].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),ih(e,t,n)}var ph=ai({pad2d_:uh});function ch(e,t,n=0){return Y(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),ih(e,t,n)}var dh=ai({pad3d_:ch});function hh(e,t,n=0){return Y(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),ih(e,t,n)}var fh=ai({pad4d_:hh});function mh(e,t,n){let r=ti(e,"x","spaceToBatchND");Y(r.rank>=1+t.length,(()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`)),Y(n.length===t.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`)),Y(r.shape.reduce(((e,r,a)=>a>0&&a<=t.length?e&&(r+n[a-1][0]+n[a-1][1])%t[a-1]===0:e),!0),(()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`));let a={x:r},s={blockShape:t,paddings:n};return Vs.runKernel(Rr,a,s)}var gh=ai({spaceToBatchND_:mh});function yh(e,t,n,r,a,s,i){null==a&&(a=[1,1]),null==s&&(s=1),0===r&&(r="valid");let o=ti(e,"x","maxPool"),l=o,u=!1;3===o.rank&&(u=!0,l=ql(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Y(Ul(s,a),(()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${a}'`));let p,c=Cl(l.shape,t,s,a,r),d=[c.dilationHeight,c.dilationWidth];p="same"===r?xh([c.filterHeight,c.filterWidth],d):[[0,0],[0,0]];let h=1===d[0]&&1===d[1],[f,m]=bh([c.inHeight,c.inWidth],d,p),g=h?r:"valid",y=h?l:gh(l,d,f),b=("avg"===n?()=>Xl(y,t,s,g,i):()=>_d(y,t,s,g,i))(),x=h?b:cu(b,d,m);return u?ql(x,[x.shape[1],x.shape[2],x.shape[3]]):x}function bh(e,t,n){let r=n.map((e=>e[0])),a=n.map((e=>e[1])),s=e.concat(r,a),i=t.map(((e,t)=>(e-s[t]%e)%e)),o=a.map(((e,t)=>e+i[t])),l=t.map(((e,t)=>[r[t],o[t]])),u=t.map(((e,t)=>[0,i[t]]));return[l,u]}function xh(e,t){let n=e.map(((e,n)=>e+(e-1)*(t[n]-1))).map((e=>e-1)),r=n.map((e=>Math.floor(e/2))),a=n.map(((e,t)=>e-r[t]));return n.map(((e,t)=>[r[t],a[t]]))}var vh=ai({pool_:yh});function wh(e,t){let n=ti(e,"x","prelu"),r=ti(t,"alpha","prelu"),a={x:n,alpha:r};return Vs.runKernel(tr,a)}var kh=ai({prelu_:wh});function Ih(e,t=null,n=!1){let r=ti(e,"x","prod");"bool"===r.dtype&&(r=wo(r,"int32"));let a={x:r},s={axis:t,keepDims:n};return Vs.runKernel(nr,a,s)}var Sh=ai({prod_:Ih});function Nh(e,t,n,r){let a=e.map(((e,t)=>ti(e,`tensors${t}`,"raggedGather","int32"))),s=ti(t,"paramsDenseValues","raggedGather"),i=ti(n,"indices","raggedGather","int32"),o={paramsNestedSplits:a,paramsDenseValues:s,indices:i},l={outputRaggedRank:r},u=Vs.runKernel(rr,o,l);return{outputNestedSplits:u.slice(0,u.length-1),outputDenseValues:u[u.length-1]}}var Th=ai({raggedGather_:Nh});function _h(e,t,n){let r=ti(e,"starts","raggedRange"),a=ti(t,"limits","raggedRange",r.dtype),s=ti(n,"deltas","raggedRange",r.dtype),i={starts:r,limits:a,deltas:s},o=Vs.runKernel(ar,i);return{rtNestedSplits:o[0],rtDenseValues:o[1]}}var Ch=ai({raggedRange_:_h});function Eh(e,t,n,r,a){let s=ti(e,"shape","raggedTensorToTensor","int32"),i=ti(t,"values","raggedTensorToTensor"),o=ti(n,"defaultValue","raggedTensorToTensor",i.dtype),l=r.map(((e,t)=>ti(e,`tensors${t}`,"raggedTensorToTensor","int32"))),u={shape:s,values:i,defaultValue:o,rowPartitionTensors:l},p={rowPartitionTypes:a};return Vs.runKernel(sr,u,p)}var Ah=ai({raggedTensorToTensor_:Eh});function $h(e,t,n){Re(e);let r=ee(e),a=null;if(null==n||"float32"===n)a=new Float32Array(r);else if("int32"===n)a=new Int32Array(r);else{if("bool"!==n)throw new Error(`Unknown data type ${n}`);a=new Uint8Array(r)}for(let s=0;s<r;s++)a[s]=t();return Vs.makeTensor(a,e,n)}var Rh=ai({rand_:$h}),Fh=b(A()),Dh={};g(Dh,{TEST_EPSILON_FLOAT16:()=>Oh,createVideoElement:()=>qh,encodeStrings:()=>jh,expectArrayBuffersEqual:()=>Hh,expectArraysClose:()=>Ph,expectArraysEqual:()=>Wh,expectNumbersClose:()=>Uh,expectPromiseToFail:()=>Bh,expectValuesInRange:()=>Gh,play:()=>Kh,testEpsilon:()=>Lh});var Mh=.001,Oh=.1;function Ph(e,t,n){return null==n&&(n=Lh()),zh(e,t,((e,t)=>Vh(e,t,n)))}function Lh(){return 32===Vs.backend.floatPrecision()?Mh:Oh}function zh(e,t,n){let r=!0;if((Ja(e)||Ja(t))&&(r=!1),Ja(e)&&Ja(t)&&(r=!0),r){let n=e.constructor.name,r=t.constructor.name;if(n!==r)throw new Error(`Arrays are of different type. Actual: ${n}. Expected: ${r}`)}if(Array.isArray(e)&&Array.isArray(t)){let n=Zs(e),r=Zs(t);if(!ne(n,r))throw new Error(`Arrays have different shapes. Actual: [${n}]. Expected: [${r}]`)}let a=Ja(e)?e:Ya(e),s=Ja(t)?t:Ya(t);if(a.length!==s.length)throw new Error(`Arrays have different lengths actual: ${a.length} vs expected: ${s.length}.\nActual:   ${a}.\nExpected: ${s}.`);for(let i=0;i<s.length;++i){let e=a[i],t=s[i];if(!n(e,t))throw new Error(`Arrays differ: actual[${i}] = ${e}, expected[${i}] = ${t}.\nActual:   ${a}.\nExpected: ${s}.`)}"undefined"!=typeof expect&&expect().nothing()}function Bh(e,t){e().then((()=>t.fail()),(()=>t())),"undefined"!=typeof expect&&expect().nothing()}function Wh(e,t){let n="string"==typeof t||"number"==typeof t||"boolean"==typeof t?[t]:t;return xe(e)||xe(e[0])||xe(t)||xe(t[0])?zh(e,n,((e,t)=>e==t)):zh(e,t,((e,t)=>Vh(e,t,0)))}function Uh(e,t,n){if(null==n&&(n=Lh()),!Vh(e,t,n))throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`);"undefined"!=typeof expect&&expect().nothing()}function Vh(e,t,n){return!isFinite(e)&&!isFinite(t)||!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function Gh(e,t,n){for(let r=0;r<e.length;r++)if(e[r]<t||e[r]>n)throw new Error(`Value out of range:${e[r]} low: ${t}, high: ${n}`)}function Hh(e,t){let n=new Float32Array(e),r=new Float32Array(t);if(n.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${n.length}`);for(let a=0;a<r.length;a++)if(n[a]!==r[a])throw new Error(`Expected ArrayBuffer value at ${a} to be ${r[a]} but got ${n[a]} instead`)}function jh(e){for(let t=0;t<e.length;t++){let n=e[t];Array.isArray(n)?jh(n):e[t]=Ka(n)}return e}function qh(e){let t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(e),new Promise((e=>{t.addEventListener("loadeddata",(n=>e(t))),t.load()}))}async function Kh(e){await e.play(),"requestVideoFrameCallback"in e&&await new Promise((t=>{e.requestVideoFrameCallback(t)}))}var Xh=class{constructor(e,t,n,r,a){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);let s=a||Math.random();this.random=Fh.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){let e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let r,a,s;do{r=2*this.random()-1,a=2*this.random()-1,s=r*r+a*a}while(s>=1||0===s);let i=Math.sqrt(-2*Math.log(s)/s);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*a*i,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}},Jh=class{constructor(e,t,n,r){this.alpha=e,this.beta=1/t,this.dtype=n;let a=r||Math.random();this.randu=Fh.alea(a.toString()),this.randn=new Xh(0,1,n,!1,this.randu()),this.d=e<1?e+2/3:e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,a,s;for(;;){do{r=this.randn.nextValue(),s=1+this.c*r}while(s<=0);if(s*=s*s,e=r*r,t=1-.331*e*e,n=.5*e+this.d*(1-s+Math.log(s)),a=this.randu(),a<t||Math.log(a)<n)break}return s=1/this.beta*this.d*s,this.alpha<1&&(s*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(s)}convertValue(e){return"float32"===this.dtype?e:Math.round(e)}},Yh=class{constructor(e=0,t=1,n,r){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==r&&(r=Math.random()),"number"==typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=Fh.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function Zh(e,t,n=1,r="float32",a){if(Re(e),null==n&&(n=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error(`Unsupported data type ${r}`);let s=new Jh(t,n,r,a),i=xo(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}var Qh=ai({randomGamma_:Zh});function ef(e,t=0,n=1,r,a){if(Re(e),null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);let s=new Xh(t,n,r,!1,a),i=xo(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}var tf=ai({randomNormal_:ef});function nf(e,t,n){if(null!=t&&"bool"===t)throw new Error(`Unsupported data type ${t}`);return tf(e,0,1,t,n)}var rf=ai({randomStandardNormal_:nf});function af(e,t=0,n=1,r="float32",a){Re(e);let s=xo(e,r),i=new Yh(t,n,null,a);for(let o=0;o<s.values.length;o++)s.values[o]=i.nextValue();return s.toTensor()}var sf=ai({randomUniform_:af});function of(e,t,n=1,r="float32"){if(0===n)throw new Error("Cannot have a step of zero");let a={start:e,stop:t,step:n,dtype:r};return Vs.runKernel(ir,{},a)}function lf(e){let t={input:ti(e,"input","real")};return Vs.runKernel(or,t)}var uf=ai({real_:lf});function pf(e){let t={x:ti(e,"x","reciprocal")};return Vs.runKernel(lr,t)}var cf=ai({reciprocal_:pf});function df(e){let t={x:ti(e,"x","relu")};return Vs.runKernel(ur,t)}var hf=ai({relu_:df});function ff(e){let t={x:ti(e,"x","relu6")};return Vs.runKernel(mr,t)}var mf=ai({relu6_:ff});function gf(e,t){let n={x:ti(e,"x","reverse")},r={dims:t};return Vs.runKernel(gr,n,r)}var yf=ai({reverse_:gf});function bf(e){let t=ti(e,"x","reverse");return Y(1===t.rank,(()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`)),yf(t,0)}var xf=ai({reverse1d_:bf});function vf(e,t){let n=ti(e,"x","reverse");return Y(2===n.rank,(()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`)),yf(n,t)}var wf=ai({reverse2d_:vf});function kf(e,t){let n=ti(e,"x","reverse");return Y(3===n.rank,(()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`)),yf(n,t)}var If=ai({reverse3d_:kf});function Sf(e,t){let n=ti(e,"x","reverse");return Y(4===n.rank,(()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`)),yf(n,t)}var Nf=ai({reverse4d_:Sf});function Tf(e){let t={x:ti(e,"x","round")};return Vs.runKernel(yr,t)}var _f=ai({round_:Tf});function Cf(e){let t={x:ti(e,"x","rsqrt","float32")};return Vs.runKernel(br,t)}var Ef=ai({rsqrt_:Cf});function Af(e){let t={x:ti(e,"x","selu")};return Vs.runKernel(Ir,t)}var $f=ai({selu_:Af});function Rf(e,t,n,r,a,s=[1,1],i="NHWC"){let o=ti(e,"x","separableConv2d"),l=ti(t,"depthwiseFilter","separableConv2d"),u=ti(n,"pointwiseFilter","separableConv2d"),p=o,c=!1;if(3===o.rank&&(c=!0,p=ql(o,[1,o.shape[0],o.shape[1],o.shape[2]])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");Y(4===p.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${p.rank}.`)),Y(4===l.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`)),Y(4===u.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`)),Y(1===u.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`)),Y(1===u.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`));let d=l.shape[2],h=l.shape[3];Y(u.shape[2]===d*h,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*h}, but got ${u.shape[2]}.`));let f=hp(p,l,r,a,i,s),m=Wu(f,u,1,"valid",i);return c?ql(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var Ff=ai({separableConv2d_:Rf});async function Df(e,t){let n=ti(e,"x","setdiff1d"),r=ti(t,"y","setdiff1d");Y(n.dtype===r.dtype,(()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`)),Y(1===n.rank,(()=>`x should be 1D tensor, but got x (${n.shape}).`)),Y(1===r.rank,(()=>`y should be 1D tensor, but got y (${r.shape}).`));let a=await n.data(),s=await r.data(),i=new Set(s),o=0;for(let p=0;p<a.length;p++)i.has(a[p])||o++;let l=new ds([o],n.dtype),u=new ds([o],"int32");for(let p=0,c=0;p<a.length;p++)i.has(a[p])||(l.values[c]=a[p],u.values[c]=p,c++);return[l.toTensor(),u.toTensor()]}var Mf=Df;function Of(e){let t={x:ti(e,"x","sign")};return Vs.runKernel(_r,t)}var Pf=ai({sign_:Of});function Lf(e){let t={x:ti(e,"x","sin","float32")};return Vs.runKernel(Nr,t)}var zf=ai({sin_:Lf});function Bf(e){let t={x:ti(e,"x","sinh")};return Vs.runKernel(Tr,t)}var Wf=ai({sinh_:Bf});function Uf(e,t,n){let r=ti(e,"x","slice1d");return Y(1===r.rank,(()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`)),su(r,[t],[n])}var Vf=ai({slice1d_:Uf});function Gf(e,t,n){let r=ti(e,"x","slice2d");return Y(2===r.rank,(()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`)),su(r,t,n)}var Hf=ai({slice2d_:Gf});function jf(e,t,n){let r=ti(e,"x","slice3d");return Y(3===r.rank,(()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`)),su(r,t,n)}var qf=ai({slice3d_:jf});function Kf(e,t,n){let r=ti(e,"x","slice4d");return Y(4===r.rank,(()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`)),su(r,t,n)}var Xf=ai({slice4d_:Kf});function Jf(e,t=-1){let n=ti(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);let r={logits:n},a={dim:t};return Vs.runKernel(Dr,r,a)}var Yf=ai({softmax_:Jf});function Zf(e){Y("complex64"===e.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`));let t={input:e};return Vs.runKernel(Zt,t)}var Qf=ai({fft_:Zf});function em(e){Y("complex64"===e.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`));let t={input:e};return Vs.runKernel(pn,t)}var tm=ai({ifft_:em});function nm(e){let t,n=e.shape[e.shape.length-1],r=e.size/n;if(n<=2){let a=ql(e,[r,n]);t=tm(a)}else{let a=[r,2*(n-1)],s=ql(uf(e),[r,n]),i=ql(Ec(e),[r,n]),o=yf(su(s,[0,1],[r,n-2]),1),l=el(yf(su(i,[0,1],[r,n-2]),1),Zp(-1)),u=Ql([s,o],1),p=Ql([i,l],1),c=ql(ii(u,p),[a[0],a[1]]);t=tm(c)}if(t=uf(t),3===e.rank&&0!==e.shape[0]){let n=t,r=e.shape[0];t=ql(t,[r,t.shape[0]/r,t.shape[1]]),n.dispose()}return t}var rm=ai({irfft_:nm});function am(e,t,n=0){let r={x:ti(e,"x","split")},a={numOrSizeSplits:t,axis:n};return Vs.runKernel(Fr,r,a)}var sm=ai({split_:am});function im(e,t){Y("float32"===e.dtype,(()=>`The dtype for rfft() must be real value but got ${e.dtype}`));let n,r=e.shape[e.shape.length-1],a=e.size/r;if(null!=t&&t<r){let a=e.shape.map((e=>0)),s=e.shape.map((e=>e));s[e.shape.length-1]=t,n=su(e,a,s),r=t}else if(null!=t&&t>r){let a=e.shape.map((e=>e));a[e.shape.length-1]=t-r,n=Ql([e,Od(a)],e.shape.length-1),r=t}else n=e;let s=_p(n),i=ql(ii(n,s),[a,r]),o=Qf(i),l=Math.floor(r/2)+1,u=uf(o),p=Ec(o),c=sm(u,[l,r-l],u.shape.length-1),d=sm(p,[l,r-l],p.shape.length-1),h=n.shape.slice();return h[n.shape.length-1]=l,ql(ii(c[0],d[0]),h)}var om=ai({rfft_:im});function lm(e,t){let n=ti(e,"a","squaredDifference"),r=ti(t,"b","squaredDifference");[n,r]=Rs(n,r),wp(n.shape,r.shape);let a={a:n,b:r},s={};return Vs.runKernel(Br,a,s)}var um=ai({squaredDifference_:lm});function pm(e,t){let n=ti(e,"x","squeeze","string_or_numeric");return ql(n,ce(n.shape,t).newShape)}var cm=ai({squeeze_:pm});function dm(e,t=0){let n=ni(e,"tensors","stack","string_or_numeric");Y(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&Y(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));let r=n,a={axis:t};return Vs.runKernel(Yn,r,a)}var hm=ai({stack_:dm});function fm(e,t=0){let n={x:ti(e,"x","step")},r={alpha:t};return Vs.runKernel(sa,n,r)}var mm=ai({step_:fm});function gm(e,t,n,r,a=0,s=0,i=0,o=0,l=0){let u={x:ti(e,"x","stridedSlice","string_or_numeric")},p={begin:t,end:n,strides:r,beginMask:a,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};return Vs.runKernel(Vr,u,p)}var ym=ai({stridedSlice_:gm});function bm(e){let t={x:ti(e,"x","tan","float32")};return Vs.runKernel(Kr,t)}var xm=ai({tan_:bm});function vm(e,t){Q(e);let n=Zs(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return oi(e,null,n,t)}function wm(e,t,n){if(Q(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");let r=Zs(e,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return oi(e,t,r,n)}function km(e,t,n){if(Q(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");let r=Zs(e,n);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return oi(e,t,r,n)}function Im(e,t,n){if(Q(e),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");let r=Zs(e,n);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return oi(e,t,r,n)}function Sm(e,t,n){if(Q(e),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");let r=Zs(e,n);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return oi(e,t,r,n)}function Nm(e,t,n){if(Q(e),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");let r=Zs(e,n);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||r,oi(e,t,r,n)}var Tm={};function _m(e,t,n){let r=t.rank>1?t.shape[t.rank-1]:1,a=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${a}.`;if(n.rank<a)throw new Error(s+` update.rank < ${a}. `);if(e.length<r+(n.rank-a))throw new Error(s+` Output shape length < ${r+(n.rank-a)}`);if(n.rank!==a+e.length-r)throw new Error(s+" update.rank != "+(a+e.length-r));for(let i=0;i<a;++i)if(n.shape[i]!==t.shape[i])throw new Error(s+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<n.rank-a;++i)if(n.shape[i+a]!==e[i+r])throw new Error(s+` updates.shape[${i+a}] (${n.shape[i+a]}) != shape[${i+a}] (${e[i+a]})`)}function Cm(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}_m(n,t,e)}function Em(e,t,n){let r=t.shape.length,a=r>1?t.shape[r-1]:1,s=n.length,i=1;for(let c=a;c<s;++c)i*=n[c];let o=a<1?1:a,l=ee(t.shape)/o,u=[...Ne(n.slice(0,a)),1],p=ee(n);return{sliceRank:a,numUpdates:l,sliceSize:i,strides:u,outputSize:p}}function Am(e,t,n){let r=ti(e,"tensor","tensorScatterupdate"),a=ti(t,"indices","tensorScatterupdate","int32"),s=ti(n,"updates","tensorScatterupdate");if(Cm(s,a,r.shape),r.dtype!==s.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${s.dtype}.`);let i={tensor:r,indices:a,updates:s},o={};return Vs.runKernel(vr,i,o)}g(Tm,{calculateShapes:()=>Em,validateInput:()=>Cm,validateUpdateShape:()=>_m});var $m=ai({tensorScatterUpdate_:Am});function Rm(e,t=1,n=!0){let r=ti(e,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");let a=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>a)throw new Error(`'k' passed to topk() must be <= the last dimension (${a}) but got ${t}`);let s={x:r},i={k:t,sorted:n},[o,l]=Vs.runKernel(Yr,s,i);return{values:o,indices:l}}var Fm=ai({topk_:Rm});function Dm(e,t=0,n=1,r,a){if(Re(e),null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");let s=new Xh(t,n,r,!0,a),i=xo(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}var Mm=ai({truncatedNormal_:Dm});function Om(e,t=0){let n=ti(e,"x","unique","string_or_numeric");Y(n.rank>0,(()=>"The input tensor must be at least 1D"));let r={x:n},a={axis:t},[s,i]=Vs.runKernel(ea,r,a);return{values:s,indices:i}}var Pm=ai({unique_:Om});function Lm(e,t,n){let r=ti(e,"x","unsortedSegmentSum"),a=ti(t,"segmentIds","unsortedSegmentSum","int32");Y(re(n),(()=>"numSegments must be of dtype int"));let s={x:r,segmentIds:a},i={numSegments:n};return Vs.runKernel(na,s,i)}var zm=ai({unsortedSegmentSum_:Lm});function Bm(e,t=0){let n=ti(e,"x","unstack","string_or_numeric");Y(t>=-n.shape.length&&t<n.shape.length,(()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`));let r={value:n},a={axis:t};return Vs.runKernel(ta,r,a)}var Wm=ai({unstack_:Bm});function Um(e,t){return Sd(e,t,"right")}function Vm(e,t=!0,n,r){return Vs.makeVariable(e,t,n,r)}function Gm(e,t){let n=[];for(let s=0;s<t.length;s++)t[s]&&n.push(s);let r=xo(e,"int32"),a=xo([n.length,e.length],"int32");for(let s=0;s<n.length;s++){let t=r.indexToLoc(n[s]),i=s*e.length;a.values.set(t,i)}return a.toTensor()}async function Hm(e){let t=ti(e,"condition","whereAsync","bool"),n=await t.data(),r=Gm(t.shape,n);return e!==t&&t.dispose(),r}var jm=Hm;async function qm(e,t,n){let r=ti(e,"tensor","boolMask"),a=ti(t,"mask","boolMask","bool"),s=null==n?0:n,i=a.rank,o=r.shape;Y(i>0,(()=>"mask cannot be scalar")),Z(o.slice(s,s+i),a.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let m=s;m<s+i;m++)l*=o[m];let u=o.slice(0,s).concat([l],o.slice(s+i)),p=ql(r,u),c=ql(a,[-1]),d=await jm(c),h=cm(d,[1]),f=Ic(p,h,s);return e!==r&&r.dispose(),t!==a&&a.dispose(),h.dispose(),p.dispose(),c.dispose(),d.dispose(),f}var Km=qm;function Xm(e,t,n){let r=ti(e,"x","transpose");if(null==t&&(t=r.shape.map(((e,t)=>t)).reverse()),Y(r.rank===t.length,(()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`)),t.forEach((e=>{Y(e>=0&&e<r.rank,(()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${t}`))})),r.rank<=1)return r.clone();let a={x:r},s={perm:t};return"complex64"===r.dtype?Do((()=>{let e=uf(r),t=Ec(r);return e=Vs.runKernel(Qr,{x:e},s),t=Vs.runKernel(Qr,{x:t},s),n&&(t=rd(t)),ii(e,t)})):Vs.runKernel(Qr,a,s)}var Jm=ai({transpose_:Xm});function Ym(e,t,n,r,a=!0){let s=ti(e,"v","movingAverage"),i=ti(t,"x","movingAverage"),o=ti(n,"decay","movingAverage");Fs(s,i),Y(ne(s.shape,i.shape),(()=>"Shape mismatch in v and x"));let l=Zp(1),u=ud(l,o),p=el(ud(i,s),u);if(a){Y(null!=r,(()=>"When using zeroDebias: true, step is required."));let e=ti(r,"step","movingAverage");p=Zo(p,ud(l,Yp(o,e)))}return Ko(s,p)}var Zm=ai({movingAverage_:Ym});function Qm(e,t,n){Re(n);let r=ti(e,"indices","scatterND","int32"),a=ti(t,"updates","scatterND");Cm(a,r,n);let s={indices:r,updates:a},i={shape:n};return Vs.runKernel(xr,s,i)}var eg=ai({scatterND_:Qm});function tg(e,t,n,r){if("int32"!==e.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);let a=e.rank>0?e.shape[0]:1,s=e.rank>1?e.shape[1]:1;if(n.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${s}.`);let i=t.size;if(0!==t.rank&&(1!==t.rank||i!==a))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${a}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function ng(e,t,n,r=0){Re(n);let a=ti(e,"sparseIndices","sparseToDense","int32"),s=ti(t,"sparseValues","sparseToDense","string_or_numeric"),i=ti(r,"defaultValue","sparseToDense",s.dtype);tg(a,s,n,i);let o={sparseIndices:a,sparseValues:s,defaultValue:i},l={outputShape:n};return Vs.runKernel(zr,o,l)}var rg=ai({sparseToDense_:ng});function ag(e,t){let n=ti(t,"indices","gatherND","int32"),r={params:ti(e,"x","gatherND","string_or_numeric"),indices:n};return Vs.runKernel(sn,r)}var sg=ai({gatherND_:ag});function ig(e,t){if(null==t)return e.shape.slice();if(ne(e.shape,t))return t;if(e.shape.length===t.length){let n=[];for(let r=0;r<e.shape.length;r++)null==t[r]&&null!=e.shape[r]?n.push(e.shape[r]):n.push(t[r]);return n}return t}function og(e,t,n,r){let a=ti(e,"x","dropout");if(Y("float32"===a.dtype,(()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${a.dtype} tensor instead.`)),Y(t>=0&&t<1,(()=>`rate must be a float in the range [0, 1), but got ${t}.`)),0===t)return e instanceof bs?a.clone():a;let s=ig(a,n),i=1-t,o=Zo(wc(Ko(sf(s,0,1,"float32",r),i)),i);return el(a,o)}var lg=ai({dropout_:og});function ug(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function pg(e,t,n){let r=1-e%2,a=new Float32Array(e);for(let s=0;s<e;++s){let i=2*Math.PI*s/(e+r-1);a[s]=t-n*Math.cos(i)}return vm(a,"float32")}async function cg(e,t,n=1){let r=ti(e,"predictions","inTopK"),a=ti(t,"targets","inTopK");Y(r.rank>1,(()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`)),Y(r.rank-1===a.rank,(()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${a.rank}`)),Z(r.shape.slice(0,r.shape.length-1),a.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let s=r.shape[r.shape.length-1];Y(n>0&&n<=s,(()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${n}`));let i=await r.data(),o=await a.data(),[l,u]=[i.length/s,s],p=de("bool",l);for(let c=0;c<l;c++){let e=c*u,t=i.subarray(e,e+u),r=[];for(let n=0;n<t.length;n++)r.push({value:t[n],index:n});r.sort(((e,t)=>t.value-e.value)),p[c]=0;for(let a=0;a<n;a++)if(r[a].index===o[c]){p[c]=1;break}}return e!==r&&r.dispose(),t!==a&&a.dispose(),li(p,a.shape,"bool")}var dg=cg,hg={};function fg(e,t,n,r,a,s="NHWC",i){let o=e;3===e.rank&&(o=ql(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=ql(t,[1,t.shape[0],t.shape[1],t.shape[2]])),Y(4===o.rank,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`)),Y(4===l.rank,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`)),Y(4===n.length,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`));let u="NHWC"===s?o.shape[3]:o.shape[1],p="NHWC"===s?l.shape[3]:l.shape[1];Y(u===n[2],(()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`)),Y(p===n[3],(()=>`Error in conv2dDerFilter: depth of dy (${p}) must match output depth for filter (${n[3]}).`)),Hl("conv2dDerFilter",a,i);let c={x:o,dy:l},d={strides:r,pad:a,dataFormat:s,dimRoundingMode:i,filterShape:n};return Vs.runKernel(St,c,d)}g(hg,{conv2d:()=>wg,depthwiseConv2d:()=>_g,matMul:()=>Eg});var mg=ai({conv2DBackpropFilter_:fg});function gg(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return el(e,mm(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function yg(e,t){let n=t,r=vp(e.shape,t.shape);return r.length>0&&(n=ac(n,r)),ql(n,e.shape)}function bg(e,t,n,r){if("linear"===t)return e;if("relu"===t)return hf(e);if("elu"===t)return Mp(e);if("relu6"===t)return mf(e);if("prelu"===t)return kh(e,n);if("leakyrelu"===t)return Pc(e,r);if("sigmoid"===t)return ru(e);throw new Error(`Unknown fused activation ${t}.`)}var xg=(e,t)=>!(e>0)||"linear"===t;function vg({x:e,filter:t,strides:n,pad:r,dataFormat:a="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:p}){if(l=l||"linear",!1===xg(Vs.state.gradientDepth,l)){Y("NHWC"===a,(()=>`Error in fused conv2d: got dataFormat of ${a} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`));let c=Wu(e,t,n,r,a,s,i);return null!=o&&(c=Ko(c,o)),bg(c,l,u,p)}let c=ti(e,"x","conv2d","float32"),d=ti(t,"filter","conv2d","float32"),h=c,f=!1;3===c.rank&&(f=!0,h=ql(c,[1,c.shape[0],c.shape[1],c.shape[2]])),Y(4===h.rank,(()=>`Error in fused conv2d: input must be rank 4, but got rank ${h.rank}.`)),Y(4===d.rank,(()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`)),Hl("fused conv2d",r,i);let m="NHWC"===a?h.shape[3]:h.shape[1];Y(d.shape[2]===m,(()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${d.shape[2]}.`)),Y(Ul(n,s),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`));let g,y,b=Al(h.shape,d.shape,n,s,r,i);if(null!=o&&(g=ti(o,"bias","fused conv2d"),[g]=Rs(g,c),"NHWC"===a?wp(b.outShape,g.shape):(Y(g.shape.length<=1,(()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${g.shape.length}.`)),Y(0===g.shape.length||g.shape[0]===b.outChannels||1===g.shape[0],(()=>`Error in fused conv2d: bias shape (${g.shape}) is not compatible with the number of output channels (${b.outChannels})`)))),null!=u){let e=u.shape;if(Y(e.length<=1||3===e.length,(()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${e.length}.`)),1===e.length)Y(1===e[0]||e[0]===b.outChannels,(()=>`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the number of output channels (${b.outChannels}).`));else if(3===e.length)try{wp(e,b.outShape)}catch(k){let t=`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the output shape of the conv2d (${b.outShape}).`;throw Error(t)}y=ti(u,"prelu weights","fused conv2d")}let x=(e,t)=>{Y("NHWC"===a,(()=>`Error in gradient of fused conv2D: got dataFormat of ${a} but only NHWC is currently supported.`));let[i,o,u,p]=t,c=gg(e,u,l);Y(Wl(s),(()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`));let d=Hu(o.shape,c,i,n,r),h=mg(o,c,i.shape,n,r),f=[d,h];if(null!=p){let e=yg(p,c);f.push(e)}return f},v={x:h,filter:d,bias:g,preluActivationWeights:y},w={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:p};return null==o?ed(((e,t,n)=>{let r=Vs.runKernel(ua,v,w);return n([t,e,r]),f&&(r=ql(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:x}}))(h,d):ed(((e,t,n,r)=>{let a=Vs.runKernel(ua,v,w);return r([t,e,a,n]),f&&(a=ql(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:x}}))(h,d,g)}var wg=ai({fusedConv2d_:vg});function kg(e,t,n,r,a,s=[1,1],i){let o=e;3===e.rank&&(o=ql(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=ql(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={x:o,dy:l},p={strides:r,pad:a,dimRoundingMode:i,dilations:s,filterShape:n};return Vs.runKernel(Pt,u,p)}var Ig=ai({depthwiseConv2dNativeBackpropFilter_:kg});function Sg(e,t,n,r,a,s=[1,1],i){let o=t,l=!1;3===t.rank&&(l=!0,o=ql(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={dy:o,filter:n},p={strides:r,pad:a,dimRoundingMode:i,dilations:s,inputShape:e},c=Vs.runKernel(Lt,u,p);return l?ql(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var Ng=ai({depthwiseConv2dNativeBackpropInput_:Sg});function Tg({x:e,filter:t,strides:n,pad:r,dataFormat:a="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:p}){if(!1===xg(Vs.state.gradientDepth,l)){let c=hp(e,t,n,r,a,s,i);return null!=o&&(c=Ko(c,o)),bg(c,l,u,p)}let c=ti(e,"x","depthwiseConv2d","float32"),d=ti(t,"filter","depthwiseConv2d","float32"),h=c,f=!1;3===c.rank&&(f=!0,h=ql(c,[1,c.shape[0],c.shape[1],c.shape[2]])),Y(4===h.rank,(()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${h.rank}.`)),Y(4===d.rank,(()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`)),Y(h.shape[3]===d.shape[2],(()=>`Error in fused depthwiseConv2d: number of input channels (${h.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`)),null==s&&(s=[1,1]),Y(Ul(n,s),(()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`)),Hl("fused depthwiseConv2d",r,i);let m,g,y=Al(h.shape,d.shape,n,s,r,i,!0);null!=o&&(m=ti(o,"bias","fused conv2d"),[m]=Rs(m,c),wp(y.outShape,m.shape)),null!=u&&(g=ti(u,"prelu weights","fused depthwiseConv2d"));let b=(e,t)=>{Y(Wl(s),(()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`));let[a,o,u,p]=t,c=gg(e,u,l),d=Ng(o.shape,c,a,n,r,s,i),h=Ig(o,c,a.shape,n,r,s,i);if(null!=p){let e=yg(m,c);return[d,h,e]}return[d,h]},x={x:h,filter:d,bias:m,preluActivationWeights:g},v={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:p};return null==o?ed(((e,t,n)=>{let r=Vs.runKernel(pa,x,v);return n([t,e,r]),f&&(r=ql(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:b}}))(h,d):ed(((e,t,n,r)=>{let a=Vs.runKernel(pa,x,v);return r([t,e,a,n]),f&&(a=ql(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:b}}))(h,d,m)}var _g=ai({fusedDepthwiseConv2d_:Tg});function Cg({a:e,b:t,transposeA:n=!1,transposeB:r=!1,bias:a,activation:s="linear",preluActivationWeights:i,leakyreluAlpha:o=.2}){if(!1===xg(Vs.state.gradientDepth,s)){let l=tu(e,t,n,r);return null!=a&&(l=Ko(l,a)),bg(l,s,i,o)}let l=ti(e,"a","fused matMul"),u=ti(t,"b","fused matMul");[l,u]=Rs(l,u);let p=n?l.shape[l.rank-2]:l.shape[l.rank-1],c=r?u.shape[u.rank-1]:u.shape[u.rank-2],d=n?l.shape[l.rank-1]:l.shape[l.rank-2],h=r?u.shape[u.rank-2]:u.shape[u.rank-1],f=l.shape.slice(0,-2),m=u.shape.slice(0,-2),g=ee(f),y=ee(m);Y(p===c,(()=>`Error in fused matMul: inner shapes (${p}) and (${c}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${n} and transposeB=${r} must match.`));let b,x,v=wp(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([d,h]),w=ql(l,n?[g,p,d]:[g,d,p]),k=ql(u,r?[y,h,c]:[y,c,h]);null!=a&&(b=ti(a,"bias","fused matMul"),[b]=Rs(b,l),wp(v,b.shape)),null!=i&&(x=ti(i,"prelu weights","fused matMul"));let I=(e,t)=>{let i,o,[l,u,p,c]=t,d=gg(ql(e,p.shape),p,s);if(n||r?!n&&r?(i=tu(d,u,!1,!1),o=tu(d,l,!0,!1)):n&&!r?(i=tu(u,d,!1,!0),o=tu(l,d,!1,!1)):(i=tu(u,d,!0,!0),o=tu(d,l,!0,!0)):(i=tu(d,u,!1,!0),o=tu(l,d,!0,!1)),null!=a){let e=yg(c,d);return[i,o,e]}return[i,o]},S={a:w,b:k,bias:b,preluActivationWeights:x},N={transposeA:n,transposeB:r,activation:s,leakyreluAlpha:o};return null==a?ed(((e,t,n)=>{let r=Vs.runKernel(la,S,N);return n([e,t,r]),{value:ql(r,v),gradFunc:I}}))(w,k):ed(((e,t,n,r)=>{let a=Vs.runKernel(la,S,N);return r([e,t,a,n]),{value:ql(a,v),gradFunc:I}}))(w,k,b)}var Eg=ai({fusedMatMul_:Cg});function Ag(e){return pg(e,.54,.46)}var $g=ai({hammingWindow_:Ag});function Rg(e){return pg(e,.5,.5)}var Fg=ai({hannWindow_:Rg});function Dg(e,t,n,r=!1,a=0){let s=0,i=[];for(;s+t<=e.size;)i.push(su(e,s,t)),s+=n;if(r)for(;s<e.size;){let r=s+t-e.size,o=Ql([su(e,s,t-r),Eu([r],a)]);i.push(o),s+=n}return 0===i.length?wm([],[0,t]):ql(Ql(i),[i.length,t])}var Mg=ai({frame_:Dg});function Og(e,t,n,r,a=Fg){null==r&&(r=ug(t));let s=Mg(e,t,n),i=el(s,a(t));return om(i,r)}var Pg=ai({stft_:Og});function Lg(e,t,n,r,a="bilinear",s=0){let i=ti(e,"image","cropAndResize"),o=ti(t,"boxes","cropAndResize","float32"),l=ti(n,"boxInd","cropAndResize","int32"),u=o.shape[0];Y(4===i.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`)),Y(2===o.rank&&4===o.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${o.shape}.`)),Y(1===l.rank&&l.shape[0]===u,(()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${o.shape}.`)),Y(2===r.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`)),Y(r[0]>=1&&r[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${r}`)),Y("bilinear"===a||"nearest"===a,(()=>`method must be bilinear or nearest, but was ${a}`));let p={image:i,boxes:o,boxInd:l},c={method:a,extrapolationValue:s,cropSize:r};return Vs.runKernel(Ft,p,c)}var zg=ai({cropAndResize_:Lg});function Bg(e){let t=ti(e,"image","flipLeftRight","float32");Y(4===t.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`));let n={image:t};return Vs.runKernel(en,n,{})}var Wg=ai({flipLeftRight_:Bg});function Ug(e){let t=ti(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];Y(t.rank>=2,(()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`)),Y(1===r,(()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`));let a=new Array(t.rank);return a.fill(1,0,n),a[n]=3,yc(t,a)}var Vg=ai({grayscaleToRGB_:Ug});function Gg(e,t,n=0,r=.5){let a=ti(e,"image","rotateWithOffset","float32");Y(4===a.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${a.rank}.`));let s={image:a},i={radians:t,fillValue:n,center:r};return Vs.runKernel(oa,s,i)}var Hg=ai({rotateWithOffset_:Gg});function jg(e,t,n,r,a,s){null==r&&(r=.5),null==a&&(a=Number.NEGATIVE_INFINITY),null==s&&(s=0);let i=e.shape[0];return n=Math.min(n,i),Y(0<=r&&r<=1,(()=>`iouThreshold must be in [0, 1], but was '${r}'`)),Y(2===e.rank,(()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`)),Y(4===e.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`)),Y(1===t.rank,(()=>"scores must be a 1D tensor")),Y(t.shape[0]===i,(()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`)),Y(0<=s&&s<=1,(()=>`softNmsSigma must be in [0, 1], but was '${s}'`)),{maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s}}function qg(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY){let s=ti(e,"boxes","nonMaxSuppression","float32"),i=ti(t,"scores","nonMaxSuppression","float32"),o=jg(s,i,n,r,a);n=o.maxOutputSize,r=o.iouThreshold,a=o.scoreThreshold;let l={maxOutputSize:n,iouThreshold:r,scoreThreshold:a};return Vs.runKernel(jn,{boxes:s,scores:i},l)}var Kg=ai({nonMaxSuppression_:qg});function Xg(e,t,n){let r=Jg(e,t,n),a=r<0?-(r+1):r;e.splice(a,0,t)}function Jg(e,t,n){return Zg(e,t,n||Yg)}function Yg(e,t){return e>t?1:e<t?-1:0}function Zg(e,t,n){let r=0,a=e.length,s=0,i=!1;for(;r<a;){s=r+(a-r>>>1);let o=n(t,e[s]);o>0?r=s+1:(a=s,i=!o)}return i?r:-r-1}function Qg(e,t,n,r,a){return ny(e,t,n,r,a,0)}function ey(e,t,n,r,a,s){return ny(e,t,n,r,a,0,!1,s,!0)}function ty(e,t,n,r,a,s){return ny(e,t,n,r,a,s,!0)}function ny(e,t,n,r,a,s,i=!1,o=!1,l=!1){let u=[];for(let g=0;g<t.length;g++)t[g]>a&&u.push({score:t[g],boxIndex:g,suppressBeginIndex:0});u.sort(sy);let p=s>0?-.5/s:0,c=[],d=[];for(;c.length<n&&u.length>0;){let t=u.pop(),{score:n,boxIndex:s,suppressBeginIndex:i}=t;if(n<a)break;let o=!1;for(let l=c.length-1;l>=i;--l){let n=ry(e,s,c[l]);if(n>=r){o=!0;break}if(t.score=t.score*ay(r,p,n),t.score<=a)break}t.suppressBeginIndex=c.length,o||(t.score===n?(c.push(s),d.push(t.score)):t.score>a&&Xg(u,t,sy))}let h=c.length,f=n-h;o&&f>0&&(c.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));let m={selectedIndices:c};return i&&(m.selectedScores=d),l&&(m.validOutputs=h),m}function ry(e,t,n){let r=e.subarray(4*t,4*t+4),a=e.subarray(4*n,4*n+4),s=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(a[0],a[2]),p=Math.min(a[1],a[3]),c=Math.max(a[0],a[2]),d=Math.max(a[1],a[3]),h=(o-s)*(l-i),f=(c-u)*(d-p);if(h<=0||f<=0)return 0;let m=Math.max(s,u),g=Math.max(i,p),y=Math.min(o,c),b=Math.min(l,d),x=Math.max(y-m,0)*Math.max(b-g,0);return x/(h+f-x)}function ay(e,t,n){let r=Math.exp(t*n*n);return n<=e?r:0}function sy(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}async function iy(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY){let s=ti(e,"boxes","nonMaxSuppressionAsync"),i=ti(t,"scores","nonMaxSuppressionAsync"),o=jg(s,i,n,r,a);n=o.maxOutputSize,r=o.iouThreshold,a=o.scoreThreshold;let l=await Promise.all([s.data(),i.data()]),u=l[0],p=l[1],{selectedIndices:c}=Qg(u,p,n,r,a);return s!==e&&s.dispose(),i!==t&&i.dispose(),vm(c,"int32")}var oy=iy;function ly(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=0){let i=ti(e,"boxes","nonMaxSuppression"),o=ti(t,"scores","nonMaxSuppression"),l=jg(i,o,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;let u={boxes:i,scores:o},p={maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s},c=Vs.runKernel(Kn,u,p);return{selectedIndices:c[0],selectedScores:c[1]}}var uy=ai({nonMaxSuppressionWithScore_:ly});async function py(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=0){let i=ti(e,"boxes","nonMaxSuppressionAsync"),o=ti(t,"scores","nonMaxSuppressionAsync"),l=jg(i,o,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;let u=await Promise.all([i.data(),o.data()]),p=u[0],c=u[1],{selectedIndices:d,selectedScores:h}=ty(p,c,n,r,a,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:vm(d,"int32"),selectedScores:vm(h)}}var cy=py;function dy(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=!1){let i=ti(e,"boxes","nonMaxSuppression"),o=ti(t,"scores","nonMaxSuppression"),l=jg(i,o,n,r,a,null),u=l.maxOutputSize,p=l.iouThreshold,c=l.scoreThreshold,d={boxes:i,scores:o},h={maxOutputSize:u,iouThreshold:p,scoreThreshold:c,padToMaxOutputSize:s},f=Vs.runKernel(qn,d,h);return{selectedIndices:f[0],validOutputs:f[1]}}var hy=ai({nonMaxSuppressionPadded_:dy});async function fy(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=!1){let i=ti(e,"boxes","nonMaxSuppressionAsync"),o=ti(t,"scores","nonMaxSuppressionAsync"),l=jg(i,o,n,r,a,null),u=l.maxOutputSize,p=l.iouThreshold,c=l.scoreThreshold,[d,h]=await Promise.all([i.data(),o.data()]),{selectedIndices:f,validOutputs:m}=ey(d,h,u,p,c,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:vm(f,"int32"),validOutputs:Zp(m,"int32")}}var my=fy;function gy(e,t,n=!1,r=!1){let a=ti(e,"images","resizeBilinear");Y(3===a.rank||4===a.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${a.rank}.`)),Y(2===t.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`)),Y(!1===r||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let s=a,i=!1;3===a.rank&&(i=!0,s=ql(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let[]=t,o={images:s},l={alignCorners:n,halfPixelCenters:r,size:t},u=Vs.runKernel(hr,o,l);return i?ql(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var yy=ai({resizeBilinear_:gy});function by(e,t,n=!1,r=!1){let a=ti(e,"images","resizeNearestNeighbor");Y(3===a.rank||4===a.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${a.rank}.`)),Y(2===t.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`)),Y("float32"===a.dtype||"int32"===a.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),Y(!1===r||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let s=a,i=!1;3===a.rank&&(i=!0,s=ql(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let[]=t,o={images:s},l={alignCorners:n,halfPixelCenters:r,size:t},u=Vs.runKernel(cr,o,l);return i?ql(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var xy=ai({resizeNearestNeighbor_:by});function vy(e,t="binary",n=!1,r=.5){let a,s,i,o,l=ti(e,"image","threshold"),u=.2989,p=.587,c=.114,d=l.shape[0]*l.shape[1],h=el(vm([r]),255);if(Y(3===l.rank,(()=>`Error in threshold: image must be rank 3,but got rank ${l.rank}.`)),Y(3===l.shape[2]||1===l.shape[2],(()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${l.shape[2]}.`)),Y("int32"===l.dtype||"float32"===l.dtype,(()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${l.dtype}.`)),Y("otsu"===t||"binary"===t,(()=>`Method must be binary or otsu, but was ${t}`)),3===l.shape[2]){[a,s,i]=sm(l,[1,1,1],-1);let e=el(a,u),t=el(s,p),n=el(i,c);o=Ko(Ko(e,t),n)}else o=e;if("otsu"===t){let e=ku(wo(_f(o),"int32"),li([]),256);h=wy(e,d)}let f=n?Wc(o,h):Nc(o,h);return wo(el(f,255),"int32")}function wy(e,t){let n,r,a,s,i,o,l=vm([-1]),u=vm([0]),p=vm([0]);for(let c=0;c<e.size-1;c++){n=su(e,0,c+1),r=su(e,c+1),i=Zo(ac(n),t),o=Zo(ac(r),t);let d=ac(el(n,of(0,n.size)));a=Zo(d,ac(n));let h=Eu(r.shape,n.size),f=Ko(of(0,r.size),h),m=el(r,f);s=Zo(ac(m),ac(r));let g=ud(a,s),y=ud(a,s),b=el(i,o);p=el(el(b,g),y);let x=Nc(p,u);u=Np(x,p,u),l=Np(x,vm([c]),l)}return l}var ky=ai({threshold_:vy});function Iy(e,t,n="nearest",r="constant",a=0,s){let i=ti(e,"image","transform","float32"),o=ti(t,"transforms","transform","float32");Y(4===i.rank,(()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`)),Y(2===o.rank&&(o.shape[0]===i.shape[0]||1===o.shape[0])&&8===o.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),Y(null==s||2===s.length,(()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`));let l={image:i,transforms:o},u={interpolation:n,fillMode:r,fillValue:a,outputShape:s};return Vs.runKernel(Zr,l,u)}var Sy=ai({transform_:Iy});function Ny(e,t,n){let r=ti(e,"a","bandPart");Y(r.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`));let a,s,i=r.shape,[o,l]=r.shape.slice(-2);"number"==typeof t?(Y(t%1===0,(()=>`bandPart(): numLower must be an integer, got ${t}.`)),Y(t<=o,(()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${o}).`)),a=ti(t<0?o:t,"numLower","bandPart")):(Y("int32"===t.dtype,(()=>"bandPart(): numLower's dtype must be an int32.")),a=Np(zc(t,0),o,Bd(t,o))),"number"==typeof n?(Y(n%1===0,(()=>`bandPart(): numUpper must be an integer, got ${n}.`)),Y(n<=l,(()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${l}).`)),s=ti(n<0?l:n,"numUpper","bandPart")):(Y("int32"===n.dtype,(()=>"bandPart(): numUpper's dtype must be an int32.")),s=Np(zc(n,0),l,Bd(n,l)));let u=ql(of(0,o,1,"int32"),[-1,1]),p=of(0,l,1,"int32"),c=ud(u,p),d=md(Wc(c,a),_c(c,rd(s))),h=Od([o,l],r.dtype);return ql(hm(Wm(ql(r,[-1,o,l])).map((e=>Np(d,e,h)))),i)}var Ty=ai({bandPart_:Ny});function _y(e){let t;if(Array.isArray(e)){t=!1,Y(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));let n=e[0].shape[0];for(let t=1;t<e.length;++t)Y(e[t].shape[0]===n,(()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`))}else t=!0,e=sm(e,e.shape[0],0).map((e=>cm(e,[0])));Y(e.length<=e[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`));let n=[],r=e;for(let a=0;a<e.length;++a)n.push(Vs.tidy((()=>{let e=r[a];if(a>0)for(let t=0;t<a;++t){let r=el(ac(el(n[t],e)),n[t]);e=ud(e,r)}return Zo(e,oc(e,"euclidean"))})));return t?hm(n,0):n}var Cy=ai({gramSchmidt_:_y});function Ey(e,t=!1){if(Y(e.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`)),2===e.rank)return Ay(e,t);{let n=e.shape.slice(0,e.shape.length-2).reduce(((e,t)=>e*t)),r=Wm(ql(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),a=[],s=[];r.forEach((e=>{let[n,r]=Ay(e,t);a.push(n),s.push(r)}));let i=ql(hm(a,0),e.shape),o=ql(hm(s,0),e.shape);return[i,o]}}function Ay(e,t=!1){return Vs.tidy((()=>{Y(2===e.shape.length,(()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`));let n=e.shape[0],r=e.shape[1],a=xc(n),s=Io(e),i=wm([[1]],[1,1]),o=Io(i),l=n>=r?r:n;for(let e=0;e<l;++e){let t=s,l=o,u=a;[o,s,a]=Vs.tidy((()=>{let t=su(s,[e,e],[n-e,1]),l=oc(t),u=su(s,[e,e],[1,1]),p=Np(Nc(u,0),wm([[-1]]),wm([[1]])),c=ud(u,el(p,l)),d=Zo(t,c);o=1===d.shape[0]?Io(i):Ql([i,su(d,[1,0],[d.shape[0]-1,d.shape[1]])],0);let h=rd(Zo(tu(p,c),l)),f=su(s,[e,0],[n-e,r]),m=el(h,o),g=Jm(o);if(0===e)s=ud(f,tu(m,tu(g,f)));else{let t=ud(f,tu(m,tu(g,f)));s=Ql([su(s,[0,0],[e,r]),t],0)}let y=Jm(m),b=su(a,[0,e],[n,a.shape[1]-e]);if(0===e)a=ud(b,tu(tu(b,o),y));else{let t=ud(b,tu(tu(b,o),y));a=Ql([su(a,[0,0],[n,e]),t],1)}return[o,s,a]})),Mo([t,l,u])}return!t&&n>r&&(a=su(a,[0,0],[n,r]),s=su(s,[0,0],[r,r])),[a,s]}))}var $y,Ry=ai({qr_:Ey});function Fy(e,t,n=$y.SUM_BY_NONZERO_WEIGHTS){let r=ti(e,"losses","computeWeightedLoss"),a=null;null!=t&&(a=ti(t,"weights","computeWeightedLoss"));let s=null==a?r:el(r,a);if(n===$y.NONE)return s;if(n===$y.SUM)return ac(s);if(n===$y.MEAN){if(null==a)return Md(s);{let e=r.size/a.size,t=Zo(ac(s),ac(a));return e>1?Zo(t,Zp(e)):t}}if(n===$y.SUM_BY_NONZERO_WEIGHTS){if(null==a)return Zo(ac(s),Zp(r.size));{let e=el(a,Pd(r.shape)),t=wo(ac(Zd(e,Zp(0))),"float32");return Zo(ac(s),t)}}throw Error(`Unknown reduction: ${n}`)}(function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})($y||($y={}));var Dy=ai({computeWeightedLoss_:Fy});function My(e,t,n,r=$y.SUM_BY_NONZERO_WEIGHTS){let a=ti(e,"labels","absoluteDifference"),s=ti(t,"predictions","absoluteDifference"),i=null;null!=n&&(i=ti(n,"weights","absoluteDifference")),Z(a.shape,s.shape,"Error in absoluteDifference: ");let o=nl(ud(a,s));return Dy(o,i,r)}var Oy=ai({absoluteDifference_:My});function Py(e,t,n,r,a=$y.SUM_BY_NONZERO_WEIGHTS){let s=ti(e,"labels","cosineDistance"),i=ti(t,"predictions","cosineDistance"),o=null;null!=r&&(o=ti(r,"weights","cosineDistance")),Z(s.shape,i.shape,"Error in cosineDistance: ");let l=Zp(1),u=ud(l,ac(el(s,i),n,!0));return Dy(u,o,a)}var Ly=ai({cosineDistance_:Py});function zy(e,t,n,r=$y.SUM_BY_NONZERO_WEIGHTS){let a=ti(e,"labels","hingeLoss"),s=ti(t,"predictions","hingeLoss"),i=null;null!=n&&(i=ti(n,"weights","hingeLoss")),Z(a.shape,s.shape,"Error in hingeLoss: ");let o=Zp(1);a=ud(el(Zp(2),a),o);let l=hf(ud(o,el(a,s)));return Dy(l,i,r)}var By=ai({hingeLoss_:zy});function Wy(e,t,n,r=1,a=$y.SUM_BY_NONZERO_WEIGHTS){let s=ti(e,"labels","huberLoss"),i=ti(t,"predictions","huberLoss"),o=null;null!=n&&(o=ti(n,"weights","huberLoss")),Z(s.shape,i.shape,"Error in huberLoss: ");let l=Zp(r),u=nl(ud(i,s)),p=Bd(u,l),c=ud(u,p),d=Ko(el(Zp(.5),nc(p)),el(l,c));return Dy(d,o,a)}var Uy=ai({huberLoss_:Wy});function Vy(e,t,n,r=1e-7,a=$y.SUM_BY_NONZERO_WEIGHTS){let s=ti(e,"labels","logLoss"),i=ti(t,"predictions","logLoss"),o=null;null!=n&&(o=ti(n,"weights","logLoss")),Z(s.shape,i.shape,"Error in logLoss: ");let l=Zp(1),u=Zp(r),p=rd(el(s,jc(Ko(i,u)))),c=el(ud(l,s),jc(Ko(ud(l,i),u))),d=ud(p,c);return Dy(d,o,a)}var Gy=ai({logLoss_:Vy});function Hy(e,t,n,r=$y.SUM_BY_NONZERO_WEIGHTS){let a=ti(e,"labels","meanSquaredError"),s=ti(t,"predictions","meanSquaredError"),i=null;null!=n&&(i=ti(n,"weights","meanSquaredError")),Z(a.shape,s.shape,"Error in meanSquaredError: ");let o=um(a,s);return Dy(o,i,r)}var jy=ai({meanSquaredError_:Hy});function qy(e,t){let n=ti(e,"labels","sigmoidCrossEntropyWithLogits"),r=ti(t,"logits","sigmoidCrossEntropyWithLogits");Z(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");let a=hf(r),s=el(r,n),i=Kc(cc(rd(nl(r))));return Ko(ud(a,s),i)}function Ky(e,t,n,r=0,a=$y.SUM_BY_NONZERO_WEIGHTS){let s=ti(e,"multiClassLabels","sigmoidCrossEntropy"),i=ti(t,"logits","sigmoidCrossEntropy"),o=null;if(null!=n&&(o=ti(n,"weights","sigmoidCrossEntropy")),Z(s.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){let e=Zp(r),t=Zp(1),n=Zp(.5);s=Ko(el(s,ud(t,e)),el(n,e))}let l=qy(s,i);return Dy(l,o,a)}var Xy=ai({sigmoidCrossEntropy_:Ky});function Jy(e,t,n=-1){if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return ed(((e,t,r)=>{let a=hd(t,[n],!0),s=ud(wo(t,"float32"),a);r([e,s]);let i=rd(el(s,e));return{value:ac(i,[n]),gradFunc:(e,t)=>{let[r,a]=t,s=Wp(e.shape,[n]);return[el(ql(e,s),ud(wo(r,"float32"),cc(a))),el(ql(e,s),ud(cc(a),wo(r,"float32")))]}}}))(e,t)}function Yy(e,t,n,r=0,a=$y.SUM_BY_NONZERO_WEIGHTS){let s=ti(e,"onehotLabels","softmaxCrossEntropy"),i=ti(t,"logits","softmaxCrossEntropy"),o=null;if(null!=n&&(o=ti(n,"weights","softmaxCrossEntropy")),Z(s.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){let e=Zp(r),t=Zp(1),n=Zp(s.shape[1]);s=Ko(el(s,ud(t,e)),Zo(e,n))}let l=Jy(s,i);return Dy(l,o,a)}var Zy=ai({softmaxCrossEntropy_:Yy});function Qy(e,t,n,r){let a=ti(e,"indices","sparseFillEmptyRows","int32"),s=ti(t,"values","sparseFillEmptyRows"),i=ti(n,"denseShape","sparseFillEmptyRows","int32"),o=ti(r,"defaultValue","sparseFillEmptyRows",s.dtype);if(2!==a.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${a.shape}`);if(1!==s.rank)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(1!==i.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(0!==o.rank)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);let l={indices:a,values:s,denseShape:i,defaultValue:o},u=Vs.runKernel(Mr,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}var eb=ai({sparseFillEmptyRows_:Qy});function tb(e,t,n){let r=ti(e,"inputIndices","sparseReshape","int32"),a=ti(t,"inputShape","sparseReshape","int32"),s=ti(n,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==a.rank)throw new Error(`Input shape should be Tensor1D but received shape ${a.shape}`);if(1!==s.rank)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);let i={inputIndices:r,inputShape:a,newShape:s},o=Vs.runKernel(Or,i);return{outputIndices:o[0],outputShape:o[1]}}var nb=ai({sparseReshape_:tb});function rb(e,t,n){let r=ti(e,"data","sparseSegmentMean"),a=ti(t,"indices","sparseSegmentMean","int32"),s=ti(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${a.shape}`);if(1!==s.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${s.shape}`);let i={data:r,indices:a,segmentIds:s};return Vs.runKernel(Pr,i)}var ab=ai({sparseSegmentMean_:rb});function sb(e,t,n){let r=ti(e,"data","sparseSegmentSum"),a=ti(t,"indices","sparseSegmentSum","int32"),s=ti(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${a.shape}`);if(1!==s.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${s.shape}`);let i={data:r,indices:a,segmentIds:s};return Vs.runKernel(Lr,i)}var ib=ai({sparseSegmentSum_:sb});function ob(e,t,n,r,a,s,i,o){let l=ti(e,"data","stringNGrams","string");if("string"!==l.dtype)throw new Error("Data must be of datatype string");if(1!==l.shape.length)throw new Error(`Data must be a vector, saw: ${l.shape}`);let u=ti(t,"dataSplits","stringNGrams");if("int32"!==u.dtype)throw new Error("Data splits must be of datatype int32");let p={separator:n,nGramWidths:r,leftPad:a,rightPad:s,padWidth:i,preserveShortSequences:o},c={data:l,dataSplits:u},d=Vs.runKernel(Gr,c,p);return{nGrams:d[0],nGramsSplits:d[1]}}var lb=ai({stringNGrams_:ob});function ub(e,t,n=!0){let r=ti(e,"input","stringSplit","string"),a=ti(t,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==a.rank)throw new Error(`Delimiter should be a scalar but received shape ${a.shape}`);let s={skipEmpty:n},i={input:r,delimiter:a},o=Vs.runKernel(Hr,i,s);return{indices:o[0],values:o[1],shape:o[2]}}var pb=ai({stringSplit_:ub});function cb(e,t){let n=ti(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");let a={input:n};return Vs.runKernel(jr,a,r)}var db=ai({stringToHashBucketFast_:cb});function hb(e,t,n,r=!0){let a=ti(e,"input","staticRegexReplace","string"),s={pattern:t,rewrite:n,replaceGlobal:r};return Vs.runKernel(Ur,{x:a},s)}var fb=ai({staticRegexReplace_:hb}),mb={fft:Qf,ifft:tm,rfft:om,irfft:rm},gb={hammingWindow:$g,hannWindow:Fg,frame:Mg,stft:Pg},yb={flipLeftRight:Wg,grayscaleToRGB:Vg,resizeNearestNeighbor:xy,resizeBilinear:yy,rotateWithOffset:Hg,cropAndResize:zg,nonMaxSuppression:Kg,nonMaxSuppressionAsync:oy,nonMaxSuppressionWithScore:uy,nonMaxSuppressionWithScoreAsync:cy,nonMaxSuppressionPadded:hy,nonMaxSuppressionPaddedAsync:my,threshold:ky,transform:Sy},bb={bandPart:Ty,gramSchmidt:Cy,qr:Ry},xb={absoluteDifference:Oy,computeWeightedLoss:Dy,cosineDistance:Ly,hingeLoss:By,huberLoss:Uy,logLoss:Gy,meanSquaredError:jy,sigmoidCrossEntropy:Xy,softmaxCrossEntropy:Zy},vb={sparseFillEmptyRows:eb,sparseReshape:nb,sparseSegmentMean:ab,sparseSegmentSum:ib},wb={stringNGrams:lb,stringSplit:pb,stringToHashBucketFast:db,staticRegexReplace:fb},kb={};g(kb,{Serializable:()=>Ib,SerializationMap:()=>Sb,registerClass:()=>Nb});var Ib=class{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}},Sb=class{constructor(){this.classNameMap={}}static getMap(){return null==Sb.instance&&(Sb.instance=new Sb),Sb.instance}static register(e){Sb.getMap().classNameMap[e.className]=[e,e.fromConfig]}};function Nb(e){Y(null!=e.className,(()=>"Class being registered does not have the static className property defined.")),Y("string"==typeof e.className,(()=>"className is required to be a string, but got type "+typeof e.className)),Y(e.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),Sb.register(e)}var Tb=class extends Ib{minimize(e,t=!1,n){let{value:r,grads:a}=this.computeGradients(e,n);if(null!=n){let e=n.map((e=>({name:e.name,tensor:a[e.name]})));this.applyGradients(e)}else this.applyGradients(a);return Mo(a),t?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return Qc(e,t)}dispose(){null!=this.iterations_&&Mo(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:Zp(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}};Object.defineProperty(Tb,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});var _b=class extends Tb{static get className(){return"Adadelta"}constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=Vs.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=Vs.registeredVariables[t],a=!1;null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:Do((()=>_p(r).variable(a)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:Do((()=>_p(r).variable(a)))});let s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;let i=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;Do((()=>{let e=Ko(el(i,this.rho),el(nc(s),1-this.rho)),t=el(Zo(ec(Ko(o,this.epsilon)),ec(Ko(i,this.epsilon))),s),n=Ko(el(o,this.rho),el(nc(t),1-this.rho));i.assign(e),o.assign(n);let a=Ko(el(t,-this.learningRate),r);r.assign(a)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(Mo(this.accumulatedGrads.map((e=>e.variable))),Mo(this.accumulatedUpdates.map((e=>e.variable))))}async getWeights(){let e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);let t=e.length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedUpdates=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}},Cb=class extends Tb{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=Vs.registeredVariables[t];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:Do((()=>Eu(r.shape,this.initialAccumulatorValue).variable(!1)))});let a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;let s=this.accumulatedGrads[n].variable;Do((()=>{let e=Ko(s,nc(a));s.assign(e);let t=Ko(el(Zo(a,ec(Ko(e,Vs.backend.epsilon()))),-this.learningRate),r);r.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&Mo(this.accumulatedGrads.map((e=>e.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(t)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}},Eb=class extends Tb{static get className(){return"Adam"}constructor(e,t,n,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Do((()=>{this.accBeta1=Zp(t).variable(),this.accBeta2=Zp(n).variable()})),null==r&&(this.epsilon=Vs.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);Do((()=>{let n=ud(1,this.accBeta1),r=ud(1,this.accBeta2);t.forEach(((t,a)=>{let s=Vs.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${t}/m`,variable:Do((()=>_p(s).variable(i)))}),null==this.accumulatedSecondMoment[a]&&(this.accumulatedSecondMoment[a]={originalName:`${t}/v`,variable:Do((()=>_p(s).variable(i)))});let o=Array.isArray(e)?e[a].tensor:e[t];if(null==o)return;let l=this.accumulatedFirstMoment[a].variable,u=this.accumulatedSecondMoment[a].variable,p=Ko(el(l,this.beta1),el(o,1-this.beta1)),c=Ko(el(u,this.beta2),el(nc(o),1-this.beta2)),d=Zo(p,n),h=Zo(c,r);l.assign(p),u.assign(c);let f=Ko(el(Zo(d,Ko(ec(h),this.epsilon)),-this.learningRate),s);s.assign(f)})),this.accBeta1.assign(el(this.accBeta1,this.beta1)),this.accBeta2.assign(el(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&Mo(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedSecondMoment&&Mo(this.accumulatedSecondMoment.map((e=>e.variable)))}async getWeights(){let e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),Do((()=>{this.accBeta1.assign(Yp(this.beta1,this.iterations_+1)),this.accBeta2.assign(Yp(this.beta2,this.iterations_+1))}));let t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedSecondMoment=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}},Ab=class extends Tb{static get className(){return"Adamax"}constructor(e,t,n,r=null,a=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Do((()=>{this.iteration=Zp(0).variable(),this.accBeta1=Zp(t).variable()})),null==r&&(this.epsilon=Vs.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);Do((()=>{let n=ud(1,this.accBeta1),r=Zo(-this.learningRate,Ko(el(this.iteration,this.decay),1));t.forEach(((t,a)=>{let s=Vs.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${t}/m`,variable:_p(s).variable(i)}),null==this.accumulatedWeightedInfNorm[a]&&(this.accumulatedWeightedInfNorm[a]={originalName:`${t}/v`,variable:_p(s).variable(i)});let o=Array.isArray(e)?e[a].tensor:e[t];if(null==o)return;let l=this.accumulatedFirstMoment[a].variable,u=this.accumulatedWeightedInfNorm[a].variable,p=Ko(el(l,this.beta1),el(o,1-this.beta1)),c=el(u,this.beta2),d=nl(o),h=Fd(c,d);l.assign(p),u.assign(h);let f=Ko(el(Zo(r,n),Zo(p,Ko(h,this.epsilon))),s);s.assign(f)})),this.iteration.assign(Ko(this.iteration,1)),this.accBeta1.assign(el(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&Mo(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedWeightedInfNorm&&Mo(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}},$b=class extends Tb{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;let a=Vs.registeredVariables[t];Do((()=>{let e=Ko(el(this.c,r),a);a.assign(e)}))})),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=Oo(Zp(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),0!==e.length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}},Rb=class extends $b{static get className(){return"Momentum"}constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=Zp(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=Vs.registeredVariables[t];null==this.accumulations[n]&&(this.accumulations[n]={originalName:`${t}/momentum`,variable:Do((()=>_p(r).variable(!1)))});let a=this.accumulations[n].variable,s=Array.isArray(e)?e[n].tensor:e[t];null!=s&&Do((()=>{let e,t=Ko(el(this.m,a),s);e=this.useNesterov?Ko(el(this.c,Ko(s,el(t,this.m))),r):Ko(el(this.c,t),r),a.assign(t),r.assign(e)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&Mo(this.accumulations.map((e=>e.variable)))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(t)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}},Fb=class extends Tb{static get className(){return"RMSProp"}constructor(e,t=.9,n=0,r=null,a=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,null==r&&(this.epsilon=Vs.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=Vs.registeredVariables[t],a=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:Do((()=>_p(r).variable(a)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:Do((()=>_p(r).variable(a)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:Do((()=>_p(r).variable(a)))});let s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;let i=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;Do((()=>{let e=Ko(el(i,this.decay),el(nc(s),1-this.decay));if(this.centered){let t=this.accumulatedMeanGrads[n].variable,a=Ko(el(t,this.decay),el(s,1-this.decay)),l=Zo(el(s,this.learningRate),ec(ud(e,Ko(nc(a),this.epsilon)))),u=Ko(el(o,this.momentum),l);i.assign(e),t.assign(a),o.assign(u);let p=ud(r,u);r.assign(p)}else{let e=Ko(el(i,this.decay),el(nc(s),1-this.decay)),t=Ko(el(o,this.momentum),Zo(el(s,this.learningRate),ec(Ko(e,this.epsilon))));i.assign(e),o.assign(t);let n=ud(r,t);r.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&Mo(this.accumulatedMeanSquares.map((e=>e.variable))),null!=this.accumulatedMeanGrads&&this.centered&&Mo(this.accumulatedMeanGrads.map((e=>e.variable))),null!=this.accumulatedMoments&&Mo(this.accumulatedMoments.map((e=>e.variable)))}async getWeights(){let e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);let t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedMoments=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}},Db=[_b,Cb,Eb,Ab,Rb,Fb,$b];function Mb(){for(let e of Db)Nb(e)}var Ob={};g(Ob,{browserFiles:()=>Hb,browserHTTPRequest:()=>rx,concatenateArrayBuffers:()=>bi,copyModel:()=>ho,decodeWeights:()=>di,encodeWeights:()=>ci,fromMemory:()=>ox,fromMemorySync:()=>lx,getLoadHandlers:()=>Fi,getModelArtifactsForJSON:()=>ki,getModelArtifactsForJSONSync:()=>wi,getModelArtifactsInfoForJSON:()=>Ii,getSaveHandlers:()=>Ri,getWeightSpecs:()=>Si,http:()=>nx,isHTTPScheme:()=>ex,listModels:()=>po,loadWeights:()=>Kb,moveModel:()=>fo,registerLoadRouter:()=>$i,registerSaveRouter:()=>Ai,removeModel:()=>co,weightsLoaderFactory:()=>Xb,withSaveHandler:()=>ux,withSaveHandlerSync:()=>px});var Pb="model",Lb=".json",zb=".weights.bin";function Bb(e){return new Promise((e=>setTimeout(e))).then(e)}var Wb=class{constructor(e){if(!We().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Wb.URL_SCHEME)&&(e=e.slice(Wb.URL_SCHEME.length)),(null==e||0===e.length)&&(e=Pb),this.modelJsonFileName=e+Lb,this.weightDataFileName=e+zb}async save(e){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");let t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let n=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],r=vi(e,n),a=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),s=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(s.download=this.modelJsonFileName,s.href=a,await Bb((()=>s.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){let e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=t,await Bb((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:Ii(e)}}}};Wb.URL_SCHEME="downloads://";var Ub=class{constructor(e){if(null==e||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise(((e,t)=>{let n=new FileReader;n.onload=n=>{let r=JSON.parse(n.target.result),a=r.modelTopology;if(null==a)return void t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));if(null==r.weightsManifest)return void t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));if(0===this.weightsFiles.length)return void e({modelTopology:a});let s=ki(r,(e=>this.loadWeights(e)));e(s)},n.onerror=e=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)}))}loadWeights(e){let t=[],n=[];for(let s of e)t.push(...s.weights),n.push(...s.paths);let r=this.checkManifestAndWeightFiles(e),a=n.map((e=>this.loadWeightsFile(e,r[e])));return Promise.all(a).then((e=>[t,bi(e)]))}loadWeightsFile(e,t){return new Promise(((n,r)=>{let a=new FileReader;a.onload=e=>{let t=e.target.result;n(t)},a.onerror=t=>r(`Failed to weights data from file of path '${e}'.`),a.readAsArrayBuffer(t)}))}checkManifestAndWeightFiles(e){let t=[],n=this.weightsFiles.map((e=>xi(e.name))),r={};for(let a of e)a.paths.forEach((e=>{let a=xi(e);if(-1!==t.indexOf(a))throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(t.push(a),-1===n.indexOf(a))throw new Error(`Weight file with basename '${a}' is not provided.`);r[e]=this.weightsFiles[n.indexOf(a)]}));if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}},Vb=e=>We().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Wb.URL_SCHEME)?Gb(e.slice(Wb.URL_SCHEME.length)):null;function Gb(e="model"){return new Wb(e)}function Hb(e){return new Ub(e)}function jb(e,t,n,r){i(e),n=null==n?0:n,r=null==r?1:r,o(n,r);let a=0,s=s=>(s.then((s=>{let i=n+ ++a/e.length*(r-n);return t(i),s})),s);function i(e){Y(null!=e&&Array.isArray(e)&&e.length>0,(()=>"promises must be a none empty array"))}function o(e,t){Y(e>=0&&e<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${e}`)),Y(t>=0&&t<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${t}`)),Y(t>=e,(()=>`startFraction must be no more than endFraction, but got startFraction ${e} and endFraction ${t}`))}return Promise.all(e.map(s))}async function qb(e,t){null==t&&(t={});let n=null==t.fetchFunc?We().platform.fetch:t.fetchFunc,r=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),a=0,s=.5,i=(null==t.onProgress?await Promise.all(r):await jb(r,t.onProgress,a,s)).map((e=>e.arrayBuffer())),o=.5,l=1;return null==t.onProgress?await Promise.all(i):await jb(i,t.onProgress,o,l)}async function Kb(e,t="",n,r){return Xb((e=>qb(e,{requestInit:r})))(e,t,n)}function Xb(e){return async(t,n="",r)=>{let a=t.map((()=>!1)),s={},i=null!=r?r.map((()=>!1)):[],o=[];if(t.forEach(((e,t)=>{let n=0;e.weights.forEach((e=>{let l="quantization"in e?e.quantization.dtype:e.dtype,u=ui[l]*ee(e.shape),p=()=>{a[t]=!0,null==s[t]&&(s[t]=[]),s[t].push({manifestEntry:e,groupOffset:n,sizeBytes:u})};null!=r?r.forEach(((t,n)=>{t===e.name&&(p(),i[n]=!0)})):p(),o.push(e.name),n+=u}))})),!i.every((e=>e))){let e=r.filter(((e,t)=>!i[t]));throw new Error(`Could not find weights in manifest with names: ${e.join(", ")}. \nManifest JSON has weights with names: ${o.join(", ")}.`)}let l=a.reduce(((e,t,n)=>(t&&e.push(n),e)),[]),u=[];l.forEach((e=>{t[e].paths.forEach((e=>{let t=n+(n.endsWith("/")?"":"/")+e;u.push(t)}))}));let p=await e(u),c={},d=0;return l.forEach((e=>{let n=t[e].paths.length,r=0;for(let t=0;t<n;t++)r+=p[d+t].byteLength;let a=new ArrayBuffer(r),i=new Uint8Array(a),o=0;for(let t=0;t<n;t++){let e=new Uint8Array(p[d+t]);i.set(e,o),o+=e.byteLength}s[e].forEach((e=>{let t=a.slice(e.groupOffset,e.groupOffset+e.sizeBytes),n=di(t,[e.manifestEntry]);for(let r in n)c[r]=n[r]})),d+=n})),c}}Ei.registerSaveRouter(Vb);var Jb="application/octet-stream",Yb="application/json",Zb=class{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(Y("function"==typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=We().platform.fetch,Y(null!=e&&e.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(e)&&Y(2===e.length,(()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`)),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;let n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=vi(e,n);t.body.append("model.json",new Blob([JSON.stringify(r)],{type:Yb}),"model.json"),null!=e.weightData&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:Jb}),"model.weights.bin");let a=await this.fetch(this.path,t);if(a.ok)return{modelArtifactsInfo:Ii(e),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)}async load(){let e,t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);try{e=await t.json()}catch(a){let e=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?e+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":e+=" Please make sure the server is serving valid JSON for this request.",new Error(e)}let n=e.modelTopology,r=e.weightsManifest;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return ki(e,(e=>this.loadWeights(e)))}async loadWeights(e){let t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=Qb(t),a=this.weightPathPrefix||n,s=Si(e),i=[],o=[];for(let u of e)for(let e of u.paths)null!=this.weightUrlConverter?o.push(this.weightUrlConverter(e)):i.push(a+e+r);this.weightUrlConverter&&i.push(...await Promise.all(o));let l=await qb(i,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[s,bi(l)]}};function Qb(e){let t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),r=e.substring(0,t),a=n>t?e.substring(n):"";return[r+"/",a]}function ex(e){return null!=e.match(Zb.URL_SCHEME_REGEX)}Zb.URL_SCHEME_REGEX=/^https?:\/\//;var tx=(e,t)=>{if("undefined"==typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>ex(e))):ex(e),n)return nx(e,t)}return null};function nx(e,t){return new Zb(e,t)}function rx(e,t){return nx(e,t)}Ei.registerSaveRouter(tx),Ei.registerLoadRouter(tx);var ax=class{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}},sx=class{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}},ix=class{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}};function ox(e,t,n,r){let a=arguments;return new ix(lx(...a))}function lx(e,t,n,r){return 1===arguments.length?null!=e.modelTopology||null!=e.weightSpecs?new ax(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new ax({modelTopology:e})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new ax({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r}))}function ux(e){return new sx(e)}function px(e){return new sx(e)}var cx={};function dx(e,t,n){let r=ti(e,"labels","confusionMatrix"),a=ti(t,"predictions","confusionMatrix");Y(null==n||n>0&&Number.isInteger(n),(()=>`If provided, numClasses must be a positive integer, but got ${n}`)),Y(1===r.rank,(()=>`Expected the rank of labels to be 1, but got ${r.rank}`)),Y(1===a.rank,(()=>`Expected the rank of predictions to be 1, but got ${a.rank}`)),Y(r.shape[0]===a.shape[0],(()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${a.shape[0]}. Labels and predictions should have the same number of elements.`)),Y(n>0&&Number.isInteger(n),(()=>`numClasses is required to be a positive integer, but got ${n}`));let s=eh(wo(r,"int32"),n),i=eh(wo(a,"int32"),n),o=Jm(s),l=tu(o,i);return wo(l,"int32")}g(cx,{confusionMatrix:()=>fx});var hx,fx=ai({confusionMatrix_:dx}),mx={};function gx(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,a=!1,s=!1,i=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if("undefined"!=typeof ImageData&&e instanceof ImageData)r=!0;else if("undefined"!=typeof HTMLVideoElement&&e instanceof HTMLVideoElement)a=!0;else if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement)s=!0;else if(null!=e.getContext)i=!0;else{if(!("undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);o=!0}if(null!=ma(ia,Vs.backendName)){let n={pixels:e},r={numChannels:t};return Vs.runKernel(ia,n,r)}let l,u,[p,c]=a?[e.videoWidth,e.videoHeight]:[e.width,e.height];if(i)l=e.getContext("2d").getImageData(0,0,p,c).data;else if(r||n)l=e.data;else if(s||a||o){if(null==hx)if("undefined"==typeof document){if("undefined"==typeof OffscreenCanvas||"undefined"==typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");hx=new OffscreenCanvas(1,1).getContext("2d")}else hx=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});hx.canvas.width=p,hx.canvas.height=c,hx.drawImage(e,0,0,p,c),l=hx.getImageData(0,0,p,c).data}if(4===t)u=new Int32Array(l);else{let e=p*c;u=new Int32Array(e*t);for(let n=0;n<e;n++)for(let e=0;e<t;++e)u[n*t+e]=l[4*n+e]}return km(u,[c,p,t],"int32")}function yx(e){return null!=e&&e.data instanceof Uint8Array}function bx(){return"undefined"!=typeof window&&"undefined"!=typeof ImageBitmap&&window.hasOwnProperty("createImageBitmap")}function xx(e){return null!=e&&0!==e.width&&0!==e.height}function vx(e){return bx()&&!(e instanceof ImageBitmap)&&xx(e)&&!yx(e)}async function wx(e,t=3){let n=null;if(We().getBool("WRAP_TO_IMAGEBITMAP")&&vx(e)){let t;try{t=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch(r){t=null}n=null!=t&&t.width===e.width&&t.height===e.height?t:e}else n=e;return gx(n,t)}async function kx(e,t){let n=ti(e,"img","toPixels");if(!(e instanceof bs)){let e=n;n=wo(e,"int32"),e.dispose()}if(2!==n.rank&&3!==n.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);let[r,a]=n.shape.slice(0,2),s=2===n.rank?1:n.shape[2];if(s>4||2===s)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${s}`);if("float32"!==n.dtype&&"int32"!==n.dtype)throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`);let i=await n.data(),o="float32"===n.dtype?255:1,l=new Uint8ClampedArray(a*r*4);for(let u=0;u<r*a;++u){let e=[0,0,0,255];for(let r=0;r<s;r++){let t=i[u*s+r];if("float32"===n.dtype){if(t<0||t>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${t}.`)}else if("int32"===n.dtype&&(t<0||t>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${t}.`);1===s?(e[0]=t*o,e[1]=t*o,e[2]=t*o):e[r]=t*o}let t=4*u;l[t+0]=Math.round(e[0]),l[t+1]=Math.round(e[1]),l[t+2]=Math.round(e[2]),l[t+3]=Math.round(e[3])}if(null!=t){t.width=a,t.height=r;let e=t.getContext("2d"),n=new ImageData(l,a,r);e.putImageData(n,0,0)}return n!==e&&n.dispose(),l}g(mx,{fromPixels:()=>Ix,fromPixelsAsync:()=>wx,toPixels:()=>kx});var Ix=ai({fromPixels_:gx}),Sx={};function Nx(e,t){let n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(0===ee(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);let a=t.shape,s=a[a.length-1],i=1;for(let c=0;c<a.length-1;++c)i*=a[c];let o=e.shape,l=a.slice();l.pop();let u=1;for(let c=s;c<n;++c)u*=o[c],l.push(o[c]);let p=[...Ne(e.shape).map((e=>e/u)),1].slice(0,s);return[l,i,u,p]}g(Sx,{prepareAndValidate:()=>Nx});var Tx={};g(Tx,{assertParamsValid:()=>Ex,computeFlatOffset:()=>Ux,computeOutShape:()=>$x,getNormalizedAxes:()=>Mx,isSliceContinous:()=>Wx,maskToAxes:()=>Ax,parseSliceParams:()=>Vx,sliceInfo:()=>Gx,startForAxis:()=>zx,startIndicesWithElidedDims:()=>Ox,stopForAxis:()=>Bx,stopIndicesWithElidedDims:()=>Px,stridesForAxis:()=>Lx,stridesWithElidedDims:()=>Rx});var _x=-2,Cx=-1;function Ex(e,t,n){let r=e.shape.length;Y(r===t.length,(()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`)),Y(r===n.length,(()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`));for(let a=0;a<r;++a)Y(t[a]+n[a]<=e.shape[a],(()=>`Error in slice${r}D: begin[${a}] + size[${a}] (${t[a]+n[a]}) would overflow input.shape[${a}] (${e.shape[a]})`))}function Ax(e){let t=[],n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function $x(e,t,n){let r=[];for(let a=0;a<e.length;a++)r[a]=Math.ceil((t[a]-e[a])/n[a]);return r}function Rx(e,t,n,r){let a=[...e];for(let s=a.length;s<r.length;s++)a.push(1);for(let s=0;s<n;s++)0===s?a[t]=1:(a.splice(t,0,1),a.pop());return a}function Fx(e,t,n){return n<=e?n:n-(t-1)}function Dx(e,t){let n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function Mx(e,t,n,r,a,s,i,o,l){let u=e.length,p=new Array(u),c=new Array(u),d=new Array(u);if(t.length&&n>0){let l=t[0],u=n+1;p=Ox(i,l,u,r,e),c=Px(o,l,u,a,e),d=Rx(s,l,u,e)}else for(let h=0;h<u;h++)p[h]=zx(i,r,s,e,h,l),c[h]=Bx(o,a,s,e,h,l),d[h]=Lx(s,h,l);return{begin:p,end:c,strides:d}}function Ox(e,t,n,r,a){let s=[...a],i=Dx(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=0;else{let a=Fx(t,n,o),i=r[a];e&1<<a&&(i=0),s[o]=i}return s}function Px(e,t,n,r,a){let s=[...a],i=Dx(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=Number.MAX_SAFE_INTEGER;else{let a=Fx(t,n,o),i=r[a];e&1<<a&&(i=Number.MAX_SAFE_INTEGER),s[o]=i}for(let o=0;o<s.length;o++){let e=a[o];s[o]<0&&(s[o]+=e),s[o]=H(0,s[o],a[o])}return s}function Lx(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function zx(e,t,n,r,a,s){let i=t[a],o=n[a]||1;(e&1<<a||s&1<<a||null==i)&&(i=o>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);let l=r[a];return i<0&&(i+=l),i=H(0,i,l-1),i}function Bx(e,t,n,r,a,s){let i=t[a],o=n[a]||1;(e&1<<a||s&1<<a||null==i)&&(i=o>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);let l=r[a];return i<0&&(i+=l),i=o>0?H(0,i,l):H(-1,i,l-1),i}function Wx(e,t,n){let r=n.length;for(let a=0;a<n.length;a++)if(n[a]>1){r=a;break}for(let a=r+1;a<n.length;a++)if(t[a]>0||n[a]!==e[a])return!1;return!0}function Ux(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function Vx(e,t,n){let r,a,s=e.shape.length;return r="number"==typeof t?[t,...new Array(s-1).fill(0)]:t.length<s?t.concat(new Array(s-t.length).fill(0)):t.slice(),r.forEach((e=>{Y(-1!==e,(()=>"slice() does not support negative begin indexing."))})),a=null==n?new Array(s).fill(-1):"number"==typeof n?[n,...new Array(s-1).fill(-1)]:n.length<s?n.concat(new Array(s-n.length).fill(-1)):n,a=a.map(((t,n)=>t>=0?t:(Y(-1===t,(()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`)),e.shape[n]-r[n]))),[r,a]}function Gx(e,t,n,r,a,s,i,o,l){let u;if(null==r?(u=new Array(t.length),u.fill(1)):u=r,null!=i&&i&i-1)throw new Error("Multiple ellipses in slice is not allowed.");let p=!1,c={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:u.slice(),beginMask:a,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};for(let b=0;b<c.dims;b++)p&&1<<b&o&&c.numAddAxisAfterEllipsis++,1<<b&i&&(p=!0);p||(c.ellipsisMask|=1<<c.dims,c.dims++);let d={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};Hx(c,d);let h=!0,f=!0,m=!0,g=[],y=[];for(let b=0;b<e.length;++b){if(0===d.strides[b])throw Error(`strides[${b}] must be non-zero`);let t=!!(d.shrinkAxisMask&1<<b),n=e[b];if(-1===n){g.push(t?1:-1);continue}let r=[d.beginMask&1<<b,d.endMask&1<<b],a=[d.strides[b]>0?0:-1,d.strides[b]>0?n:n-1];if(t&&d.strides[b]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===d.strides[b];let s=!!(d.beginMask&1<<b&&d.endMask&1<<b);if(d.beginValid&&d.endValid){if(t){let e=d.begin[b]<0?n+d.begin[b]:d.begin[b];if(d.begin[b]=e,d.end[b]=d.begin[b]+1,e<0||e>=n)throw Error(`slice index ${d.begin[b]} of dimension ${b} out of bounds.`)}else d.begin[b]=jx(d.begin[b],0,d.strides[b],n,r,a),d.end[b]=jx(d.end[b],1,d.strides[b],n,r,a);let e=1===d.strides[b]&&0===d.begin[b]&&d.end[b]===n;h=h&&e,f=f&&(0===b&&1===d.strides[b]||e)}else h=h&&1===d.strides[b]&&s,f=f&&(0===b&&1===d.strides[b]||s);let i,o=!1;if(d.beginValid&&d.endValid?(i=d.end[b]-d.begin[b],o=!0):t?(i=1,o=!0):s&&n>=0&&(i=d.strides[b]<0?-n:n,o=!0),o){let e;e=0===i||i<0!=d.strides[b]<0?0:Math.trunc(i/d.strides[b])+(i%d.strides[b]!==0?1:0),g.push(e)}else g.push(-1)}for(let b=0;b<d.finalShapeGatherIndices.length;++b){let e=d.finalShapeGatherIndices[b];e>=0?y.push(g[e]):e===_x&&y.push(1)}return{finalShapeSparse:y.filter(((e,t)=>d.finalShapeGatherIndices[t]!==_x)),finalShape:y,isIdentity:h,sliceDim0:f,isSimpleSlice:m,begin:d.begin,end:d.end,strides:d.strides}}function Hx(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){let a=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<a;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(_x),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=e.begin&&(t.begin[n]=e.begin[r]),null!=e.end&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(Cx),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}function jx(e,t,n,r,a,s){if(a[t])return n>0?s[t]:s[t+1&1];{let t=e<0?r+e:e;return t<s[0]?s[0]:t>s[1]?s[1]:t}}var qx="4.3.0",Kx=class{static sgd(e){return new $b(e)}static momentum(e,t,n=!1){return new Rb(e,t,n)}static rmsprop(e,t=.9,n=0,r=null,a=!1){return new Fb(e,t,n,r,a)}static adam(e=.001,t=.9,n=.999,r=null){return new Eb(e,t,n,r)}static adadelta(e=.001,t=.95,n=null){return new _b(e,t,n)}static adamax(e=.002,t=.9,n=.999,r=null,a=0){return new Ab(e,t,n,r,a)}static adagrad(e,t=.1){return new Cb(e,t)}},Xx=Kx,Jx=(()=>"undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:e=>e())();function Yx(){return new Promise((e=>Jx((()=>e()))))}var Zx,Qx={};function ev(e,t){let n=e[0].length;e.forEach(((e,t)=>{Y(e.length===n,(()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`))})),Y(t>=0&&t<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));let r=e[0];e.forEach(((e,a)=>{for(let s=0;s<n;s++)Y(s===t||e[s]===r[s],(()=>`Error in concat${n}D: Shape of tensors[${a}] (${e}) does not match the shape of the rest (${r}) along the non-concatenated axis ${a}.`))}))}function tv(e,t){let n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}function nv(e,t,n){let r=new Array;if(null==n&&null==t)return r;if(null==t)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(null==n)return r;if(e+n.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let a=1;a<n.length;++a){let s=n[a],i=r[r.length-n.length+a],o=r[i];if(s>=0)if(o>=0){if(o!==s)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${a+e}] = ${s} but shape[${a+e}] = ${o}`)}else r[i]=s}return r}function rv(e){let t={FIRST_DIM_SIZE:Zx.FIRST_DIM_SIZE,VALUE_ROWIDS:Zx.VALUE_ROWIDS,ROW_LENGTHS:Zx.ROW_LENGTHS,ROW_SPLITS:Zx.ROW_SPLITS,ROW_LIMITS:Zx.ROW_LIMITS,ROW_STARTS:Zx.ROW_STARTS},n=[];for(let r of e){if(!(r in t))break;n.push(t[r])}return n}function av(e){return 0===e.length?0:e[0]===Zx.FIRST_DIM_SIZE?e.length-1:e.length}function sv(e,t){if(null==e||null==t)return;let n=e.length,r=t.length;if(n>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let a=0;a<Math.min(n,r-1);++a){let n=e[a],r=t[a+1];if(n>=0&&r>=0&&1!==n&&n!==r)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${a-e.length}] = ${n} but ragged tensor input.flatValues.shape[${a-e.length}] = ${r}`)}}g(Qx,{ERF_A1:()=>yv,ERF_A2:()=>bv,ERF_A3:()=>xv,ERF_A4:()=>vv,ERF_A5:()=>wv,ERF_P:()=>gv,PARALLELIZE_THRESHOLD:()=>iv,RowPartitionType:()=>Zx,SELU_SCALE:()=>mv,SELU_SCALEALPHA:()=>fv,applyActivation:()=>bg,assertAndGetBroadcastShape:()=>wp,assertAxesAreInnerMostDims:()=>Up,assertParamsConsistent:()=>ev,assignToTypedArray:()=>_v,axesAreInnerMostDims:()=>Lp,calculateShapes:()=>Em,checkEinsumDimSizes:()=>Ov,checkPadOnDimRoundingMode:()=>Hl,combineLocations:()=>zp,combineRaggedTensorToTensorShapes:()=>nv,complexWithEvenIndex:()=>Sv,complexWithOddIndex:()=>Nv,computeConv2DInfo:()=>Al,computeConv3DInfo:()=>$l,computeDefaultPad:()=>Dl,computeDilation2DInfo:()=>_l,computeOptimalWindowSize:()=>ov,computeOutAndReduceShapes:()=>Bp,computeOutShape:()=>tv,computePool2DInfo:()=>Cl,computePool3DInfo:()=>El,convertConv2DDataFormat:()=>Gl,decodeEinsumEquation:()=>Dv,eitherStridesOrDilationsAreOne:()=>Ul,expandShapeToKeepDim:()=>Wp,exponent:()=>Ev,exponents:()=>Cv,fromStringArrayToUint8:()=>aw,fromUint8ToStringArray:()=>rw,getAxesPermutation:()=>Vp,getBroadcastDims:()=>xp,getComplexWithIndex:()=>Tv,getEinsumComputePath:()=>Pv,getEinsumPermutation:()=>Mv,getFusedBiasGradient:()=>yg,getFusedDyActivation:()=>gg,getImageCenter:()=>lv,getInnerMostAxes:()=>Hp,getPermuted:()=>pv,getRaggedRank:()=>av,getReductionAxes:()=>vp,getReshaped:()=>uv,getReshapedPermuted:()=>cv,getRowPartitionTypesHelper:()=>rv,getSliceBeginCoords:()=>dv,getSliceSize:()=>hv,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>Wv,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>Uv,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>Vv,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>jv,getSparseReshapeInputOutputMismatchErrorMessage:()=>Kv,getSparseReshapeInputOutputMultipleErrorMessage:()=>qv,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>Gv,getSparseReshapeNegativeOutputDimErrorMessage:()=>Hv,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>Zv,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>Xv,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>Jv,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>Yv,getUndoAxesPermutation:()=>Gp,isIdentityPermutation:()=>Lv,log:()=>da,mergeRealAndImagArrays:()=>kv,prepareAndValidate:()=>Nx,prepareSplitSize:()=>Bv,segment_util:()=>Qv,shouldFuse:()=>xg,slice_util:()=>Tx,splitRealAndImagArrays:()=>Iv,stridesOrDilationsArePositive:()=>Vl,tupleValuesAreOne:()=>Wl,upcastType:()=>Cs,validateDefaultValueShape:()=>sv,validateInput:()=>Cm,validateUpdateShape:()=>_m,warn:()=>ca}),function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"}(Zx||(Zx={}));var iv=30;function ov(e){return e<=iv?e:Se(e,Math.floor(Math.sqrt(e)))}function lv(e,t,n){let r=n*("number"==typeof e?e:e[0]),a=t*("number"==typeof e?e:e[1]);return[r,a]}function uv(e,t,n,r=!0){let a=[];if(r)a=a.concat(t.slice(0)),a.push(e[0]/n),a=a.concat(e.slice(1));else{a=a.concat(e[0]);let n=t.length;for(let r=0;r<n;++r)a=a.concat([e[r+1]/t[r],t[r]]);a=a.concat(e.slice(n+1))}return a}function pv(e,t,n=!0){let r=[];if(n){r.push(t);for(let n=t+1;n<e;++n)n<=2*t?(r.push(n),r.push(n-(t+1))):r.push(n)}else{let n=[],a=[];for(let r=1;r<e;++r)r>=2*t+1||r%2===1?a.push(r):n.push(r);r.push(...n),r.push(0),r.push(...a)}return r}function cv(e,t,n,r=!0){let a=[];r?a.push(e[0]/n):a.push(e[0]*n);for(let s=1;s<e.length;++s)s<=t.length?r?a.push(t[s-1]*e[s]):a.push(e[s]/t[s-1]):a.push(e[s]);return a}function dv(e,t){let n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function hv(e,t,n){let r=e.slice(0,1);for(let a=0;a<n;++a)r.push(e[a+1]-t[a][0]-t[a][1]);return r}var fv=1.7580993408473768,mv=1.0507009873554805,gv=.3275911,yv=.254829592,bv=-.284496736,xv=1.421413741,vv=-1.453152027,wv=1.061405429;function kv(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);let n=new Float32Array(2*e.length);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function Iv(e){let t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function Sv(e){let t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let a=0;a<e.length;a+=4)n[Math.floor(a/4)]=e[a],r[Math.floor(a/4)]=e[a+1];return{real:n,imag:r}}function Nv(e){let t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let a=2;a<e.length;a+=4)n[Math.floor(a/4)]=e[a],r[Math.floor(a/4)]=e[a+1];return{real:n,imag:r}}function Tv(e,t){let n=e[2*t],r=e[2*t+1];return{real:n,imag:r}}function _v(e,t,n,r){e[2*r]=t,e[2*r+1]=n}function Cv(e,t){let n=new Float32Array(e/2),r=new Float32Array(e/2);for(let a=0;a<Math.ceil(e/2);a++){let s=(t?2:-2)*Math.PI*(a/e);n[a]=Math.cos(s),r[a]=Math.sin(s)}return{real:n,imag:r}}function Ev(e,t,n){let r=(n?2:-2)*Math.PI*(e/t),a=Math.cos(r),s=Math.sin(r);return{real:a,imag:s}}var Av="->",$v=/->/g,Rv=",",Fv="...";function Dv(e,t){e=e.replace(/\s/g,"");let n=(e.length-e.replace($v,"").length)/Av.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${Av}").`);let[r,a]=e.split(Av);Y(-1===r.indexOf(Fv),(()=>`The ellipsis notation ("${Fv}") is not supported yet.`));let s=r.split(Rv),i=s.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let o=[];for(let d=0;d<a.length;++d){let e=a[d];if(!s.some((t=>-1!==t.indexOf(e))))throw new Error(`Output subscripts contain the label ${e} not present in the input subscripts.`);-1===o.indexOf(e)&&o.push(e)}for(let d=0;d<r.length;++d){let e=r[d];-1===o.indexOf(e)&&e!==Rv&&o.push(e)}let l=new Array(s.length);for(let d=0;d<i;++d){if(new Set(s[d].split("")).size!==s[d].length)throw new Error(`Found duplicate axes in input component ${s[d]}. Support for duplicate axes in input is not implemented yet.`);l[d]=[];for(let e=0;e<s[d].length;++e)l[d].push(o.indexOf(s[d][e]))}let u=o.length,p=a.length,c=[];for(let d=p;d<u;++d)c.push(d);return{allDims:o,summedDims:c,idDims:l}}function Mv(e,t){let n=new Array(e);n.fill(-1);for(let a=0;a<t.length;++a)n[t[a]]=a;let r=[];for(let a=0;a<e;++a)-1===n[a]&&r.push(a);return n=n.filter((e=>-1!==e)),{permutationIndices:n,expandDims:r}}function Ov(e,t,n){let r=new Array(e);for(let a=0;a<n.length;++a){let e=n[a].shape;for(let n=0;n<t[a].length;++n)void 0===r[t[a][n]]?r[t[a][n]]=e[n]:Y(r[t[a][n]]===e[n],(()=>`Expected dimension ${r[t[a][n]]} at axis ${n} of input shaped ${JSON.stringify(e)}, but got dimension ${e[n]}`))}}function Pv(e,t){let n=e,r=[],a=0;0===e.length&&n.push(-1),a=e.length+1;for(let i=0;i<a;++i)r.push([]);let s=[];for(let i=0;i<n.length;++i){let e=n[i],a=zv(t,e);for(let t of a)-1===s.indexOf(t)&&(r[i].push(t),s.push(t))}return{path:n,steps:r}}function Lv(e){return e.every(((e,t)=>e===t))}function zv(e,t){let n=[];for(let r=0;r<e.length;++r)(0===e[r].length||-1!==e[r].indexOf(t)||-1===t)&&n.push(r);return n}function Bv(e,t,n=0){let r=[];if("number"==typeof t)Y(e.shape[n]%t===0,(()=>"Number of splits must evenly divide the axis.")),r=new Array(t).fill(e.shape[n]/t);else{let a=t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0);Y(a<=1,(()=>"There should be only one negative value in split array."));let s=t.indexOf(-1);if(-1!==s){let r=t.reduce(((e,t)=>t>0?e+t:e));t[s]=e.shape[n]-r}Y(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),r=t}return r}function Wv(e){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${e}`}function Uv(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function Vv(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function Gv(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function Hv(e,t){return`size ${e} must be non-negative, not ${t}`}function jv(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function qv(e,t){let n=ee(e),r=ee(t);return`Input to reshape is a SparseTensor with ${n}\n  dense values, but the requested shape requires a multiple of ${r}. inputShape=${e} outputShape= ${t}`}function Kv(e,t){let n=ee(e),r=ee(t);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${r}. inputShape=${e} outputShape=${t}`}function Xv(){return"segment ids must be >= 0"}function Jv(){return"segment ids are not increasing"}function Yv(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function Zv(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}var Qv={};function ew(e,t){let n,r=!1;for(e<=iv?(n=e,r=!0):n=Se(e,Math.floor(Math.sqrt(e)));!r;)n>t||n===e?r=!0:n=Se(e,n+1);return n}function tw(e,t,n){let r=[],a=e.length;for(let s=0;s<a;s++)s!==t?r.push(e[s]):r.push(n);return r}function nw(e,t,n,r){let a=t.shape.length,s=e.shape.length;if(0!==r&&(r<-a||r>a))throw new Error(`Expect batchDims in the range of [-${a}, ${a}], but got ${r}`);if(r<0&&(r+=a),r>s)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${s}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let c=0;c<r;++c)if(e.shape[c]!==t.shape[c])throw new Error(`x.shape[${c}]: ${e.shape[c]} should be equal to indices.shape[${c}]: ${t.shape[c]}.`);let i=e.shape[n],o=[],l=1,u=1,p=1;for(let c=0;c<r;++c)o.push(e.shape[c]),l*=e.shape[c];for(let c=r;c<n;c++)o.push(e.shape[c]),u*=e.shape[c];for(let c=r;c<a;c++)o.push(t.shape[c]);for(let c=n+1;c<s;c++)o.push(e.shape[c]),p*=e.shape[c];return{batchSize:l,sliceSize:p,outerSize:u,dimSize:i,outputShape:o}}function rw(e){try{return e.map((e=>Xa(e)))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function aw(e){return e.map((e=>Ka(e)))}g(Qv,{collectGatherOpShapeInfo:()=>nw,computeOutShape:()=>tw,segOpComputeOptimalWindowSize:()=>ew});var sw={};g(sw,{nonMaxSuppressionV3Impl:()=>Qg,nonMaxSuppressionV4Impl:()=>ey,nonMaxSuppressionV5Impl:()=>ty,whereImpl:()=>Gm}),Mb();var iw={kernelName:Ke,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>el(e,mm(wo(n,"float32"),-1))}}},ow={kernelName:Xe,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=nc(wo(n,"float32")),r=ec(ud(Zp(1),t));return rd(Zo(e,r))}}}},lw={kernelName:Je,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=ec(ud(nc(wo(n,"float32")),1));return Zo(e,t)}}}},uw={kernelName:Ye,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=wp(n.shape,r.shape);return{a:()=>{let t=e,r=vp(n.shape,a);return r.length>0&&(t=ac(t,r)),ql(t,n.shape)},b:()=>{let t=e,n=vp(r.shape,a);return n.length>0&&(t=ac(t,n)),ql(t,r.shape)}}}},pw={kernelName:Ze,saveAllInputs:!0,gradFunc:(e,t)=>{let n={};return t.forEach(((t,r)=>{n[r]=()=>e.clone()})),n}},cw={kernelName:tt,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>_p(n)}}},dw={kernelName:nt,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>_p(n)}}},hw={kernelName:rt,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Zo(e,ec(ud(Zp(1),nc(wo(n,"float32")))))}}},fw={kernelName:at,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=ec(Ko(Zp(1),nc(wo(n,"float32"))));return Zo(e,t)}}}},mw={kernelName:ot,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=wp(n.shape,r.shape);return{a:()=>{let t=Ko(nc(n),nc(r)),s=el(e,Zo(r,t)),i=vp(n.shape,a);return i.length>0&&(s=ac(s,i)),ql(s,n.shape)},b:()=>{let t=Ko(nc(n),nc(r)),s=rd(el(e,Zo(n,t))),i=vp(r.shape,a);return i.length>0&&(s=ac(s,i)),ql(s,r.shape)}}}},gw={kernelName:st,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Zo(e,Ko(nc(wo(n,"float32")),1))}}},yw={kernelName:it,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Zo(e,ud(Zp(1),nc(wo(n,"float32"))))}}};function bw(e,t,n,r,a,s){let i=ti(e,"dy","avgPool3dGrad"),o=ti(t,"input","avgPool3dGrad"),l=i,u=o,p=!1;4===o.rank&&(p=!0,l=ql(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=ql(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Y(5===l.rank,(()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`)),Y(5===u.rank,(()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`)),Hl("avgPool3dGrad",a,s);let c={dy:l,input:u},d={filterSize:n,strides:r,pad:a,dimRoundingMode:s},h=Vs.runKernel(ct,c,d);return p?ql(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}var xw=ai({avgPool3dGrad_:bw}),vw={kernelName:pt,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:a,strides:s,pad:i,dimRoundingMode:o}=n;return{x:()=>xw(e,r,a,s,i,o)}}};function ww(e,t,n,r,a){let s=ti(e,"dy","avgPoolGrad"),i=ti(t,"input","avgPoolGrad");Y(i.rank===s.rank,(()=>`Rank of input (${i.rank}) does not match rank of dy (${s.rank})`));let o=i,l=s,u=!1;3===i.rank&&(u=!0,o=ql(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=ql(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Y(4===l.rank,(()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`)),Y(4===o.rank,(()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`));let p={dy:l,input:o},c={filterSize:n,strides:r,pad:a},d=Vs.runKernel(ut,p,c);return u?ql(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var kw=ai({avgPoolGrad_:ww}),Iw={kernelName:lt,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:a,strides:s,pad:i}=n;return{x:()=>kw(e,r,a,s,i)}}},Sw={kernelName:dt,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{let[r,a]=t,{transposeA:s,transposeB:i}=n;return s||i?!s&&i?{a:()=>tu(e,a,!1,!1),b:()=>tu(e,r,!0,!1)}:s&&!i?{a:()=>tu(a,e,!1,!0),b:()=>tu(r,e,!1,!1)}:{a:()=>tu(a,e,!0,!0),b:()=>tu(e,r,!0,!0)}:{a:()=>tu(e,a,!1,!0),b:()=>tu(r,e,!0,!1)}}},Nw={kernelName:ht,gradFunc:(e,t,n)=>{let{blockShape:r,crops:a}=n;return{x:()=>gh(e,r,a)}}},Tw={kernelName:mt,gradFunc:(e,t,n)=>{let r=n,a=r.inputShape,s=r.shape,i=Array.from(s);for(let l=a.length-1;l>=0;l--)if(a[l]===s[l])i[l]=1;else if(1!==a[l])throw new Error(`broadcastTo(): [${a}] cannot be broadcast to [${s}].`);let o=[];for(let l=0;l<i.length;l++)i[l]>1&&o.push(l);return{x:()=>ac(e,o,!0)}}},_w={kernelName:yt,gradFunc:e=>({x:()=>e.clone()})},Cw={kernelName:bt,gradFunc:e=>({x:()=>_p(e)})},Ew={kernelName:xt,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{clipValueMin:a,clipValueMax:s}=n;return{x:()=>Np(md(_c(r,a),Wc(r,s)),e,_p(e))}}},Aw={kernelName:wt,inputsToSave:["x"],gradFunc:iw.gradFunc},$w={kernelName:kt,saveAllInputs:!0,gradFunc:(e,t,n)=>{let r=t.map((e=>e.shape)),{axis:a}=n,s=pe(a,t[0].shape)[0],i=r.map((e=>e[s]));return sm(e,i,s).map((e=>()=>e))}},Rw={kernelName:It,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,{dilations:s,strides:i,pad:o,dataFormat:l}=n;return Y(Wl(s),(()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`)),{x:()=>Hu(r.shape,e,a,i,o,l),filter:()=>mg(r,e,a.shape,i,o,l)}}},Fw={kernelName:Nt,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,{strides:s,pad:i,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>Wu(e,a,s,i,o,1,l),filter:()=>mg(e,r,a.shape,s,i,o,l)}}};function Dw(e,t,n,r,a){let s=e;4===e.rank&&(s=ql(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;4===i.rank&&(i=ql(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),Y(5===s.rank,(()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`)),Y(5===i.rank,(()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`)),Y(5===n.length,(()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`)),Y(s.shape[4]===n[3],(()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${n[3]}.`)),Y(i.shape[4]===n[4],(()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`));let o={x:s,dy:i},l={strides:r,pad:a,filterShape:n};return Vs.runKernel(_t,o,l)}var Mw=ai({conv3DBackpropFilter_:Dw}),Ow={kernelName:Tt,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:a,pad:s}=n;Y(Wl(r),(()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`));let[i,o]=t;return{x:()=>Yu(i.shape,e,o,a,s),filter:()=>Mw(i,e,o.shape,a,s)}}},Pw={kernelName:Et,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>el(rd(zf(wo(n,"float32"))),e)}}},Lw={kernelName:At,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>el(Wf(wo(n,"float32")),e)}}},zw={kernelName:Rt,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a,exclusive:s,reverse:i}=n;return{x:()=>{let t=Vp([a],r.rank),n=op(e,a,s,!i);return null!=t&&(n=Jm(n,t)),n}}}},Bw={kernelName:Ot,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:a,pad:s,dimRoundingMode:i}=n,o=null==r?[1,1]:r;Y(Wl(o),(()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`));let[l,u]=t;return Y(4===l.rank,(()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`)),Y(4===u.rank,(()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`)),Y(l.shape[3]===u.shape[2],(()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`)),Y(Ul(a,o),(()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${a} and dilations '${o}'.`)),Hl("depthwiseConv2d",s,i),{x:()=>Ng(l.shape,e,u,a,s,o,i),filter:()=>Ig(l,e,u.shape,a,s,o,i)}}},Ww={kernelName:Bt,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,s={x:r,filter:a,dy:e},i={x:r,filter:a,dy:e};return{x:()=>Vs.runKernel(Wt,s,n),filter:()=>Vs.runKernel(Ut,i,n)}}},Uw={kernelName:Ht,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t,r={dy:e,y:n};return{x:()=>Vs.runKernel(jt,r)}}},Vw={kernelName:qt,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=el(cc(rd(nc(n))),2/Math.sqrt(Math.PI));return{x:()=>el(e,r)}}},Gw={kernelName:Xt,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>el(e,n)}}},Hw={kernelName:Jt,inputsToSave:["input"],gradFunc:(e,t)=>{let[n]=t;return{input:()=>ql(e,n.shape)}}},jw={kernelName:Yt,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>el(e,cc(n))}}},qw={kernelName:tn,gradFunc:e=>({x:()=>_p(e)})},Kw={kernelName:nn,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=wp(n.shape,r.shape);return{a:()=>{let t=Zo(e,wo(r,"float32")),s=vp(n.shape,a);return s.length>0?ql(ac(t,s),n.shape):t},b:()=>{let t=el(e,wo(n,"float32")),s=vp(r.shape,a);s.length>0&&(t=ql(ac(t,s),r.shape));let i=nc(r);return rd(Zo(t,wo(i,"float32")))}}}},Xw={kernelName:rn,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{let{varianceEpsilon:r}=n,[a,s,i,o]=t,l=null==o?Zp(1):o,u=vp(s.shape,a.shape),p=[];if(1===s.rank){for(let e=0;e<a.shape.length-1;++e)p.push(a.shape[e]);p.push(1)}let c=ud(a,s),d=el(e,l),h=Ef(Ko(i,Zp(r))),f=el(el(el(h,h),h),Zp(-.5));return{x:()=>1===s.rank?ql(el(el(e,yc(ql(h,[1,1,1,s.shape[0]]),p)),l),a.shape):ql(el(el(e,h),l),a.shape),mean:()=>{let e=el(el(h,Zp(-1)),d);return 1===s.rank&&(e=ac(e,u)),ql(e,s.shape)},variance:()=>{let e=el(el(f,c),d);return 1===s.rank&&(e=ac(e,u)),ql(e,s.shape)},scale:()=>{let t=el(c,h),n=el(e,t);return 1===s.rank&&(n=ac(n,u)),ql(n,s.shape)},offset:()=>{let t=e;return 1===s.rank&&(t=ac(t,u)),ql(t,s.shape)}}}},Jw={kernelName:an,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{let[r,a]=t,{axis:s}=n,i=pe(s,r.shape)[0];return{x:()=>{let t=r.shape,n=a.size,o=t.slice(0,i),l=o.length,u=t.slice(s,t.length).slice(1),p=u.length,c=Yw(0,l),d=Yw(l+1,l+1+p),h=Zw([o,[n],u]),f=ql(e,h),m=ql(a,[n]),g=Zw([[l],c,d]),y=Jm(f,g),b=zm(y,m,r.shape[i]),x=Gp(g);return b=Jm(b,x),b},indices:()=>a}}};function Yw(e,t){let n=[];for(let r=e;r<t;++r)n.push(r);return n}function Zw(e){let t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}var Qw={kernelName:ln,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>_p(n),b:()=>_p(r)}}},ek={kernelName:un,gradFunc:e=>({x:()=>wo(e,"float32")})},tk={kernelName:dn,gradFunc:e=>({x:()=>_p(e)})},nk={kernelName:hn,gradFunc:e=>({x:()=>_p(e)})},rk={kernelName:fn,gradFunc:e=>({x:()=>_p(e)})},ak={kernelName:mn,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{alpha:a}=n,s=Nc(r,0);return{x:()=>Np(s,e,el(e,a))}}},sk={kernelName:vn,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Zo(e,Ko(n,1))}}},ik={kernelName:xn,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Zo(e,wo(n,"float32"))}}},ok={kernelName:Nn,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n;return{logits:()=>{let t=cc(r);return ud(e,el(ac(e,a,!0),t))}}}};function lk(e,t,n,r=5,a=1,s=1,i=.5){let o={x:e,y:t,dy:n},l={depthRadius:r,bias:a,alpha:s,beta:i};return Vs.runKernel(Cn,o,l)}var uk=ai({localResponseNormalizationBackprop_:lk}),pk={kernelName:_n,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{depthRadius:s,bias:i,alpha:o,beta:l}=n;return{x:()=>uk(r,a,e,s,i,o,l)}}};function ck(e,t,n,r){return t.rank<n.rank&&(t=ql(t,Wp(t.shape,r))),e.rank<n.rank&&(e=ql(e,Wp(e.shape,r))),{x:()=>el(e,wo(Ip(n,t),e.dtype))}}var dk={kernelName:An,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{reductionIndices:a}=r,s=t[0],i=t[1],o=pe(a,s.shape),l=ck(e,i,s,o);return{x:()=>l.x()}}},hk={kernelName:$n,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>el(e,wo(_c(n,r),"float32")),b:()=>el(e,wo(zc(n,r),"float32"))}}};function fk(e,t,n,r,a,s,i){let o=ti(e,"dy","maxPool3dGrad"),l=ti(t,"input","maxPool3dGrad"),u=ti(n,"output","maxPool3dGrad"),p=o,c=l,d=u,h=!1;4===l.rank&&(h=!0,p=ql(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),c=ql(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=ql(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),Y(5===p.rank,(()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${p.rank}.`)),Y(5===c.rank,(()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${c.rank}.`)),Y(5===d.rank,(()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`)),Hl("maxPool3dGrad",s,i);let f={dy:p,input:c,output:d},m={filterSize:r,strides:a,pad:s,dimRoundingMode:i},g=Vs.runKernel(Mn,f,m);return h?ql(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}var mk=ai({maxPool3dGrad_:fk}),gk={kernelName:Dn,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=n;return{x:()=>mk(e,r,a,s,i,o,l)}}};function yk(e,t,n,r,a,s,i){let o=ti(e,"dy","maxPoolGrad"),l=ti(t,"input","maxPoolGrad"),u=ti(n,"output","maxPoolGrad");Y(l.rank===o.rank,(()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`)),Y(4===o.rank,(()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`)),Y(4===l.rank,(()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`)),Hl("maxPoolGrad",s,i);let p={dy:o,input:l,output:u},c={filterSize:r,strides:a,pad:s,dimRoundingMode:i};return Vs.runKernel(Fn,p,c)}var bk=ai({maxPoolGrad_:yk}),xk={kernelName:Rn,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{filterSize:s,strides:i,pad:o}=n;return{x:()=>bk(e,r,a,s,i,o)}}},vk={kernelName:Pn,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n,s=pe(a,r.shape),i=Bp(r.shape,s)[1],o=ee(i);return{x:()=>{let t=r.shape.slice();s.forEach((e=>{t[e]=1}));let n=ql(e,t);return Zo(el(n,Pd(r.shape,"float32")),o)}}}},wk={kernelName:Ln,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{axis:a}=r,[s,i]=t,o=pe(a,s.shape),l=ck(e,i,s,o);return{x:()=>l.x()}}},kk={kernelName:zn,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>el(e,wo(Wc(n,r),"float32")),b:()=>el(e,wo(Nc(n,r),"float32"))}}},Ik={kernelName:Bn,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:a}=n,s=a.map((e=>e[0]));return{x:()=>su(e,s,r.shape)}}},Sk={kernelName:Wn,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=wp(n.shape,r.shape);return{a:()=>{let t=vp(n.shape,a);return t.length>0?ql(ac(e,t),n.shape):e},b:()=>{let t=el(e,rd(wc(Zo(n,r)))),s=vp(r.shape,a);return s.length>0?ql(ac(t,s),r.shape):t}}}},Nk={kernelName:Vn,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=wp(n.shape,r.shape);return{a:()=>{let t=el(e,wo(r,"float32")),s=vp(n.shape,a);return s.length>0?ql(ac(t,s),n.shape):t},b:()=>{let t=el(e,wo(n,"float32")),s=vp(r.shape,a);return s.length>0?ql(ac(t,s),r.shape):t}}}},Tk={kernelName:Gn,gradFunc:e=>({x:()=>rd(e)})},_k={kernelName:Jn,inputsToSave:["indices"],gradFunc:(e,t)=>{let n=t[0];return{indices:()=>Od(n.shape,"float32")}}},Ck={kernelName:Xn,gradFunc:e=>({x:()=>_p(e)})},Ek={kernelName:Yn,saveAllInputs:!0,gradFunc:(e,t,n)=>{let{axis:r}=n;return Wm(e,r).map((e=>()=>e))}},Ak={kernelName:Zn,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:a}=n,s=a.map((e=>e[0]));return{x:()=>su(e,s,r.shape)}}},$k={kernelName:er,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{let[n,r,a]=t,s=n,i=r,o=wp(s.shape,i.shape);return{a:()=>{let t=wo(i,"float32"),n=el(e,el(t,Yp(s,ud(t,Zp(1))))),r=vp(s.shape,o);return r.length>0&&(n=ac(n,r)),ql(n,s.shape)},b:()=>{let t=Nc(s,0),n=Np(t,jc(s),_p(s)),r=el(e,el(a,n)),l=vp(i.shape,o);return l.length>0&&(r=ac(r,l)),ql(r,i.shape)}}}},Rk={kernelName:tr,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{let[n,r]=t,a=Nc(n,0);return{x:()=>Np(a,e,el(e,r)),alpha:()=>{let t=Np(a,_p(e),el(e,n)),s=vp(r.shape,e.shape);return s.length>0&&(t=ac(t,s)),ql(t,r.shape)}}}};function Fk(e,t,n){let r=e.shape.slice();r[n]=1;let a=ql(t,r),s=sp(e,n,!0,!1),i=sp(e,n,!0,!0),o=el(s,i);return el(a,o)}function Dk(e,t,n){let r=e.shape.length,a=r-n.length,s=Qx.getAxesPermutation(n,r),i=e;null!=s&&(i=Jm(e,s));let o=i.shape.slice(),l=o.splice(r-n.length,n.length).reduce(((e,t)=>e*t),1);o.push(l);let u=i.reshape(o),p=Fk(u,t,a);if(p=p.reshape(i.shape),null!=s){let e=Qx.getUndoAxesPermutation(s);p=Jm(p,e)}return p}var Mk={kernelName:nr,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n,s=[];return s=null==a?r.shape.map(((e,t)=>t)):"number"==typeof a?[a]:a,{x:()=>Dk(r,e,s)}}},Ok={kernelName:Vt,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=wp(n.shape,r.shape);return{a:()=>{let t=Zo(e,wo(r,"float32")),s=vp(n.shape,a);return s.length>0?ql(ac(t,s),n.shape):t},b:()=>{let t=el(e,wo(n,"float32")),s=vp(r.shape,a);s.length>0&&(t=ql(ac(t,s),r.shape));let i=nc(r);return rd(Zo(t,wo(i,"float32")))}}}},Pk={kernelName:lr,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Zo(e,rd(nc(n)))}}},Lk={kernelName:mr,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=el(Wc(n,6),mm(n));return{x:()=>el(e,wo(r,"float32"))}}},zk={kernelName:ur,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>el(e,wo(mm(n),"float32"))}}},Bk={kernelName:pr,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ql(e,n.shape)}}},Wk={kernelName:hr,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,a={dy:e,images:r};return{images:()=>Vs.runKernel(fr,a,n)}}},Uk={kernelName:cr,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,a={dy:e,images:r};return{images:()=>Vs.runKernel(dr,a,n)}}},Vk={kernelName:gr,gradFunc:(e,t,n)=>{let{dims:r}=n,a=pe(r,e.shape);return{x:()=>yf(e,a)}}},Gk={kernelName:yr,gradFunc:e=>({x:()=>_p(e)})},Hk={kernelName:br,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>rd(Zo(e,el(Yp(n,1.5),2)))}}},jk={kernelName:kr,inputsToSave:["condition"],gradFunc:(e,t)=>{let[n]=t;return{condition:()=>wo(_p(n),"float32"),t:()=>el(e,wo(n,e.dtype)),e:()=>el(e,wo(yd(n),e.dtype))}}},qk={kernelName:Ir,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=Nc(n,Zp(0)),r=Zp(fv),a=Zp(mv),s=el(e,a),i=el(el(e,r),cc(wo(n,"float32")));return Np(t,s,i)}}}},Kk={kernelName:Cr,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>el(e,el(n,ud(Zp(1),n)))}}},Xk={kernelName:_r,gradFunc:e=>({x:()=>_p(e)})},Jk={kernelName:Nr,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>el(tp(wo(n,"float32")),e)}}},Yk={kernelName:Tr,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>el(rp(wo(n,"float32")),e)}}},Zk={kernelName:Sr,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{begin:a,size:s}=n,i=r.shape,[o,l]=Vx(r,a,s),u=[];for(let p=0;p<e.rank;p++)u.push([o[p],i[p]-o[p]-l[p]]);return{x:()=>ih(e,u)}}},Qk={kernelName:Dr,outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{dim:a}=n,s=!0,i=el(e,r);return{logits:()=>ud(i,el(ac(i,[a],s),r))}}},eI={kernelName:Er,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>el(e,ru(n))}}},tI={kernelName:Rr,gradFunc:(e,t,n)=>{let{blockShape:r,paddings:a}=n;return{x:()=>cu(e,r,a)}}},nI={kernelName:Fr,gradFunc:(e,t,n)=>{let{axis:r}=n;return{x:()=>Ql(e,r)}}},rI={kernelName:Ar,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Zo(e,el(ec(wo(n,"float32")),2))}}},aI={kernelName:Wr,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>el(e,el(wo(n,"float32"),2))}}},sI={kernelName:Br,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=Zp(2);return{a:()=>el(e,el(a,ud(n,r))),b:()=>el(e,el(a,ud(r,n)))}}},iI={kernelName:sa,gradFunc:e=>({x:()=>_p(e)})},oI={kernelName:qr,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=wp(n.shape,r.shape);return{a:()=>{let t=e,r=vp(n.shape,a);return r.length>0&&(t=ac(t,r)),ql(t,n.shape)},b:()=>{let t=e,n=vp(r.shape,a);return n.length>0&&(t=ac(t,n)),ql(rd(t),r.shape)}}}},lI={kernelName:$r,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,a=r.shape.slice(),{axis:s}=n;pe(s,r.shape).forEach((e=>{a[e]=1}));let i=ql(e,a),o=el(i,Pd(r.shape,"float32"));return{x:()=>o}}},uI={kernelName:Kr,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Zo(e,nc(tp(n)))}}},pI={kernelName:Xr,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>el(ud(Zp(1),nc(n)),e)}}},cI={kernelName:Jr,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{reps:a}=n;return{x:()=>{let t=_p(r);if(1===r.rank)for(let n=0;n<a[0];++n)t=Ko(t,su(e,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)t=Ko(t,su(e,[n*r.shape[0],s*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)for(let i=0;i<a[2];++i)t=Ko(t,su(e,[n*r.shape[0],s*r.shape[1],i*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)for(let i=0;i<a[2];++i)for(let o=0;o<a[3];++o)t=Ko(t,su(e,[n*r.shape[0],s*r.shape[1],i*r.shape[2],o*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return t}}}},dI={kernelName:Qr,gradFunc:(e,t,n)=>{let r=n,{perm:a}=r,s=Gp(a);return{x:()=>Jm(e,s)}}},hI={kernelName:ta,gradFunc:(e,t,n)=>{let r=n,{axis:a}=r;return{value:()=>hm(e,a)}}},fI={kernelName:na,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>mI(e,n)}}};function mI(e,t){let n=Fd(t,_p(t)),r=Ic(e,n),a=_c(t,Zp(0,"int32")),s=r.rank-a.rank;for(let o=0;o<s;++o)a=hc(a,o+1);a=md(a,Pd(r.shape,"bool"));let i=_p(r);return Np(a,r,i)}var gI={kernelName:aa,gradFunc:e=>({x:()=>_p(e)})},yI=[iw,ow,lw,uw,pw,cw,dw,hw,fw,mw,gw,yw,vw,Iw,Sw,Nw,Tw,_w,Cw,Ew,Aw,$w,Fw,Rw,Ow,Pw,Lw,zw,Bw,Ww,Ok,Uw,Vw,Gw,Hw,jw,Kw,qw,Xw,Jw,Qw,ek,tk,nk,rk,ak,sk,ik,ok,pk,dk,dk,hk,gk,xk,vk,wk,kk,Ik,Sk,Nk,Tk,_k,Ck,Ek,Ak,Ak,$k,Rk,Mk,Pk,Lk,zk,Bk,Wk,Uk,Vk,Gk,Hk,jk,qk,Kk,Xk,Jk,Yk,Zk,Qk,eI,tI,tI,nI,nI,rI,sI,aI,iI,oI,lI,uI,pI,cI,dI,hI,fI,gI];for(let cle of yI)xa(cle);xs().prototype.abs=function(){return this.throwIfDisposed(),nl(this)},xs().prototype.acos=function(){return this.throwIfDisposed(),al(this)},xs().prototype.acosh=function(){return this.throwIfDisposed(),il(this)},xs().prototype.add=function(e){return this.throwIfDisposed(),Ko(this,e)},xs().prototype.all=function(e,t){return this.throwIfDisposed(),pl(this,e,t)},xs().prototype.any=function(e,t){return this.throwIfDisposed(),dl(this,e,t)},xs().prototype.argMax=function(e){return this.throwIfDisposed(),fl(this,e)},xs().prototype.argMin=function(e){return this.throwIfDisposed(),gl(this,e)},xs().prototype.asScalar=function(){return this.throwIfDisposed(),Y(1===this.size,(()=>"The array must have only 1 element.")),ql(this,[])},xs().prototype.asType=function(e){return this.throwIfDisposed(),wo(this,e)},xs().prototype.as1D=function(){return this.throwIfDisposed(),ql(this,[this.size])},xs().prototype.as2D=function(e,t){return this.throwIfDisposed(),ql(this,[e,t])},xs().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),ql(this,[e,t,n])},xs().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),ql(this,[e,t,n,r])},xs().prototype.as5D=function(e,t,n,r,a){return this.throwIfDisposed(),ql(this,[e,t,n,r,a])},xs().prototype.asin=function(){return this.throwIfDisposed(),bl(this)},xs().prototype.asinh=function(){return this.throwIfDisposed(),vl(this)},xs().prototype.atan=function(){return this.throwIfDisposed(),kl(this)},xs().prototype.atan2=function(e){return this.throwIfDisposed(),Sl(this,e)},xs().prototype.atanh=function(){return this.throwIfDisposed(),Tl(this)},xs().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),Xl(this,e,t,n,r)},xs().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),cu(this,e,t)},xs().prototype.batchNorm=function(e,t,n,r,a){return this.throwIfDisposed(),fu(this,e,t,n,r,a)},xs().prototype.broadcastTo=function(e){return this.throwIfDisposed(),Tu(this,e)},xs().prototype.cast=function(e){return this.throwIfDisposed(),wo(this,e)},xs().prototype.ceil=function(){return this.throwIfDisposed(),Cu(this)},xs().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),$u(this,e,t)},xs().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof bs&&(e=[e]),Ql([this,...e],t)},xs().prototype.conv1d=function(e,t,n,r,a,s){return this.throwIfDisposed(),Vu(this,e,t,n,r,a,s)},xs().prototype.conv2dTranspose=function(e,t,n,r,a){return this.throwIfDisposed(),qu(this,e,t,n,r,a)},xs().prototype.conv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),Wu(this,e,t,n,r,a,s)},xs().prototype.cos=function(){return this.throwIfDisposed(),tp(this)},xs().prototype.cosh=function(){return this.throwIfDisposed(),rp(this)},xs().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),sp(this,e,t,n)},xs().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),op(this,e,t,n)},xs().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),cp(this,e,t)},xs().prototype.depthwiseConv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),hp(this,e,t,n,r,a,s)},xs().prototype.dilation2d=function(e,t,n,r,a){return this.throwIfDisposed(),yp(this,e,t,n,r,a)},xs().prototype.divNoNan=function(e){return this.throwIfDisposed(),Ep(this,e)},xs().prototype.div=function(e){return this.throwIfDisposed(),Zo(this,e)},xs().prototype.dot=function(e){return this.throwIfDisposed(),$p(this,e)},xs().prototype.elu=function(){return this.throwIfDisposed(),Mp(this)},xs().prototype.equal=function(e){return this.throwIfDisposed(),Ip(this,e)},xs().prototype.erf=function(){return this.throwIfDisposed(),Pp(this)},xs().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),uc(this,e,t)},xs().prototype.exp=function(){return this.throwIfDisposed(),cc(this)},xs().prototype.expandDims=function(e){return this.throwIfDisposed(),hc(this,e)},xs().prototype.expm1=function(){return this.throwIfDisposed(),mc(this)},xs().prototype.fft=function(){return this.throwIfDisposed(),Qf(this)},xs().prototype.flatten=function(){return this.throwIfDisposed(),ql(this,[this.size])},xs().prototype.floor=function(){return this.throwIfDisposed(),wc(this)},xs().prototype.floorDiv=function(e){return this.throwIfDisposed(),Jo(this,e)},xs().prototype.gather=function(e,t,n){return this.throwIfDisposed(),Ic(this,e,t,n)},xs().prototype.greaterEqual=function(e){return this.throwIfDisposed(),_c(this,e)},xs().prototype.greater=function(e){return this.throwIfDisposed(),Nc(this,e)},xs().prototype.ifft=function(){return this.throwIfDisposed(),tm(this)},xs().prototype.irfft=function(){return this.throwIfDisposed(),rm(this)},xs().prototype.isFinite=function(){return this.throwIfDisposed(),$c(this)},xs().prototype.isInf=function(){return this.throwIfDisposed(),Fc(this)},xs().prototype.isNaN=function(){return this.throwIfDisposed(),Mc(this)},xs().prototype.leakyRelu=function(e){return this.throwIfDisposed(),Pc(this,e)},xs().prototype.lessEqual=function(e){return this.throwIfDisposed(),Wc(this,e)},xs().prototype.less=function(e){return this.throwIfDisposed(),zc(this,e)},xs().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),Gc(this,e,t,n,r)},xs().prototype.logSigmoid=function(){return this.throwIfDisposed(),od(this)},xs().prototype.logSoftmax=function(e){return this.throwIfDisposed(),cd(this,e)},xs().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),hd(this,e,t)},xs().prototype.log=function(){return this.throwIfDisposed(),jc(this)},xs().prototype.log1p=function(){return this.throwIfDisposed(),Kc(this)},xs().prototype.logicalAnd=function(e){return this.throwIfDisposed(),md(this,e)},xs().prototype.logicalNot=function(){return this.throwIfDisposed(),yd(this)},xs().prototype.logicalOr=function(e){return this.throwIfDisposed(),xd(this,e)},xs().prototype.logicalXor=function(e){return this.throwIfDisposed(),wd(this,e)},xs().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),tu(this,e,t,n)},xs().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),_d(this,e,t,n,r)},xs().prototype.max=function(e,t){return this.throwIfDisposed(),qp(this,e,t)},xs().prototype.maximum=function(e){return this.throwIfDisposed(),Fd(this,e)},xs().prototype.mean=function(e,t){return this.throwIfDisposed(),Md(this,e,t)},xs().prototype.min=function(e,t){return this.throwIfDisposed(),Xp(this,e,t)},xs().prototype.minimum=function(e){return this.throwIfDisposed(),Bd(this,e)},xs().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),Ud(this,e,t)},xs().prototype.mod=function(e){return this.throwIfDisposed(),Gd(this,e)},xs().prototype.mul=function(e){return this.throwIfDisposed(),el(this,e)},xs().prototype.neg=function(){return this.throwIfDisposed(),rd(this)},xs().prototype.norm=function(e,t,n){return this.throwIfDisposed(),oc(this,e,t,n)},xs().prototype.notEqual=function(e){return this.throwIfDisposed(),Zd(this,e)},xs().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),eh(this,e,t,n)},xs().prototype.onesLike=function(){return this.throwIfDisposed(),nh(this)},xs().prototype.pad=function(e,t){return this.throwIfDisposed(),ih(this,e,t)},xs().prototype.pool=function(e,t,n,r,a,s){return this.throwIfDisposed(),vh(this,e,t,n,r,a,s)},xs().prototype.pow=function(e){return this.throwIfDisposed(),Yp(this,e)},xs().prototype.prelu=function(e){return this.throwIfDisposed(),kh(this,e)},xs().prototype.prod=function(e,t){return this.throwIfDisposed(),Sh(this,e,t)},xs().prototype.reciprocal=function(){return this.throwIfDisposed(),cf(this)},xs().prototype.relu=function(){return this.throwIfDisposed(),hf(this)},xs().prototype.relu6=function(){return this.throwIfDisposed(),mf(this)},xs().prototype.reshapeAs=function(e){return this.throwIfDisposed(),ql(this,e.shape)},xs().prototype.reshape=function(e){return this.throwIfDisposed(),ql(this,e)},xs().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),yy(this,e,t,n)},xs().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),xy(this,e,t,n)},xs().prototype.reverse=function(e){return this.throwIfDisposed(),yf(this,e)},xs().prototype.rfft=function(){return this.throwIfDisposed(),om(this)},xs().prototype.round=function(){return this.throwIfDisposed(),_f(this)},xs().prototype.rsqrt=function(){return this.throwIfDisposed(),Ef(this)},xs().prototype.selu=function(){return this.throwIfDisposed(),$f(this)},xs().prototype.separableConv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),Ff(this,e,t,n,r,a,s)},xs().prototype.sigmoid=function(){return this.throwIfDisposed(),ru(this)},xs().prototype.sign=function(){return this.throwIfDisposed(),Pf(this)},xs().prototype.sin=function(){return this.throwIfDisposed(),zf(this)},xs().prototype.sinh=function(){return this.throwIfDisposed(),Wf(this)},xs().prototype.slice=function(e,t){return this.throwIfDisposed(),su(this,e,t)},xs().prototype.softmax=function(e){return this.throwIfDisposed(),Yf(this,e)},xs().prototype.softplus=function(){return this.throwIfDisposed(),sd(this)},xs().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),gh(this,e,t)},xs().prototype.split=function(e,t){return this.throwIfDisposed(),sm(this,e,t)},xs().prototype.sqrt=function(){return this.throwIfDisposed(),ec(this)},xs().prototype.square=function(){return this.throwIfDisposed(),nc(this)},xs().prototype.squaredDifference=function(e){return this.throwIfDisposed(),um(this,e)},xs().prototype.squeeze=function(e){return this.throwIfDisposed(),cm(this,e)},xs().prototype.stack=function(e,t){this.throwIfDisposed();let n=e instanceof bs?[this,e]:[this,...e];return hm(n,t)},xs().prototype.step=function(e){return this.throwIfDisposed(),mm(this,e)},xs().prototype.stridedSlice=function(e,t,n,r,a,s,i,o){return this.throwIfDisposed(),ym(this,e,t,n,r,a,s,i,o)},xs().prototype.sub=function(e){return this.throwIfDisposed(),ud(this,e)},xs().prototype.sum=function(e,t){return this.throwIfDisposed(),ac(this,e,t)},xs().prototype.tan=function(){return this.throwIfDisposed(),xm(this)},xs().prototype.tanh=function(){return this.throwIfDisposed(),ou(this)},xs().prototype.tile=function(e){return this.throwIfDisposed(),yc(this,e)},xs().prototype.toBool=function(){return this.throwIfDisposed(),wo(this,"bool")},xs().prototype.toFloat=function(){return this.throwIfDisposed(),wo(this,"float32")},xs().prototype.toInt=function(){return this.throwIfDisposed(),wo(this,"int32")},xs().prototype.topk=function(e,t){return this.throwIfDisposed(),Fm(this,e,t)},xs().prototype.transpose=function(e){return this.throwIfDisposed(),Jm(this,e)},xs().prototype.unique=function(e){return this.throwIfDisposed(),Pm(this,e)},xs().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),zm(this,e,t)},xs().prototype.unstack=function(e){return this.throwIfDisposed(),Wm(this,e)},xs().prototype.where=function(e,t){return this.throwIfDisposed(),Np(e,this,t)},xs().prototype.zerosLike=function(){return this.throwIfDisposed(),_p(this)};var bI=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,bI.prototype)}},xI=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,xI.prototype)}},vI=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,vI.prototype)}},wI=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,wI.prototype)}},kI=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,kI.prototype)}},II=class{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){let e=this.cache.keys().next().value;this.cache.delete(e)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){let e=this.cache.keys().next().value;this.cache.delete(e)}this.maxEntries=e}};function SI(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}{let n=new Array(t);return n.fill(e),n}}function NI(e,t){if(!e)throw new kI(t)}function TI(e,t){let n=0;for(let r of e)r===t&&n++;return n}function _I(e){return 1===e.length?e[0]:e}function CI(e){return Array.isArray(e)?e:[e]}function EI(e){let t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function AI(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,((e,t)=>t.toUpperCase()))}var $I={};function RI(e){if(null==e)return null;let t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function FI(e){if(null!=e&&"object"==typeof e)if(Array.isArray(e))e.forEach((e=>FI(e)));else{let t=Object.keys(e);for(let n of t){let t=e[n];null!=t&&"object"==typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!=typeof t.value?FI(t):e[n]=t.value)}}}function DI(e,t={},n={},r="object",a=!1){if("string"==typeof e){let a,s=e;if(s in n)a=n[s];else if(s in $I)a=$I[s];else if(a=t[s],null==a)throw new vI(`Unknown ${r}: ${e}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}{let s=e;if(null==s.className||null==s.config)throw new vI(`${r}: Improper config format: ${JSON.stringify(s)}.\n'className' and 'config' must set.`);let i,o,l=s.className;if(l in n?[i,o]=n[l]:l in $I?[i,o]=$I.className:l in t&&([i,o]=t[l]),null==i)throw new vI(`Unknown ${r}: ${l}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=o){let e={};for(let n of Object.keys($I))e[n]=$I[n];for(let a of Object.keys(n))e[a]=n[a];let t=s.config;t.customObjects=e;let r=Object.assign({},$I);for(let a of Object.keys(n))$I[a]=n[a];FI(s.config);let l=o(i,s.config,n,a);return $I=Object.assign({},r),l}{let e=Object.assign({},$I);for(let r of Object.keys(n))$I[r]=n[r];let t=new i(s.config);return $I=Object.assign({},e),t}}}function MI(e,t){return e<t?-1:e>t?1:0}function OI(e,t){return-1*MI(e,t)}function PI(e){if(null==e)return e;let t=[];for(let n of e)-1===t.indexOf(n)&&t.push(n);return t}function LI(e){if(null==e)throw new vI(`Invalid value in obj: ${JSON.stringify(e)}`);for(let t in e)if(e.hasOwnProperty(t))return!1;return!0}function zI(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new vI(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function BI(e,t,n=0,r=1/0){return NI(n>=0),NI(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every((e=>typeof e===t))}function WI(e,t){Array.isArray(e)?(Sa.assert(e.length>0,(()=>`${t} is unexpectedly an empty array.`)),e.forEach(((e,n)=>WI(e,`element ${n+1} of ${t}`)))):Sa.assert(Number.isInteger(e)&&e>0,(()=>`Expected ${t} to be a positive integer, but got ${UI(e)}.`))}function UI(e){return null===e?"null":Array.isArray(e)?"["+e.map((e=>UI(e))).join(",")+"]":"string"==typeof e?`"${e}"`:`${e}`}function VI(e,t,n){let r,a=null!=n?n():Sa.now();return(...s)=>{let i=null!=n?n():Sa.now();return i-a<t||(a=i,r=e(...s)),r}}function GI(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}var HI=0;function jI(){return HI++}var qI={};function KI(e=""){return e in qI||(qI[e]=0),qI[e]+=1,e+qI[e].toString()}var XI=["channelsFirst","channelsLast"],JI=["nearest","bilinear"],YI=["valid","same","causal"],ZI=["max","avg"],QI=["sum","mul","concat","ave"],eS=new Map;function tS(e){zI(XI,"DataFormat",e)}function nS(e){zI(JI,"InterpolationFormat",e)}function rS(e){zI(YI,"PaddingMode",e)}function aS(e){zI(ZI,"PoolMode",e)}var sS=[],iS="/";function oS(e,t){sS.push(e);try{let e=t();return sS.pop(),e}catch(n){throw sS.pop(),n}}function lS(){return 0===sS.length?"":sS.join(iS)+iS}function uS(e){if(!hS(e))throw new Error("Not a valid tensor name: '"+e+"'");return lS()+e}function pS(e){if(!hS(e))throw new Error("Not a valid tensor name: '"+e+"'");eS.has(e)||eS.set(e,0);let t=eS.get(e);if(eS.set(e,eS.get(e)+1),t>0){let n=`${e}_${t}`;return eS.set(n,1),n}return e}var cS,dS=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function hS(e){return!!e.match(dS)}function fS(e){return e===parseInt(e.toString(),10)}function mS(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let r=1;for(let a=t;a<n;++a)r*=e[a];return r}function gS(e){if(0===e.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r<t&&(t=r)}return t}function yS(e){if(0===e.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r>t&&(t=r)}return t}function bS(e,t){if(t<e)throw new vI(`end (${t}) < begin (${e}) is forbidden.`);let n=[];for(let r=e;r<t;++r)n.push(r);return n}function xS(){return null==cS&&(cS=Ho().epsilon()),cS}function vS(){return"channelsLast"}function wS(e,t){return wo(e,t)}function kS(e,t=-1){let n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),ql(e,n)}function IS(e,t){return Do((()=>{if(2!==e.shape.length)throw new vI(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);let n=kS(e,1);return $S(n,[1,t,1])}))}function SS(e){let t=[mS(e.shape)];return ql(e,t)}function NS(e){if(e.rank<=1)throw new vI(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);let t=[e.shape[0],mS(e.shape,1)];return ql(e,t)}function TS(e,t,n){return Do((()=>{switch(e.rank){case 1:return Vf(e,t,n);case 2:return Hf(e,[t,0],[n,e.shape[1]]);case 3:return qf(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return Xf(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return su(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return su(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new vI(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function _S(e,t,n){return Do((()=>{switch(e.rank){case 1:return Vf(e,t,n);case 2:return Hf(e,[0,t],[e.shape[0],n]);case 3:return qf(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return Xf(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new vI(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function CS(e,t,n,r){return Do((()=>{switch(e.rank){case 1:return Vf(e,t,n);case 2:switch(r){case 1:return TS(e,t,n);case 2:return _S(e,t,n);default:throw new vI(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return TS(e,t,n);case 2:return qf(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return _S(e,t,n);default:throw new vI(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return TS(e,t,n);case 2:return Xf(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return Xf(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return _S(e,t,n);default:throw new vI(`The axis is not within the rank of the tensor ${r}`)}default:throw new vI(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function ES(e,t=-1){let n;return t<0&&(n=e[0].rank,t=0!==n?n:0),t===e[0].rank&&(t=-1),Ql(e,t)}function AS(e,t){switch(e.rank){case 1:return Fu([e,t]);case 2:return Mu([e,t],0);case 3:return Pu([e,t],0);case 4:return zu([e,t],0);default:throw new vI(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function $S(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new vI(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return yc(e,t)}function RS(e,t=0,n=1,r,a){return tf(e,t,n,r,a)}function FS(e,t,n,r){if(e.rank<2||t.rank<2)throw new wI(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){let n=e.shape.slice(-1)[0],r=t.shape.slice(-2)[0];if(n!==r)throw new wI(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(2===e.rank&&2===t.rank)return hg.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?OS(e.rank,r,vS()):null,activation:n});{let a=e.shape.slice(),s=a.pop();e=ql(e,[-1,s]);let i=t.shape.slice(),o=i.pop(),l=i.pop(),u=[...i,o],p=Array.from({length:t.rank},((e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n));t=ql(Jm(t,p),[l,-1]);let c=[...a,...u],d=!1,h=!1;return ql(hg.matMul({a:e,b:t,transposeA:d,transposeB:h,bias:r?OS(e.rank,r,vS()):null,activation:n}),c)}}function DS(e,t,n){return Do((()=>(t=Array.isArray(t)?vm(t,"int32"):wo(t,"int32"),Ic(e,t,n))))}function MS(e){return el(e,e)}function OS(e,t,n){let r=t.shape;if(1!==t.rank&&t.rank!==e)throw new vI(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(5===e){if("channelsFirst"===n)return 1===r.length?ql(t,[1,r[0],1,1,1]):ql(t,[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return 1===r.length?ql(t,[1,1,1,1,r[0]]):ql(t,[1].concat(r))}else if(4===e){if("channelsFirst"===n)return 1===r.length?ql(t,[1,r[0],1,1]):ql(t,[1,r[2],r[0],r[1]]);if("channelsLast"===n)return 1===r.length?ql(t,[1,1,1,r[0]]):ql(t,[1].concat(r))}else if(3===e){if("channelsFirst"===n)return 1===r.length?ql(t,[1,r[0],1]):ql(t,[1,r[1],r[0]]);if("channelsLast"===n)return 1===r.length?ql(t,[1,1,r[0]]):ql(t,[1].concat(r))}else if(e<3)return t;throw new vI(`Unsupported input rank by biasAdd: ${t.rank}`)}function PS(e,t,n){return Do((()=>(null==n&&(n=vS()),tS(n),Ko(e,OS(e.rank,t,n)))))}function LS(e,t=1){if(1!==t)throw new wI(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return Mp(e)}function zS(e){return Do((()=>Zo(e,Ko(nl(e),1))))}function BS(e,t,n,r){return Do((()=>lg(e,t,n,r)))}function WS(e){return Do((()=>{let t=Ko(.5,el(.2,e));return $u(t,0,1)}))}function US(e,t,n=!1){return n?e():t()}var VS=["fanIn","fanOut","fanAvg"],GS=["normal","uniform","truncatedNormal"];function HS(e){zI(VS,"FanMode",e)}function jS(e){zI(GS,"Distribution",e)}var qS=class extends kb.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},KS=class extends qS{apply(e,t){return Od(e,t)}};KS.className="Zeros",kb.registerClass(KS);var XS=class extends qS{apply(e,t){return Pd(e,t)}};XS.className="Ones",kb.registerClass(XS);var JS=class extends qS{constructor(e){if(super(),"object"!=typeof e)throw new vI(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new vI(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return Do((()=>el(Zp(this.value),Pd(e,t))))}getConfig(){return{value:this.value}}};JS.className="Constant",kb.registerClass(JS);var YS=class extends qS{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return sf(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};YS.className="RandomUniform",kb.registerClass(YS);var ZS=class extends qS{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32","float32"!==t&&"int32"!==t)throw new wI(`randomNormal does not support dType ${t}.`);return RS(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};ZS.className="RandomNormal",kb.registerClass(ZS);var QS=class extends qS{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32","float32"!==t&&"int32"!==t)throw new wI(`truncatedNormal does not support dType ${t}.`);return Mm(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};QS.className="TruncatedNormal",kb.registerClass(QS);var eN=class extends qS{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return Do((()=>{if(2!==e.length||e[0]!==e[1])throw new vI("Identity matrix initializer can only be used for 2D square matrices.");return el(this.gain,xc(e[0]))}))}getConfig(){return{gain:this.gain}}};function tN(e,t="channelsLast"){let n,r;if(tS(t),2===e.length)n=e[0],r=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===t){let t=mS(e,2);n=e[1]*t,r=e[0]*t}else if("channelsLast"===t){let t=mS(e,0,e.length-2);n=e[e.length-2]*t,r=e[e.length-1]*t}}else{let t=mS(e);n=Math.sqrt(t),r=Math.sqrt(t)}return[n,r]}eN.className="Identity",kb.registerClass(eN);var nN=class extends qS{constructor(e){if(super(),e.scale<0)throw new vI(`scale must be a positive float. Got: ${e.scale}`);this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,HS(this.mode),this.distribution=null==e.distribution?"normal":e.distribution,jS(this.distribution),this.seed=e.seed}apply(e,t){let n=tN(e),r=n[0],a=n[1],s=this.scale;if("fanIn"===this.mode?s/=Math.max(1,r):"fanOut"===this.mode?s/=Math.max(1,a):s/=Math.max(1,(r+a)/2),"normal"===this.distribution){let n=Math.sqrt(s);if(t=t||"float32","float32"!==t&&"int32"!==t)throw new wI(`${this.getClassName()} does not support dType ${t}.`);return Mm(e,0,n,t,this.seed)}{let n=Math.sqrt(3*s);return sf(e,-n,n,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};nN.className="VarianceScaling",kb.registerClass(nN);var rN=class extends nN{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return nN.className}};rN.className="GlorotUniform",kb.registerClass(rN);var aN=class extends nN{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return nN.className}};aN.className="GlorotNormal",kb.registerClass(aN);var sN=class extends nN{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return nN.className}};sN.className="HeNormal",kb.registerClass(sN);var iN=class extends nN{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return nN.className}};iN.className="HeUniform",kb.registerClass(iN);var oN=class extends nN{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return nN.className}};oN.className="LeCunNormal",kb.registerClass(oN);var lN=class extends nN{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return nN.className}};lN.className="LeCunUniform",kb.registerClass(lN);var uN=class extends qS{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return Do((()=>{if(e.length<2)throw new wI("Shape must be at least 2D.");if("int32"!==t&&"float32"!==t&&void 0!==t)throw new TypeError(`Unsupported data type ${t}.`);let n=Sa.sizeFromShape(e.slice(0,-1)),r=e[e.length-1],a=n*r;a>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${a}) elements: Slowness may result.`);let s=[Math.max(r,n),Math.min(r,n)],i=RS(s,0,1,t,this.seed),o=bb.qr(i,!1),l=o[0],u=o[1].flatten().stridedSlice([0],[Math.min(r,n)*Math.min(r,n)],[Math.min(r,n)+1]);return l=el(l,u.sign()),n<r&&(l=l.transpose()),el(Zp(this.gain),l.reshape(e))}))}getConfig(){return{gain:this.gain,seed:this.seed}}};uN.className="Orthogonal",kb.registerClass(uN);var pN={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function cN(e,t={}){return DI(e,kb.SerializationMap.getMap().classNameMap,t,"initializer")}function dN(e){return RI(e)}function hN(e){if("string"==typeof e){let t=e in pN?pN[e]:e;if("GlorotNormal"===t)return new aN;if("GlorotUniform"===t)return new rN;if("HeNormal"===t)return new sN;if("HeUniform"===t)return new iN;if("LeCunNormal"===t)return new oN;if("LeCunUniform"===t)return new lN;{let e={};return e.className=t,e.config={},cN(e)}}return e instanceof qS?e:cN(e)}function fN(e){return Array.isArray(e)&&Array.isArray(e[0])}function mN(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function gN(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new vI(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function yN(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return e[0];throw new vI(`Expected exactly 1 Shape; got ${e.length}`)}return e}function bN(e){let t=0;for(let n of e)0===n.shape.length?t+=1:t+=n.shape.reduce(((e,t)=>e*t));return t}var xN="Variable",vN=class{constructor(e,t="float32",n=xN,r=!0,a=null){this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=jI(),n=null==n?xN:n,this.originalName=uS(n),this.name=pS(this.originalName),this.trainable_=r,this.constraint=a,this.val=Vm(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),wN(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}};function wN(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}function kN(e){return e.map((e=>e.read()))}function IN(e){e.forEach((e=>{e[0].write(e[1])}))}var SN=class{constructor(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}},NN=class{constructor(e,t,n,r,a,s,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=a,this.outputTensorIndex=i,this.id=jI(),null!=s&&(this.originalName=uS(s),this.name=pS(this.originalName)),this.rank=t.length}},TN=0,_N=class{constructor(e,t){this.callArgs=t,this.id=TN++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(let n of e.inboundLayers)null!=n&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){let e=[];for(let t of this.inboundLayers)null!=t?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},CN=0,EN=class extends kb.Serializable{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=CN++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){let e=this.getClassName();t=EI(e)+"_"+KI(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}null!=e.weights?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new xI(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new vI(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return _I(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return _I(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new bI(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new bI(`Layer ${this.name} is not connected, no input to return.`);return _I(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new bI(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new bI(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return _I(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((e=>e()))}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach((t=>t.trainable=e)),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((e=>e.trainable)):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((e=>!e.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){if(e=CI(e),null==this.inputSpec||0===this.inputSpec.length)return;let t=CI(this.inputSpec);if(e.length!==t.length)throw new vI(`Layer ${this.name} expects ${t.length} inputs, but it received ${e.length} input tensors. Input received: ${e}`);for(let n=0;n<e.length;n++){let r=e[n],a=t[n];if(null==a)continue;let s=r.rank;if(null!=a.ndim&&s!==a.ndim)throw new vI(`Input ${n} is incompatible with layer ${this.name}: expected ndim=${a.ndim}, found ndim=${s}`);if(null!=a.maxNDim&&s>a.maxNDim)throw new vI(`Input ${n} is incompatible with layer ${this.name}: expected max_ndim=${a.maxNDim}, found ndim=${s}`);if(null!=a.minNDim&&s<a.minNDim)throw new vI(`Input ${n} is incompatible with layer ${this.name}: expected min_ndim=${a.minNDim}, found ndim=${s}.`);if(null!=a.dtype&&r.dtype!==a.dtype)throw new vI(`Input ${n} is incompatible with layer ${this.name} : expected dtype=${a.dtype}, found dtype=${r.dtype}.`);if(a.axes){let e=r.shape;for(let t in a.axes){let r=Number(t),s=a.axes[t],i=r>=0?e[r]:e[e.length+r];if(null!=s&&-1===[s,null].indexOf(i))throw new vI(`Input ${n} is incompatible with layer ${this.name}: expected axis ${r} of input shape to have value ${s} but got shape ${e}.`)}}if(null!=a.shape)for(let e=0;e<a.shape.length;++e){let t=a.shape[e],s=r.shape[e];if(null!=t&&null!=s&&t!==s)throw new vI(`Input ${n} is incompatible with layer ${this.name}: expected shape=${a.shape}, found shape=${r.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();let n=CI(e),r=!0;for(let s of n)if(!(s instanceof NN)){r=!1;break}let a=!0;for(let s of n)if(s instanceof NN){a=!1;break}if(r===a)throw new vI("Arguments to apply() must be all SymbolicTensors or all Tensors");return oS(this.name,(()=>{if(!this.built){this.assertInputCompatibility(e);let t=[];for(let n of CI(e))t.push(n.shape);this.build(_I(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&a&&(this._refCount=1)}if(this.assertInputCompatibility(e),a){let r=this.call(e,t),a=CI(r),s=[];for(let e of a)-1!==n.indexOf(e)&&(e=e.clone()),s.push(e);if(r=_I(s),null!=this.activityRegularizer)throw new wI("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}{let n,r=AN(e),a=this.computeOutputShape(r),s=$N(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?r[0]:r),n=null!=a&&a.length>0&&Array.isArray(a[0])?a.map(((n,r)=>new NN(s,n,this,CI(e),t,this.name,r))):new NN(s,a,this,CI(e),t,this.name),this.addInboundNode(e,n,null,null,r,a,t),this._refCount++,null!=this.activityRegularizer)throw new wI("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return n}}))}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach(((n,r)=>{null!=n&&null!=e[r]&&e[r]!==n&&(t=!0)})),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new bI(`The layer ${this.name} has never been called and thus has no defined output shape.`);let e=[];for(let t of this.inboundNodes){let n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){let e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new bI(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new xI(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return bN(this.weights)}build(e){this.built=!0}getWeights(e=!1){return kN(e?this.trainableWeights:this.weights)}setWeights(e){Do((()=>{let t=this.weights;if(t.length!==e.length)throw new vI(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(0===t.length)return;let n=[],r=kN(t);for(let a=0;a<r.length;++a){let s=r[a],i=t[a],o=e[a];if(!Sa.arraysEqual(s.shape,o.shape))throw new vI(`Layer weight shape ${s.shape} not compatible with provided weight shape ${o.shape}`);n.push([i,o])}IN(n)}))}addWeight(e,t,n,r,a,s,i,o){if(-1!==this._addedWeightNames.indexOf(e))throw new vI(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=null!=o?o():hN("zeros"));let l=r.apply(t,n),u=new vN(l,n,e,s,i);return l.dispose(),null!=a&&this.addLoss((()=>a.apply(u.read()))),null==s&&(s=!0),s?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=CI(e),void 0!==this._losses&&null!==this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);t.forEach((e=>{if(null!=e)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)}))}return null}return t}addInboundNode(e,t,n,r,a,s,i=null){let o=CI(e);t=CI(t),n=CI(n),r=CI(r),a=mN(a),s=mN(s);let l=[],u=[],p=[];for(let c of o)l.push(c.sourceLayer),u.push(c.nodeIndex),p.push(c.tensorIndex);new _N({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:p,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:a,outputShapes:s},i);for(let c=0;c<t.length;c++)t[c].sourceLayer=this,t[c].nodeIndex=this.inboundNodes.length-1,t[c].tensorIndex=c}getConfig(){let e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach((e=>e.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return 0===--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}};function AN(e){e=CI(e);let t=[];for(let n of e)t.push(n.shape);return _I(t)}function $N(e){return"float32"}function RN(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];{let e=t.inboundNodes[n];if(0===e.inboundLayers.length)return e.inputTensors;{let t=[];for(let n=0;n<e.inboundLayers.length;n++){let r=e.inputTensors[n],a=e.inboundLayers[n],s=e.nodeIndices[n],i=RN(r,a,s);for(let e of i)-1===t.indexOf(e)&&t.push(e)}return t}}}var FN=class extends EN{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:KI("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new vI("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new vI("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new vI("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];let r=new NN(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new _N({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new vI(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};function DN(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new vI("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;return null==n&&(n="float32"),new FN({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}function MN(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return wo(t,e.dtype)}catch(n){throw new vI(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}FN.className="InputLayer",kb.registerClass(FN);var ON=class{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof ON)for(let t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(null==e)return;for(let t of e)this.add(t.key,t.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new vI(`Duplicate key: name=${e.name}, id=${e.id}`);return this.id2Value[e.id]=MN(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof NN){if(null==this.id2Value[e.id])throw new vI(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}{let t=this.name2Id[e];if(null==t)throw new vI(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof NN){if(null==this.id2Value[e.id])throw new vI(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}{let t=this.name2Id[e];if(null==t)throw new vI(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&Mo(this.id2Mask)}},PN=new II,LN=new II;function zN(e){null!=PN&&PN.setMaxEntries(e),null!=LN&&LN.setMaxEntries(e)}function BN(e,t,n,r){let a=null!=n&&n.training,s=Array.isArray(e),i=s?e:[e],o=i.map((e=>e.name)),l=[],u=t.names();for(let f of o)-1!==u.indexOf(f)?l.push(t.getValue(f)):l.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);let p,c=o.join(",")+"|"+t.names().sort().join(","),d=PN.get(c);if(null==d){let e=WN(i,t);d=e.sorted,p=e.recipientCounts,PN.put(c,d),LN.put(c,p)}p={},a||Object.assign(p,LN.get(c));let h=new ON(t);for(let f=0;f<d.length;++f){if(null!=r){let e=Ro().numTensors;e>r.maxNumTensors&&(r.maxNumTensors=e),e<r.minNumTensors&&(r.minNumTensors=e)}let e=d[f],s=e.sourceLayer;if(s instanceof FN)continue;let i=[],u=[],c=[],m=!1;for(let n of e.inputs){let e=h.getValue(n),r=h.getMask(n);i.push(e),u.push(r),null!=r&&(m=!0),a||(p[n.name]--,0===p[n.name]&&!t.hasKey(n)&&-1===o.indexOf(n.name)&&!e.isDisposed&&!0!==n.sourceLayer.stateful&&c.push(e))}m&&(n=n||{},n.mask=u[0]);let g=CI(s.apply(i,n)),y=null;s.supportsMasking&&(y=s.computeMask(i,u));let b=GN(e),x=Array.isArray(b)?b:[b];for(let t=0;t<x.length;++t){h.hasKey(x[t])||h.add(x[t],g[t],Array.isArray(y)?y[0]:y);let e=o.indexOf(x[t].name);-1!==e&&(l[e]=g[t])}a||Mo(c)}return h.disposeMasks(),s?l:l[0]}function WN(e,t){Sa.assert(null!=e&&e.length>0,(()=>"Expected at least one fetch, got none"));let n=[],r={};if(1===e.length){let a=VN(e[0],t);n=a.sorted,r=a.recipientMap}else{let a=new Set;for(let s of e){let{sorted:e,recipientMap:i}=VN(s,t);for(let t of e)a.has(t.name)||(n.push(t),a.add(t.name));for(let t in i)null==r[t]&&(r[t]=new Set),i[t].forEach((e=>r[t].add(e)))}}return{sorted:n,recipientCounts:UN(r)}}function UN(e){let t={};for(let n in e)t[n]=e[n].size;return t}function VN(e,t){let n=new Set,r=[],a={};for(let o of t.names())n.add(o);let s=[],i=[];for(s.push(e);s.length>0;){let e=s[s.length-1];if(n.has(e.name)){s.pop();continue}let t=i[i.length-1]===s.length-1;if(0===e.inputs.length||t)s.pop(),r.push(e),n.add(e.name),t&&i.pop();else{i.push(s.length-1);for(let t of e.inputs)null==a[t.name]&&(a[t.name]=new Set),a[t.name].add(e.name),!n.has(t.name)&&s.push(t)}}return{sorted:r,recipientMap:a}}function GN(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(let r of e.sourceLayer.inboundNodes[t].outputTensors)if(r.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}var HN=We();HN.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),zN);var jN={};function qN(e,t){return Do((()=>ec(ac(el(e,e),t,!0))))}g(jN,{maxNorm:()=>rT,minMaxNorm:()=>iT,nonNeg:()=>sT,unitNorm:()=>aT});var KN=class extends kb.Serializable{getConfig(){return{}}},XN=class extends KN{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Do((()=>{let t=qN(e,this.axis),n=$u(t,0,this.maxValue);return el(e,Zo(n,Ko(xS(),t)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};XN.className="MaxNorm",kb.registerClass(XN);var JN=class extends KN{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Do((()=>Zo(e,Ko(xS(),qN(e,this.axis)))))}getConfig(){return{axis:this.axis}}};JN.className="UnitNorm",kb.registerClass(JN);var YN=class extends KN{apply(e){return hf(e)}};YN.className="NonNeg",kb.registerClass(YN);var ZN=class extends KN{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Do((()=>{let t=qN(e,this.axis),n=Ko(el(this.rate,$u(t,this.minValue,this.maxValue)),el(1-this.rate,t));return el(e,Zo(n,Ko(xS(),t)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};ZN.className="MinMaxNorm",kb.registerClass(ZN);var QN={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function eT(e){return RI(e)}function tT(e,t={}){return DI(e,kb.SerializationMap.getMap().classNameMap,t,"constraint")}function nT(e){if(null==e)return null;if("string"==typeof e){let t={className:e in QN?QN[e]:e,config:{}};return tT(t)}return e instanceof KN?e:tT(e)}function rT(e){return new XN(e)}function aT(e){return new JN(e)}function sT(){return new YN}function iT(e){return new ZN(e)}var oT={};function lT(){return new KS}function uT(){return new XS}function pT(e){return new JS(e)}function cT(e){return new YS(e)}function dT(e){return new ZS(e)}function hT(e){return new QS(e)}function fT(e){return new eN(e)}function mT(e){return new nN(e)}function gT(e){return new rN(e)}function yT(e){return new aN(e)}function bT(e){return new sN(e)}function xT(e){return new iN(e)}function vT(e){return new oN(e)}function wT(e){return new lN(e)}function kT(e){return new uN(e)}g(oT,{constant:()=>pT,glorotNormal:()=>yT,glorotUniform:()=>gT,heNormal:()=>bT,heUniform:()=>xT,identity:()=>fT,leCunNormal:()=>vT,leCunUniform:()=>wT,ones:()=>uT,orthogonal:()=>kT,randomNormal:()=>dT,randomUniform:()=>cT,truncatedNormal:()=>hT,varianceScaling:()=>mT,zeros:()=>lT});var IT,ST={};async function NT(e){if(null==e)return;let t=[],n=[],r=[];for(let a in e){let s=e[a];if("number"!=typeof s){let e=s;t.push(e.data()),n.push(a),r.push(e)}}if(t.length>0){let a=await Promise.all(t);for(let t=0;t<a.length;++t)e[n[t]]=a[t][0];Mo(r)}}function TT(e){if(null!=e)for(let t in e){let n=e[t];"number"!=typeof n&&n.dispose()}}g(ST,{Layer:()=>EN,RNN:()=>IE,RNNCell:()=>SE,activation:()=>o$,add:()=>g$,alphaDropout:()=>iR,average:()=>y$,averagePooling1d:()=>T$,averagePooling2d:()=>E$,averagePooling3d:()=>R$,avgPool1d:()=>_$,avgPool2d:()=>A$,avgPool3d:()=>F$,avgPooling1d:()=>C$,avgPooling2d:()=>$$,avgPooling3d:()=>D$,batchNormalization:()=>I$,bidirectional:()=>Z$,categoryEncoding:()=>cR,centerCrop:()=>uR,concatenate:()=>b$,conv1d:()=>ZA,conv2d:()=>QA,conv2dTranspose:()=>e$,conv3d:()=>t$,conv3dTranspose:()=>n$,convLstm2d:()=>K$,convLstm2dCell:()=>X$,cropping2D:()=>a$,dense:()=>l$,depthwiseConv2d:()=>i$,dot:()=>k$,dropout:()=>u$,elu:()=>jA,embedding:()=>m$,flatten:()=>c$,gaussianDropout:()=>sR,gaussianNoise:()=>aR,globalAveragePooling1d:()=>M$,globalAveragePooling2d:()=>O$,globalMaxPool1d:()=>eR,globalMaxPool2d:()=>tR,globalMaxPooling1d:()=>P$,globalMaxPooling2d:()=>L$,gru:()=>U$,gruCell:()=>V$,input:()=>xC,inputLayer:()=>HA,layerNormalization:()=>S$,leakyReLU:()=>KA,lstm:()=>G$,lstmCell:()=>H$,masking:()=>oR,maxPool1d:()=>nR,maxPool2d:()=>rR,maxPooling1d:()=>z$,maxPooling2d:()=>B$,maxPooling3d:()=>W$,maximum:()=>x$,minimum:()=>v$,multiply:()=>w$,permute:()=>f$,prelu:()=>XA,reLU:()=>qA,repeatVector:()=>d$,rescaling:()=>lR,reshape:()=>h$,resizing:()=>pR,rnn:()=>J$,separableConv2d:()=>r$,simpleRNN:()=>j$,simpleRNNCell:()=>q$,softmax:()=>JA,spatialDropout1d:()=>p$,stackedRNNCells:()=>Y$,thresholdedReLU:()=>YA,timeDistributed:()=>Q$,upSampling2d:()=>s$,zeroPadding2d:()=>N$}),function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(IT||(IT={}));var _T=125,CT=class{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}},ET=class{constructor(e,t=10){null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(let t of this.callbacks)t.setParams(e)}setModel(e){for(let t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){null==t&&(t={});for(let n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){null==t&&(t={});for(let n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){null==t&&(t={});for(let n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){null==t&&(t={});for(let n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){null==e&&(e={});for(let t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){null==e&&(e={});for(let t of this.callbacks)await t.onTrainEnd(e)}},AT=class extends CT{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){null==t&&(t={});let n=null==t.size?0:t.size;this.seen+=n;for(let r in t){let e=t[r];if("number"==typeof e)this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+e*n;else{let t;r in this.totals?t=this.totals[r]:this.totals[r]=0;let a=Do((()=>Ko(this.totals[r],el(e,n))));this.totals[r]=a,null!=t&&t.dispose()}}}async onEpochEnd(e,t){if(null!=t)for(let n of this.params.metrics)null!=this.totals[n]&&("number"==typeof this.totals[n]?t[n]=this.totals[n]/this.seen:Do((()=>{let e=el(Zo(1,this.seen),this.totals[n]);t[n]=e,this.totals[n].dispose(),Oo(t[n])})))}},$T=class extends CT{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){null==t&&(t={}),this.epoch.push(e);for(let n in t)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){let e=[],t=[],n=[];for(let a in this.history){let r=this.history[a];for(let s=0;s<r.length;++s)if("number"!=typeof r[s]){let i=r[s];e.push(i.data()),t.push(a),n.push(s)}}let r=await Promise.all(e);for(let a=0;a<r.length;++a)this.history[t[a]][n[a]].dispose(),this.history[t[a]][n[a]]=r[a][0]}},RT=class extends CT{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||Yx,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=_T),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");Sa.isNumber(this.yieldEvery)&&(this.maybeWait=VI(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){let r=[];null!=this.yield&&(await NT(n),r.push(this.yield(e,t,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,null!=this.epochBegin&&(await NT(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){let n=[];null!=this.epochEnd&&(await NT(t),n.push(this.epochEnd(e,t))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){null!=this.batchBegin&&(await NT(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){let n=[];null!=this.batchEnd&&(await NT(t),n.push(this.batchEnd(e,t))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):Sa.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){null!=this.trainBegin&&(await NT(e),await this.trainBegin(e))}async onTrainEnd(e){null!=this.trainEnd&&(await NT(e),await this.trainEnd(e))}};function FT(e,t){return null==e&&(e={}),e instanceof CT?[e]:Array.isArray(e)&&e[0]instanceof CT?e:CI(e).map((e=>new RT(e,t)))}var DT=class{constructor(){}static registerCallbackConstructor(e,t){Sa.assert(e>=0&&Number.isInteger(e),(()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`)),DT.checkForDuplicate(t),null==DT.constructors[e]&&(DT.constructors[e]=[]),DT.constructors[e].push(t)}static checkForDuplicate(e){for(let t in DT.constructors)DT.constructors[+t].forEach((t=>{if(t===e)throw new vI("Duplicate callback constructor.")}))}static clear(){DT.constructors={}}static createCallbacks(e){let t=[];for(let n in DT.constructors){let r=+n;e>=r&&t.push(...DT.constructors[r])}return t.map((e=>new e))}};function MT(e,t,n,r,a,s,i,o,l){let u=new $T,p=[new AT,...DT.createCallbacks(t)];null!=e&&p.push(...e),p.push(u);let c=new ET(p);return c.setParams({epochs:n,initialEpoch:r,samples:a,steps:s,batchSize:i,verbose:t,doValidation:o,metrics:l}),{callbackList:c,history:u}}function OT(e,t={},n=!1){return DI(e,kb.SerializationMap.getMap().classNameMap,t,"layer",n)}function PT(e,t){return Do((()=>{"float32"!==e.dtype&&(e=wo(e,"float32"));let n=ac(MS(e),t,!0),r=Eu(n.shape,xS()),a=ec(Fd(n,r));return Zo(e,a)}))}function LT(e,t){return Do((()=>Md(MS(ud(t,e)),-1)))}function zT(e,t){return Do((()=>Md(nl(ud(t,e)),-1)))}function BT(e,t){return Do((()=>{let n=ud(e,t),r=$u(nl(e),xS(),Number.MAX_VALUE),a=nl(Zo(n,r));return el(100,Md(a,-1))}))}function WT(e,t){return Do((()=>{let n=$u(t,xS(),Number.MAX_VALUE),r=jc(Ko(1,n)),a=$u(e,xS(),Number.MAX_VALUE),s=jc(Ko(1,a));return Md(MS(ud(r,s)),-1)}))}function UT(e,t){return Do((()=>{let n=Fd(0,ud(1,el(e,t)));return Md(MS(n),-1)}))}function VT(e,t){return Do((()=>{let n=Fd(0,ud(1,el(e,t)));return Md(n,-1)}))}function GT(e,t){return Do((()=>{let n=ac(el(e,t),-1),r=qp(el(ud(1,e),t),-1);return Fd(0,Ko(1,ud(r,n)))}))}function HT(e,t){return Do((()=>{let n=Math.log(2),r=ud(t,e),a=ud(Ko(r,sd(el(-2,r))),n);return Md(a,-1)}))}function jT(e,t,n=!1){return Do((()=>{if(n)t=Yf(t);else{let e=ac(t,t.shape.length-1,!0);t=Zo(t,e)}return t=$u(t,xS(),1-xS()),rd(ac(el(wo(e,"float32"),jc(t)),t.shape.length-1))}))}function qT(e,t,n=!1){return Do((()=>{let r=wo(wc(SS(e)),"int32");t=$u(t,xS(),1-xS());let a=t.shape,s=ql(eh(r,a[a.length-1]),a);return jT(s,t,n)}))}function KT(e,t){if(!Sa.arraysEqual(e.shape,t.shape))throw new vI(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return Do((()=>{let n=hf(t),r=rd(nl(t));return Ko(ud(n,el(t,e)),Kc(cc(r)))}))}function XT(e,t){return Do((()=>{let n;return n=$u(t,xS(),1-xS()),n=jc(Zo(n,ud(1,n))),Md(KT(e,n),-1)}))}function JT(e,t){return Do((()=>{let n=$u(e,xS(),1),r=$u(t,xS(),1);return ac(el(e,jc(Zo(n,r))),-1)}))}function YT(e,t){return Do((()=>{let n=jc(Ko(xS(),t));return Md(ud(t,el(e,n)),-1)}))}function ZT(e,t){return Do((()=>{let n=PT(e,-1),r=PT(t,-1),a=el(n,r);return rd(ac(a,-1))}))}DT.constructors={};var QT={meanSquaredError:LT,meanAbsoluteError:zT,meanAbsolutePercentageError:BT,meanSquaredLogarithmicError:WT,squaredHinge:UT,hinge:VT,categoricalHinge:GT,logcosh:HT,categoricalCrossentropy:jT,sparseCategoricalCrossentropy:qT,binaryCrossentropy:XT,kullbackLeiblerDivergence:JT,poisson:YT,cosineProximity:ZT};function e_(e){if("string"==typeof e){if(e in QT)return QT[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new vI(t)}return e}function t_(e,t){return Do((()=>{let n=el(.5,nh(t)),r=wS(Nc(t,n),e.dtype);return Md(Ip(e,r),-1)}))}function n_(e,t){return Do((()=>wS(Ip(fl(e,-1),fl(t,-1)),"float32")))}function r_(e,t){return Do((()=>wo(ac(md(Ip(e,1),Ip(t,1))),"float32")))}function a_(e,t){return Do((()=>wo(ac(md(Ip(e,1),Ip(t,0))),"float32")))}function s_(e,t){return Do((()=>wo(ac(md(Ip(e,0),Ip(t,1))),"float32")))}function i_(e,t){return Do((()=>{let n=r_(e,t),r=s_(e,t),a=Ko(n,r);return wo(Np(Nc(a,0),Zo(n,a),0),"float32")}))}function o_(e,t){return Do((()=>{let n=r_(e,t),r=a_(e,t),a=Ko(n,r);return wo(Np(Nc(a,0),Zo(n,a),0),"float32")}))}function l_(e,t){return XT(e,t)}function u_(e,t){return e.rank===t.rank&&(e=cm(e,[e.rank-1])),t=fl(t,-1),t.dtype!==e.dtype&&(t=wo(t,e.dtype)),wo(Ip(e,t),"float32")}var p_=LT,c_=LT,d_=zT,h_=zT,f_=BT,m_=BT,g_=jT,y_=ZT,b_=qT,x_={binaryAccuracy:t_,categoricalAccuracy:n_,precision:i_,categoricalCrossentropy:g_,sparseCategoricalCrossentropy:b_,mse:p_,MSE:c_,mae:d_,MAE:h_,mape:f_,MAPE:m_,cosine:y_};function v_(e){if("string"==typeof e&&e in x_)return x_[e];if("string"!=typeof e&&null!=e)return e;throw new vI(`Unknown metric ${e}`)}function w_(e){if(NI(null!==e,`Unknown LossOrMetricFn ${e}`),"string"==typeof e)return e;{let t;for(let n of Object.keys(QT))if(QT[n]===e){t=n;break}if(void 0!==t)return t;for(let n of Object.keys(x_))if(x_[n]===e){t=n;break}return void 0!==t?t:e.name}}function k_(e){let t={Adagrad:()=>Xx.adagrad(.01),Adadelta:()=>Xx.adadelta(1,.95,xS()),Adam:()=>Xx.adam(.001,.9,.999,xS()),Adamax:()=>Xx.adamax(.002,.9,.999,xS(),0),RMSProp:()=>Xx.rmsprop(.001,.9,0,xS()),SGD:()=>Xx.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new vI(`Unknown Optimizer ${e}`)}function I_(e,t,n=!1){if(null==e||"object"!=typeof e||Object.getPrototypeOf(e)!==Object.prototype||!S_(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){let n=JSON.stringify(e);n.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function S_(e){if(null===e)return!0;if("object"==typeof e){if(Object.getPrototypeOf(e)===Object.prototype){let t=Object.keys(e);for(let n of t)if("string"!=typeof n||!S_(e[n]))return!1;return!0}if(Array.isArray(e)){for(let t of e)if(!S_(t))return!1;return!0}return!1}{let t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function N_(e,t,n,r=console.log){let a,s=__(e),i=["Layer (type)","Input Shape","Output shape","Param #"];if(s?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map((e=>Math.floor(t*e)))),!s){i.push("Receives inputs"),a=[];for(let t in e.nodesByDepth)a.push(...e.nodesByDepth[t])}r("_".repeat(t)),C_(i,n,r),r("=".repeat(t));let o=e.layers;for(let p=0;p<o.length;++p)s?E_(o[p],n,r):A_(o[p],n,a,r),r((p===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();let l=T_(e),u=bN(e.nonTrainableWeights);r(`Total params: ${l+u}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${u}`),r("_".repeat(t))}function T_(e){let t;return t=null!=e.collectedTrainableWeights?bN(e.collectedTrainableWeights):bN(e.trainableWeights),t}function __(e){let t=!0,n=[],r=[];for(let a in e.nodesByDepth)n.push(e.nodesByDepth[a]);for(let a of n){if(a.length>1||1===a.length&&a[0].inboundLayers.length>1){t=!1;break}r.push(...a)}if(t)for(let a of e.layers){let e=!1;for(let n of a.inboundNodes)if(-1!==r.indexOf(n)){if(e){t=!1;break}e=!0}if(!t)break}return t}function C_(e,t,n=console.log){let r="";for(let a=0;a<e.length;++a)a>0&&(r=r.slice(0,r.length-1)+" "),r+=e[a],r=r.slice(0,t[a]),r+=" ".repeat(t[a]-r.length);n(r)}function E_(e,t,n){let r,a;try{a=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(l){a="multiple"}try{r=JSON.stringify(e.outputShape)}catch(l){r="multiple"}let s=e.name,i=e.getClassName(),o=[`${s} (${i})`,a,r,e.countParams().toString()];C_(o,t,n)}function A_(e,t,n,r){let a,s;try{s=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(c){s="multiple"}try{a=JSON.stringify(e.outputShape)}catch(c){a="multiple"}let i=[];for(let d of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(d)))for(let e=0;e<d.inboundLayers.length;++e){let t=d.inboundLayers[e].name,n=d.nodeIndices[e],r=d.tensorIndices[e];i.push(`${t}[${n}][${r}]`)}let o=e.name,l=e.getClassName(),u=0===i.length?"":i[0],p=[`${o} (${l})`,s,a,e.countParams().toString(),u];C_(p,t,r);for(let d=1;d<i.length;++d)C_(["","","","",i[d]],t,r)}function $_(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"==typeof n}function R_(e,t){if(null===e)return null;if("string"==typeof e)return AI(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){let n=[],r=e.length;for(let a=0;a<r;++a){let r=e[a];$_(t,a,r)?n.push(r):n.push(R_(r,t))}return n}{let t={};for(let n of Object.keys(e)){let r=e[n];if("name"===n&&"string"==typeof r)t[n]=r;else{let e=AI(n);t[e]=R_(r,e)}}return t}}function F_(e,t){if(null==e)return null;if("string"==typeof e)return EI(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){let n=[],r=e.length;for(let a=0;a<r;++a){let r=e[a];$_(t,a,r)?n.push(r):n.push(F_(r,t))}return n}{let t={};for(let n of Object.keys(e)){let r=e[n],a=EI(n);t[a]="name"!==n&&"className"!==n||"string"!=typeof r?F_(r,n):r}return t}}var D_="4.3.0",M_=class extends EN{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,null==this.name){let e=this.getClassName().toLowerCase();this.name=KI(e)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],PI(this.inputs).length!==this.inputs.length)throw new vI(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map((e=>e.name))}`);PI(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map((e=>e.name))}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let y of this.outputs){let e=y.sourceLayer,t=y.nodeIndex,n=y.tensorIndex;this.outputLayers.push(e),this.outputLayersNodeIndices.push(t),this.outputLayersTensorIndices.push(n)}for(let y of this.inputs){let e=y.sourceLayer,t=y.nodeIndex,n=y.tensorIndex;NI(0===t,"input layer has >1 nodes"),NI(0===n,"input layer has >1 tensors"),this.inputLayers.push(e),this.inputLayersNodeIndices.push(t),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let y=0;y<this.inputLayers.length;y++){let t=this.inputLayers[y];if(!(t instanceof FN))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${y} (0-based) originates from layer type ${t.getClassName()}.`);this.inputNames.push(t.name),this.feedInputShapes.push(t.batchInputShape),this.feedInputNames.push(t.name)}for(let y of this.outputLayers)this.outputNames.push(y.name);this.internalInputShapes=this.inputs.map((e=>e.shape)),this.internalOutputShapes=this.outputs.map((e=>e.shape));let t={},n={},r={},a={},s={},i=[],o=(e,t,n,r,a,l)=>{(null==r||null==a||null==l)&&(r=e.sourceLayer,a=e.nodeIndex,l=e.tensorIndex);let u=r.inboundNodes[a];if(-1!==n.indexOf(u))throw new xI(`The tensor ${e.name} at layer "${r.name}" is part of a cycle.`);if(-1!==t.indexOf(u))return;this.containerNodes.add(M_.nodeKey(r,a)),r.id in s||(s[r.id]=Object.keys(s).length),-1===n.indexOf(u)&&n.push(u);let p=u.inboundLayers.length;for(let s=0;s<p;s++){let e=u.inputTensors[s],r=u.inboundLayers[s],a=u.nodeIndices[s],i=u.tensorIndices[s];o(e,t,n,r,a,i)}for(t.push(u);n.indexOf(u)>=0;)n.splice(n.indexOf(u),1);i.push(u)},l=[],u=[];for(let y of this.outputs)o(y,l,u);let p=i.slice().reverse();for(let y of p){n[y.id]=y,y.id in t||(t[y.id]=0);let e=t[y.id],s=null==r[y.outboundLayer.id]?0:r[y.outboundLayer.id];e=Math.max(e,s),r[y.outboundLayer.id]=e,a[y.outboundLayer.id]=y.outboundLayer,t[y.id]=e;for(let r=0;r<y.inboundLayers.length;r++){let a=y.inboundLayers[r],s=y.nodeIndices[r],i=a.inboundNodes[s],o=null==t[i.id]?0:t[i.id];t[i.id]=Math.max(e+1,o),n[i.id]=i}}let c={};for(let y in t){let e=t[y];e in c||(c[e]=[]),c[e].push(n[y])}let d={};for(let y in r){let e=r[y];e in d||(d[e]=[]),d[e].push(a[y])}let h=Object.keys(d).map((e=>parseInt(e,10))).sort(OI);this.layers=[];for(let y of h){let e=d[y];e.sort(((e,t)=>{let n=s[e.id],r=s[t.id];return n<r?-1:n>r?1:0}));for(let t of e)t instanceof M_&&this.internalContainerRefs.push(t),this.layers.push(t)}this.layersByDepth=d,h=Object.keys(c).map((e=>parseInt(e,10))).sort(OI);let f=this.inputs.slice(),m=[];for(let y of h)for(let e of c[y]){let t=e.outboundLayer;if(null!=t){for(let n of e.inputTensors)if(-1===f.indexOf(n))throw new xI(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${t.name}". The following previous layers were accessed without issue: ${m}`);for(let t of e.outputTensors)f.push(t);m.push(t.name)}}this.nodesByDepth=c;let g=this.layers.map((e=>e.name));for(let y of g){let e=g.filter((e=>e===y)).length;if(1!==e)throw new xI(`The name "${y}" is used ${e} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new _N({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((e=>null)),outputMasks:this.outputs.map((e=>null)),inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs.map((e=>e.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let e={refCountAfterDispose:null,numDisposedVariables:0};if(0===--this._refCount){for(let t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(let t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach((t=>{t._trainableWeights.forEach((t=>t.trainable=e))})),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new vI("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(let t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){let n={},r=0;for(let s of this.layers)for(let e of s.weights){if(null!=n[e.originalName])throw new vI(`Duplicate weight name: ${e.originalName}`);n[e.originalName]=e,r++}let a=[];for(let s in e){let r=s;if(null==n[s]){let e=s.split("/");r=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[r])a.push([n[r],e[s]]);else if(t)throw new vI(`Provided weight data has no target variable: ${s}`);delete n[r]}if(t){let e=[];for(let t in n)e.push(t);if(e.length>0)throw new vI(`${e.length} of ${r} weights are not set: ${e}`)}IN(a)}updatedConfig(){let e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${D_}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){let n=F_(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return Do((()=>{e=CI(e);let n=new ON;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return BN(this.outputs,n,t)}))}computeMask(e,t){return Do((()=>{let n;return e=CI(e),n=null==t?SI(null,e.length):CI(t),this.runInternalGraph(e,n)[1]}))}computeOutputShape(e){let t=mN(e);if(t.length!==this.inputLayers.length)throw new vI(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);let n={};for(let i=0;i<t.length;i++){let e=this.inputLayers[i],r=t[i],a=e.name+"_0_0";n[a]=r}let r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(OI);if(r.length>1)for(let i of r){let e=this.nodesByDepth[i];for(let t of e){let e=t.outboundLayer;if(-1!==this.inputLayers.map((e=>e.id)).indexOf(e.id))continue;let r=[];for(let o=0;o<t.inboundLayers.length;o++){let e=t.inboundLayers[o],a=t.nodeIndices[o],s=t.tensorIndices[o],i=`${e.name}_${a}_${s}`,l=n[i];r.push(l)}let a=e.computeOutputShape(_I(r)),s=mN(a),i=e.inboundNodes.indexOf(t);for(let t=0;t<s.length;t++){let r=`${e.name}_${i}_${t}`;n[r]=s[t]}}}let a=[],s=[];for(let i=0;i<this.outputLayers.length;i++){let e=this.outputLayers[i],t=this.outputLayersNodeIndices[i],n=this.outputLayersTensorIndices[i],r=`${e.name}_${t}_${n}`;s.push(r)}for(let i=0;i<s.length;i++){let e=s[i];NI(e in n),a.push(n[e])}return _I(a)}runInternalGraph(e,t){null==t&&(t=SI(null,e.length));let n={};for(let o=0;o<this.inputs.length;++o){let r=this.inputs[o],a=e[o],s=t[o];n[r.id]=[a,s]}let r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(OI);for(let o of r){let e=this.nodesByDepth[o];for(let t of e){let e=t.outboundLayer,r=t.inputTensors,a=t.outputTensors,s=new Array;for(let t of r)t.id in n&&s.push(n[t.id]);if(s.length===r.length){let r,i,o,l,u={};if(null!=t.callArgs&&(u=t.callArgs),1===s.length){let[t,n]=s[0];null==u.mask&&(u.mask=n),o=CI(e.call(t,u)),l=CI(e.computeMask(t,n)),r=[t],i=[n]}else r=s.map((e=>e[0])),i=s.map((e=>e[1])),null==u.mask&&(u.mask=i),o=CI(e.call(r,u)),l=CI(e.computeMask(r,i));if(e.activityRegularizer)throw new wI("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<a.length;++e){let t=a[e],r=o[e],s=l[e];n[t.id]=[r,s]}}}}let a=[],s=[],i=[];for(let o of this.outputs){NI(o.id in n,`Could not compute output ${o.name} : ${o.id}`);let[e,t]=n[o.id];i.push(e.shape),a.push(e),s.push(t)}return[a,s,i]}buildNodeConversionMap(e){let t,n={};for(let r of this.layers){t=r instanceof M_?1:0;for(let e=0;e<r.inboundNodes.length;e++){let a=M_.nodeKey(r,e);this.containerNodes.has(a)&&(n[a]=t,t+=1)}}return n}getLayer(e,t){if(null!=t){if(this.layers.length<=t)throw new vI(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}if(null==e)throw new vI("Provide either a layer name or layer index");for(let n of this.layers)if(n.name===e)return n;throw new vI(`No such layer: ${e}`)}calculateLosses(){return Do((()=>{let e=[];for(let t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){let r=M_.nodeKey(t,n);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e}))}getConfig(){let e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(let i of this.layers){let e=i.getClassName(),r=i.getConfig(),a=[];for(let n=0;n<i.inboundNodes.length;n++){let e=i.inboundNodes[n],r=M_.nodeKey(i,n),o={};if(this.containerNodes.has(r)){if(e.callArgs)try{JSON.stringify(e.callArgs),o=e.callArgs}catch(s){console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${e.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),o={}}if(e.inboundLayers.length>0){let n=[];for(let r=0;r<e.inboundLayers.length;r++){let a=e.inboundLayers[r],s=e.nodeIndices[r],i=e.tensorIndices[r],l=M_.nodeKey(a,s),u=t[l];null==u&&(u=0),n.push([a.name,u,i,o])}a.push(n)}}}let o={};o.name=i.name,o.className=e,o.config=r,o.inboundNodes=a,n.push(o)}e.layers=n;let r=[];for(let i=0;i<this.inputLayers.length;i++){let e=this.inputLayers[i],n=this.inputLayersNodeIndices[i],a=M_.nodeKey(e,n);if(!this.containerNodes.has(a))continue;let s=t[a];null==s&&(s=0);let o=this.inputLayersTensorIndices[i];r.push([e.name,s,o])}e.inputLayers=r;let a=[];for(let i=0;i<this.outputLayers.length;i++){let e=this.outputLayers[i],n=this.outputLayersNodeIndices[i],r=M_.nodeKey(e,n);if(!this.containerNodes.has(r))continue;let s=t[r];null==s&&(s=0);let o=this.outputLayersTensorIndices[i];a.push([e.name,s,o])}return e.outputLayers=a,e}static fromConfig(e,t,n={},r=!1){let a={},s={};function i(e,t){e.name in s?s[e.name].push(t):s[e.name]=[t]}function o(e,t){let n,r=[];for(let s of t){let o=s[0],l=s[1],u=s[2];if(n=null==s[3]?{}:s[3],!(o in a))return void i(e,t);let p=a[o];if(p.inboundNodes.length<=l)return void i(e,t);let c=p.inboundNodes[l];r.push(c.outputTensors[u])}r.length>0&&e.apply(_I(r),n)}function l(e){let n=e.name,s=OT(e,null!=t.customObjects?t.customObjects:{});s.setFastWeightInitDuringBuild(r),a[n]=s,e.inboundNodes.forEach((e=>{if(!(e instanceof Array))throw new vI(`Corrupted configuration, expected array for nodeData: ${e}`);i(s,e)}))}let u=t.name,p=t.layers;for(let m of p)l(m);for(;!LI(s);)for(let e of p){let t=a[e.name];if(t.name in s){let e=s[t.name];delete s[t.name];for(let n of e)o(t,n)}}let c=[],d=[],h=t.inputLayers;for(let m of h){let e=m[0],t=m[1],n=m[2];NI(e in a);let r=a[e].inboundNodes[t].outputTensors;c.push(r[n])}let f=t.outputLayers;for(let m of f){let e=m[0],t=m[1],n=m[2];NI(e in a);let r=a[e].inboundNodes[t].outputTensors;d.push(r[n])}return new e({inputs:c,outputs:d,name:u})}get stateful(){if(this._stateful)throw new vI("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let e of this.layers)if(e.stateful)return!0;return!1}resetStates(){Do((()=>{this.layers.forEach((e=>{e.stateful&&e.resetStates()}))}))}};function O_(e,t,n){let r=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>null));if(1===r)return Array.isArray(e)&&1===e.length?e:"object"==typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}if("object"==typeof e&&Object.keys(e).length>0&&"object"==typeof e[Object.keys(e)[0]]){let n=[];return t.forEach((t=>{t in e?n.push(e[t]):n.push(null)})),n}throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}function P_(e,t){return O_(e,t,"classWeight")}async function L_(e,t,n,r){if(null!=t||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){let t=Do((()=>{if(1===e.shape.length)return Io(e);if(2===e.shape.length){if(e.shape[1]>1)return fl(e,1);if(1===e.shape[1])return ql(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)})),r=Array.from(await t.data());Mo(t);let a=[];return r.forEach((e=>{if(null==n[e])throw new Error(`classWeight must contain all classes in the training data. The class ${e} exists in the data but not in classWeight`);a.push(n[e])})),vm(a,"float32")}return null}function z_(e,t){return el(e,t)}var B_=32;function W_(e,t){let n,r,a=t;n=a.xs,r=a.ys,Sa.assert(null!=n&&null!=r,(()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`));let s=U_("input",e.inputNames,n),i=U_("output",e.outputNames,r),o=s[0].shape[0];Sa.assert(s.length===e.inputs.length,(()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`)),Sa.assert(i.length===e.outputs.length,(()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`));for(let l=0;l<s.length;l++)Sa.assert(s[l].shape[0]===o,(()=>`Batch size mismatch: input ${e.inputNames[l]} has ${s[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));for(let l=0;l<i.length;l++)Sa.assert(i[l].shape[0]===o,(()=>`Batch size mismatch: output ${e.outputNames[l]} has ${i[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));return{xs:s,ys:i}}function U_(e,t,n){if(n instanceof bs)return[n];if(Array.isArray(n))return Sa.assert(n.length===t.length,(()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`)),n;{let r=[];for(let a of t){if(null==n[a])throw new vI(`The feature data generated by the dataset lacks the required ${e} key '${a}'.`);r.push(n[a])}return r}}function V_(e){if(3===e.length)throw new wI("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}async function G_(e,t,n){let r=null!=n.batchesPerEpoch;if(Sa.assert(null!=e.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),Sa.assert(null!=n,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),Sa.assert(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),(()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`)),Sa.assert(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),(()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`)),Sa.assert(null==n.validationSplit,(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{let a,s,i=null!=n.validationData;if(i)if(j_(n.validationData))Sa.assert(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),(()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`));else{let e=V_(n.validationData);a=e.xs,s=e.ys}let o,l=e.makeTrainFunction(),u=e.getDedupedMetricsNames();o=i?u.slice().concat(u.map((e=>"val_"+e))):u.slice();let p=FT(n.callbacks,n.yieldEvery),c=null==n.verbose?1:n.verbose,{callbackList:d,history:h}=MT(p,c,n.epochs,null,null,H_(t,n),null,i,o);d.setModel(e),e.history=h,await d.onTrainBegin(),e.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,m=await t.iterator();for(;f<n.epochs;){let o={};await d.onEpochBegin(f);let p=0,c=0;for(r||(m=await t.iterator());!r||p<n.batchesPerEpoch;){let t=await m.next();if(r&&t.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${p} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(null!=t.value){let{xs:r,ys:a}=W_(e,t.value),s={};s.batch=c,s.size=r[0].shape[0],await d.onBatchBegin(c,s);let i=[];if(null!=n.classWeight){let t=P_(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)i.push(await L_(a[e],null,t[e]))}let o=r.concat(a).concat(i),h=l(o);Mo(o);for(let e=0;e<u.length;++e){let t=u[e],n=h[e];s[t]=n,Oo(n)}await d.onBatchEnd(c,s),TT(s),c++,p++}if(r?p>=n.batchesPerEpoch:t.done){if(i){let t;t=j_(n.validationData)?CI(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):CI(e.evaluate(a,s,{batchSize:null==n.validationBatchSize?B_:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)o[`val_${e.metricsNames[n]}`]=t[n]}break}if(e.stopTraining_)break}if(await d.onEpochEnd(f,o),f++,e.stopTraining_)break}return await d.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function H_(e,t){let n=null;return null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}function j_(e){return"function"==typeof e.iterator}function q_(e){return"function"==typeof e.next}async function K_(e,t,n){n=n||{};let r=null!=n.batches,a=e.testFunction,s=[];if(n.verbose>0)throw new wI("Verbose mode is not implemented yet.");Sa.assert(!r||n.batches>0&&Number.isInteger(n.batches),(()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`));let i=q_(t)?t:await t.iterator(),o=0,l=0;for(;!r||l<n.batches;){let t=await i.next();if(s=Do((()=>{if(t.value){let{xs:n,ys:r}=W_(e,t.value),i=n.concat(r),u=Do((()=>a(i)));if(Mo(i),0===l)for(let e=0;e<u.length;++e)s.push(Zp(0));let p=i[0].shape[0];for(let e=0;e<u.length;++e){let t=u[e],n=s[e];s[e]=Do((()=>Ko(s[e],el(p,t)))),l>0&&Mo(n)}Mo(u),o+=p,++l}return s})),t.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<s.length;++u){let e=s[u];s[u]=Zo(s[u],o),Mo(e)}return _I(s)}function X_(e){Sa.assert(e>0&&Number.isInteger(e),(()=>`batchSize is required to be a positive integer, but got ${e}`))}function J_(e,t,n){return null==e?[null]:Array.isArray(e)?e.map((e=>TS(e,t,n-t))):TS(e,t,n-t)}function Y_(e,t){return Do((()=>null==e?null:Array.isArray(e)?e.map((e=>Y_(e,t))):DS(e,"int32"===t.dtype?t:wo(t,"int32"))))}function Z_(e,t){let n=[],r=0,a=null;for(;r<e;)a=r+t,a>=e&&(a=e),n.push([r,a]),r=a;return n}function Q_(e){let t=[];e instanceof bs&&(e=[e]);for(let n=0;n<e.length;++n){let r=e[n];if(1===r.rank)t.push(kS(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function eC(e,t){if(null==e)return;let n=[];if(t instanceof bs)n.push(t.id);else if(Array.isArray(t))t.forEach((e=>n.push(e.id)));else if(null!=t)for(let a in t){let e=t[a];n.push(e.id)}let r=[];if(e instanceof bs)-1===n.indexOf(e.id)&&r.push(e);else if(Array.isArray(e))e.forEach((e=>{-1===n.indexOf(e.id)&&r.push(e)}));else if(null!=e)for(let a in e){let t=e[a];-1===n.indexOf(t.id)&&r.push(t)}r.forEach((e=>{e.isDisposed||e.dispose()}))}function tC(e){return e instanceof bs}function nC(e){return Array.isArray(e)}function rC(e){return!tC(e)&&!nC(e)}function aC(e,t,n,r=!0,a=""){if(null==t||0===t.length){if(null!=e){let t=!1;if(nC(e)&&e.length>0)t=!0;else if(rC(e)){for(let n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new vI(`Error when checking model ${a} expected no data, but got ${e}`)}return[]}if(null==e)return t.map((e=>null));let s;if(rC(e)){s=[];for(let n of t){if(null==e[n])throw new vI(`No data provided for "${n}". Need data for each key in: ${t}`);s.push(e[n])}}else if(nC(e)){if(e.length!==t.length)throw new vI(`Error when checking model ${a}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);s=e}else{if(t.length>1)throw new vI(`The model ${a} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);s=[e]}if(s=Q_(s),null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;let e=s[i];if(e.shape.length!==n[i].length)throw new vI(`Error when checking ${a}: expected ${t[i]} to have ${n[i].length} dimension(s). but got array with shape ${e.shape}`);for(let t=0;t<n[i].length;++t){if(0===t&&!r)continue;let s=e.shape[t],o=n[i][t];if(null!=o&&o>=0&&s!==o)throw new vI(`${a} expected a batch of elements where each example has shape [${n[i].slice(1,n[i].length)}] (i.e.,tensor shape [*,${n[i].slice(1,n[i].length)}]) but the ${a} received an input with ${e.shape[0]} examples, each with shape [${e.shape.slice(1,e.shape.length)}] (tensor shape [${e.shape}])`)}}return s}function sC(e,t,n){let r=PI(e.map((e=>e.shape[0])));r.sort();let a=PI(t.map((e=>e.shape[0])));if(a.sort(),r.length>1)throw new vI(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map((e=>e.shape)))}`);if(a.length>1)throw new vI(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map((e=>e.shape)))}`);if(r.length>0&&a.length>0&&!Sa.arraysEqual(r,a))throw new vI(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${a[0]} target sample(s).`)}function iC(e,t,n){let r=[LT,XT,jT];for(let a=0;a<e.length;++a){let s=e[a],i=t[a],o=n[a];if(null!=i){if(i===jT&&1===s.shape[s.shape.length-1])throw new vI(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(i)){let e=s.shape.slice(1),t=o.slice(1);for(let n=0;n<e.length;++n){let r=e[n],a=t[n];if(null!=a&&r!==a)throw new vI(`A target Tensor with shape ${s.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function oC(e,t,n,r=!0,a=""){let s;if(Array.isArray(e)){if(e.length!==t.length)throw new vI(`Error when checking model ${a}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);s=e}else{if(t.length>1)throw new vI(`The model expects ${t.length} ${a} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);s=[e]}if(null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;let e=s[i];if(e.shape.length!==n[i].length)throw new vI(`Error when checking ${a}: expected ${t[i]} to have ${n[i].length} dimension(s), but got array with shape ${JSON.stringify(e.shape)}`);for(let s=0;s<n[i].length;++s){if(0===s&&!r)continue;let o=e.shape[s],l=n[i][s];if(null!=l&&l!==o)throw new vI(`Error when checking ${a}: expected ${t[i]} to have shape ${JSON.stringify(n[i])} but got array with shape ${JSON.stringify(e.shape)}.`)}}}function lC(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>[]));let n;if("string"==typeof e||"function"==typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!=typeof e)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);n=e}if(Array.isArray(n))return t.map((e=>n));{let e=[];for(let r of t){let t=n.hasOwnProperty(r)?n[r]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}var uC="layers-model",pC=class extends M_{constructor(e){super(e),this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new vI("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");N_(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=k_(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Tb))throw new vI("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new vI(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map((e=>e_(e)))}else{let n=e_(e.loss);this.outputs.forEach((e=>{t.push(n)}))}else{e.loss=e.loss;for(let t in e.loss)if(-1===this.outputNames.indexOf(t))throw new vI(`Unknown entry in loss dictionary: "${t}". Only expected the following keys: ${this.outputNames}`);for(let n of this.outputNames)null==e.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),t.push(e_(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let s=0;s<this.outputs.length;++s){let e=this.internalOutputShapes[s],t=this.outputNames[s];this.feedOutputNames.push(t),this.feedOutputShapes.push(e),this.feedLossFns.push(this.lossFunctions[s])}let n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],oS("loss",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;let t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}}));let r=lC(e.metrics,this.outputNames),a=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};oS("metric",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;let t=r[e];(t=>{let n,r,s,i="";for(let o of t){if("string"==typeof o&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(o)){let t,a=this.internalOutputShapes[e];1===a[a.length-1]||this.lossFunctions[e]===XT?-1!==["accuracy","acc"].indexOf(o)?r=t_:-1!==["crossentropy","ce"].indexOf(o)&&(r=l_):this.lossFunctions[e]===qT?-1!==["accuracy","acc"].indexOf(o)?r=u_:-1!==["crossentropy","ce"].indexOf(o)&&(r=b_):-1!==["accuracy","acc"].indexOf(o)?r=n_:-1!==["crossentropy","ce"].indexOf(o)&&(r=g_),-1!==["accuracy","acc"].indexOf(o)?t="acc":-1!==["crossentropy","ce"].indexOf(o)&&(t="ce"),s=r,n=i+t}else s=v_(o),n=i+w_(o);let t;oS(n,(()=>{t=s})),a(e,n,t)}})(t)}})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){let r=null==n.batchSize?32:n.batchSize;X_(r);let a=!0,s=this.standardizeUserDataXY(e,t,a,r);try{let e=s[0].concat(s[1]);this.makeTestFunction();let t=this.testFunction,a=this.testLoop(t,e,r,n.verbose,n.steps);return _I(a)}finally{eC(s[0],e),eC(s[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),K_(this,e,t)}checkNumSamples(e,t,n,r="steps"){let a;if(null!=n){if(a=null,null!=t)throw new vI(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else{if(null==e)throw new vI(`Either the input data should have a defined shape, or ${r} shoud be specified.`);a=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return a}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new vI("`outputs` is an empty Array, which is not allowed.");let n=Array.isArray(t),r=n?t:[t],a=this.retrieveSymbolicTensors(r),s=new ON;if(e instanceof bs&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new vI(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let t=0;t<this.inputs.length;++t)s.add(this.inputs[t],e[t])}else for(let o of this.inputs){let t=e[o.name];if(null==t)throw new vI(`No value is provided for the model's input ${o.name}`);s.add(o,t)}let i=BN(a,s);return n?i:i[0]}retrieveSymbolicTensors(e){let t=SI(null,e.length),n=e.length;for(let r of this.layers){let a=Array.isArray(r.output)?r.output:[r.output],s=a.map((e=>e.name));for(let r=0;r<e.length;++r){let i=s.indexOf(e[r]);if(-1!==i&&(t[r]=a[i],n--),0===n)break}if(0===n)break}if(n>0){let n=[];throw t.forEach(((t,r)=>{null==t&&n.push(e[r])})),new vI(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return t}predictLoop(e,t=32,n=!1){return Do((()=>{let r=this.checkNumSamples(e);if(n)throw new wI("Verbose predictLoop() is not implemented yet.");let a=Z_(r,t),s=this.outputs.map((e=>[]));for(let t=0;t<a.length;++t)Do((()=>{let n=a[t][0],r=a[t][1],s=J_(e,n,r),i=[];if(Array.isArray(s))for(let e=0;e<s.length;++e)i.push({key:this.inputs[e],value:s[e]});else i.push({key:this.inputs[0],value:s});let o=new ON(i);return BN(this.outputs,o)})).forEach(((e,t)=>s[t].push(e)));return _I(s.map((e=>Ql(e,0))))}))}predict(e,t={}){let n=Q_(e);oC(n,this.inputNames,this.feedInputShapes,!1);try{let e=null==t.batchSize?32:t.batchSize;return X_(e),this.predictLoop(n,e)}finally{eC(n,e)}}predictOnBatch(e){oC(e,this.inputNames,this.feedInputShapes,!0);let t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,r){if(null==this.optimizer_)throw new xI("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let a=[];for(let s=0;s<this.feedOutputShapes.length;++s){let e=this.feedOutputShapes[s];this.feedLossFns[s]===qT?a.push(e.slice(0,e.length-1).concat([1])):a.push(e)}if(e=aC(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=aC(t,this.feedOutputNames,a,!1,"target"),sC(e,t,null),iC(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=r&&r>0&&e[0].shape[0]%r!==0)throw new vI(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,r,a=!0,s){let[i,o]=this.standardizeUserDataXY(e,t,a,s);if(null!=n)throw new Error("sample weight is not supported yet.");let l=null;if(null!=r){let e=P_(r,this.outputNames);l=[];for(let t=0;t<e.length;++t)l.push(await L_(o[t],null,e[t]))}return[i,o,l]}testLoop(e,t,n,r=0,a){return Do((()=>{let s=this.checkNumSamples(t,n,a,"steps"),i=[];if(r>0)throw new wI("Verbose mode is not implemented yet.");if(null!=a)throw new wI("steps mode in testLoop() is not implemented yet");{let r=Z_(s,n),a=vm(bS(0,s));for(let n=0;n<r.length;++n){let s=r[n][0],o=r[n][1],l=TS(a,s,o-s),u=Y_(t,l),p=e(u);if(0===n)for(let e=0;e<p.length;++e)i.push(Zp(0));for(let e=0;e<p.length;++e){let t=p[e];i[e]=Ko(i[e],el(o-s,t))}}for(let e=0;e<i.length;++e)i[e]=Zo(i[e],s)}return i}))}getDedupedMetricsNames(){let e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){let r=e[n],a=r;if(TI(e,r)>1){let t=TI(e.slice(0,n),r);a+=`_${t}`}t.push(a)}return t}makeTrainFunction(){return e=>{let t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),s=[],i=()=>{let e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});let i,o=new ON(e),l=BN(this.outputs,o,{training:!0});for(let n=0;n<this.lossFunctions.length;++n){let e=this.lossFunctions[n],s=e(r[n],l[n]);null!=a[n]&&(s=z_(s,a[n]));let o=Md(s);t.push(o),i=0===n?s:Ko(i,s)}for(let n=0;n<this.metricsTensors.length;++n){let e;if(this.outputs.length>1&&n<this.outputs.length)e=t[n];else{let t=this.metricsTensors[n][0],a=this.metricsTensors[n][1];e=Md(t(r[a],l[a]))}Oo(e),s.push(e)}return i=Md(i),this.calculateLosses().forEach((e=>{i=Ko(i,e)})),i},o=this.collectedTrainableWeights.map((e=>e.read())),l=!0;return[this.optimizer_.minimize(i,l,o)].concat(s)}}makeTestFunction(){this.testFunction=e=>Do((()=>{let t,n=[],r=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=[];for(let e=0;e<this.inputs.length;++e)s.push({key:this.inputs[e],value:r[e]});let i=new ON(s),o=BN(this.outputs,i);for(let e=0;e<this.lossFunctions.length;++e){let r=this.lossFunctions[e],s=Md(r(a[e],o[e]));t=0===e?s:Ko(t,s),n.push(t)}for(let e=0;e<this.metricsTensors.length;++e){let t=this.metricsTensors[e][0],r=this.metricsTensors[e][1],s=Md(t(a[r],o[r]));n.push(s)}return n}))}async fit(e,t,n={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let r,a,s,i,o,l,u,p,c;this.isTraining=!0;try{let d=null==n.batchSize?32:n.batchSize;X_(d);let h=!1,f=await this.standardizeUserData(e,t,n.sampleWeight,n.classWeight,h,d);r=f[0],a=f[1],c=f[2];let m,g=!1;if(null!=n.validationData&&n.validationData.length>0){if(g=!0,2!==n.validationData.length)throw 3===n.validationData.length?new wI("validationData including sample weights is not supported yet."):new vI(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);o=n.validationData[0],l=n.validationData[1];let e=!0,t=await this.standardizeUserData(o,l,null,null,e,d);u=t[0],p=t[1],m=u.concat(p)}else if(null!=n.validationSplit&&n.validationSplit>0&&n.validationSplit<1){g=!0;let e=Math.floor(r[0].shape[0]*(1-n.validationSplit)),t=r[0].shape[0];u=J_(r,e,t),s=r,r=J_(r,0,e),p=J_(a,e,t),i=a,a=J_(a,0,e),m=u.concat(p)}else null!=n.validationSteps&&(g=!0);let y=r.concat(a).concat(c);this.checkTrainableWeightsConsistency();let b,x,v=this.makeTrainFunction(),w=this.getDedupedMetricsNames();g?(this.makeTestFunction(),b=this.testFunction,x=w.slice().concat(w.map((e=>"val_"+e)))):(b=null,m=[],x=w.slice());let k=FT(n.callbacks,n.yieldEvery);return await this.fitLoop(v,y,w,d,n.epochs,n.verbose,k,b,m,n.shuffle,x,n.initialEpoch,null,null)}finally{this.isTraining=!1,eC(r,e),eC(a,t),eC(s,e),eC(i,t),eC(u,o),eC(p,l),null!=c&&Mo(c)}}async fitLoop(e,t,n,r,a,s,i,o,l,u,p,c,d,h){null==r&&(r=32),null==a&&(a=1),null==u&&(u=!0),null==c&&(c=0);let f=!1;if(null!=o&&null!=l&&(f=!0),null!=h&&(f=!0,null==d))throw new vI("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let m,g=this.checkNumSamples(t,r,d,"steps_per_epoch");null!=g&&(m=bS(0,g)),null==s&&(s=1);let{callbackList:y,history:b}=MT(i,s,a,c,g,d,r,f,p);y.setModel(this),this.history=b,await y.onTrainBegin(),this.stopTraining_=!1;for(let x=c;x<a;++x){await y.onEpochBegin(x);let a={};if(null!=d)throw new wI("stepsPerEpoch mode is not implemented yet.");{if("batch"===u)throw new wI("batch shuffling is not implemneted yet");u&&Sa.shuffle(m);let s=vm(m),i=Z_(g,r);for(let u=0;u<i.length;++u){let p={};if(await y.onBatchBegin(u,p),Do((()=>{let c=i[u][0],d=i[u][1],h=TS(s,c,d-c);p.batch=u,p.size=d-c;let m=Y_(t,h),g=e(m);for(let e=0;e<n.length;++e){let t=n[e],r=g[e];p[t]=r,Oo(r)}if(u===i.length-1&&f){let e=this.testLoop(o,l,r);for(let t=0;t<n.length;++t){let r=n[t],s=e[t];Oo(s),a["val_"+r]=s}}})),await y.onBatchEnd(u,p),TT(p),this.stopTraining_)break}s.dispose()}if(await y.onEpochEnd(x,a),this.stopTraining_)break}return await y.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return G_(this,e,t)}async trainOnBatch(e,t){let n=await this.standardizeUserData(e,t),r=n[0],a=n[1],s=this.makeTrainFunction()(r.concat(a)),i=[];for(let o of s){let e=await o.data();i.push(e[0])}return Mo(s),eC(n[0],e),eC(n[1],t),_I(i)}getNamedWeights(e){let t=[],n=null!=e&&e.trainableOnly,r=n?this.trainableWeights:this.weights,a=this.getWeights(n);for(let s=0;s<r.length;++s)n&&!r[s].trainable||t.push({name:r[s].originalName,tensor:a[s]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){let e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){let t=Ro().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-Ro().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=EI(this.loss);else if(Array.isArray(this.loss)){for(let e of this.loss)if("string"!=typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map((e=>EI(e)))}else{let t=Object.keys(this.loss);e={};let n=this.loss;for(let r of t){if("string"!=typeof n[r])throw new Error("Serialization of non-string loss is not supported.");e[r]=EI(n[r])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[EI(w_(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((e=>EI(w_(e))));{let e={};for(let t in this.metrics)e[t]=EI(w_(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");let t,n,r=R_(e.optimizer_config),a=OT(r);if("string"==typeof e.loss)t=AI(e.loss);else if(Array.isArray(e.loss))t=e.loss.map((e=>AI(e)));else if(null!=e.loss){t={};for(let n in e.loss)t[n]=AI(e.loss[n])}if(Array.isArray(e.metrics))n=e.metrics.map((e=>AI(e)));else if(null!=e.metrics){n={};for(let t in e.metrics)n[t]=AI(e.metrics[t])}this.compile({loss:t,metrics:n,optimizer:a})}async save(e,t){if("string"==typeof e){let t=Ob.getSaveHandlers(e);if(0===t.length)throw new vI(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new vI(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new vI("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let n=await Ob.encodeWeights(this.getNamedWeights(t)),r=!1,a=null,s={modelTopology:this.toJSON(a,r),format:uC,generatedBy:`TensorFlow.js tfjs-layers v${D_}`,convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=this.optimizer){s.trainingConfig=this.getTrainingConfig();let e="optimizer",{data:t,specs:r}=await Ob.encodeWeights(await this.optimizer.getWeights(),e);n.specs.push(...r),n.data=Ob.concatenateArrayBuffers([n.data,t])}return null!=this.userDefinedMetadata&&(I_(this.userDefinedMetadata,this.name,!0),s.userDefinedMetadata=this.userDefinedMetadata),s.weightData=n.data,s.weightSpecs=n.specs,e.save(s)}setUserDefinedMetadata(e){I_(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}};pC.className="Model",kb.registerClass(pC);var cC=class extends pC{};async function dC(e,t){"modelTopology"in e||(e={modelTopology:e});let n=e.modelTopology;null!=n.model_config&&(n=n.model_config);let r=R_(n),a=OT(r,t);if(null!=e.weightsManifest){let t=await Ob.loadWeights(e.weightsManifest,e.pathPrefix,a.weights.map((e=>e.originalName))),n={};for(let e of a.weights)n[e.originalName]=t[e.originalName];a.loadWeights(n),Mo(t)}return a}async function hC(e,t){if(null==t&&(t={}),"string"==typeof e){let n=Ob.getLoadHandlers(e,t);if(0===n.length)n.push(Ob.browserHTTPRequest(e,t));else if(n.length>1)throw new vI(`Found more than one (${n.length}) load handlers for URL '${e}'`);e=n[0]}return fC(e,void 0,t)}async function fC(e,t,n){if(null==n&&(n={}),null==e.load)throw new vI("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let r=await e.load(),a=r.modelTopology;null!=a.model_config&&(a=a.model_config);let s=null==n.strict||n.strict,i=null!=r.weightData&&null!=r.weightSpecs&&s,o=OT(R_(a),t,i),l=r.trainingConfig;if(null!=l&&o.loadTrainingConfig(l),null!=r.userDefinedMetadata&&o.setUserDefinedMetadata(r.userDefinedMetadata),null!=r.weightData){if(null==r.weightSpecs)throw new vI("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:e,optimizerWeights:t}=mC(r.weightData,r.weightSpecs);o.loadWeights(e,s),null!=o.optimizer&&t.length>0&&await o.optimizer.setWeights(t),Mo(e),Mo(t.map((e=>e.tensor)))}return o}function mC(e,t){let n=Ob.decodeWeights(e,t),r={},a=[];return t.forEach((e=>{"optimizer"===e.group?a.push({name:e.name,tensor:n[e.name]}):r[e.name]=n[e.name]})),{modelWeights:r,optimizerWeights:a}}cC.className="Functional",kb.registerClass(cC);var gC=class extends pC{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:KI("sequential_"),null!=e.layers)for(let t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some((e=>e<0)))throw new vI(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){let t,n=e instanceof gC||e instanceof pC;if(n){if(t=e,1!==t.outputs.length)throw new vI("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==t.inputs.length)throw new vI("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new vI("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let t=DN({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(t)}if(n)this.outputs=t.outputs,this.inputs=t.inputs;else{if(1!==e.inboundNodes.length)throw new vI(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new vI("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=RN(this.outputs[0])}this.inboundNodes=[],new _N({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:SI(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs[0].shape})}else{let t=e.apply(this.outputs[0]);if(Array.isArray(t))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[t],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(yN(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new pC({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,n=console.log){this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t,n={}){if(!this.built)throw new xI("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new xI("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,n={}){if(!this.built)throw new xI("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new xI("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,n={},r=!1){let a,s={};if(t instanceof Array){if(null==t[0].className||"Merge"===t[0].className)throw new vI("Legacy serialization format not supported yet.");a=t}else Sa.assert(null!=t.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),a=t.layers,delete t.layers,s=t;let i=new e(s);if(!(i instanceof gC))throw new wI(`Sequential.fromConfig called on non-Sequential input: ${i}`);for(let o of a){let e=OT(o,void 0,r);r&&e.setFastWeightInitDuringBuild(!0),i.add(e)}return i}set stopTraining(e){if(null==this.model)throw new vI("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new vI("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let e=[];for(let t of this.layers){let n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}};function yC(e){return new pC(e)}function bC(e){return new gC(e)}function xC(e){return DN(e)}function vC(e,t){DT.registerCallbackConstructor(e,t)}gC.className="Sequential",kb.registerClass(gC);var wC=class extends kb.Serializable{getConfig(){return{}}},kC=class extends wC{apply(e,t=1){return LS(e,t)}};kC.className="elu",kb.registerClass(kC);var IC=class extends wC{apply(e){return $f(e)}};IC.className="selu",kb.registerClass(IC);var SC=class extends wC{apply(e){return hf(e)}};SC.className="relu",kb.registerClass(SC);var NC=class extends wC{apply(e){return Do((()=>Bd(6,hf(e))))}};NC.className="relu6",kb.registerClass(NC);var TC=class extends wC{apply(e){return e}};TC.className="linear",kb.registerClass(TC);var _C=class extends wC{apply(e){return ru(e)}};_C.className="sigmoid",kb.registerClass(_C);var CC=class extends wC{apply(e){return WS(e)}};CC.className="hardSigmoid",kb.registerClass(CC);var EC=class extends wC{apply(e){return sd(e)}};EC.className="softplus",kb.registerClass(EC);var AC=class extends wC{apply(e){return zS(e)}};AC.className="softsign",kb.registerClass(AC);var $C=class extends wC{apply(e){return ou(e)}};$C.className="tanh",kb.registerClass($C);var RC=class extends wC{apply(e,t=-1){return Yf(e,t)}};RC.className="softmax",kb.registerClass(RC);var FC=class extends wC{apply(e,t=-1){return cd(e,t)}};FC.className="logSoftmax",kb.registerClass(FC);var DC=class extends wC{apply(e,t=1){return Do((()=>el(ru(el(e,t)),e)))}};DC.className="swish",kb.registerClass(DC);var MC=class extends wC{apply(e){return Do((()=>el(e,ou(sd(e)))))}};function OC(e){return e.getClassName()}function PC(e,t={}){return DI(e,kb.SerializationMap.getMap().classNameMap,t,"activation")}function LC(e){if(null==e){let e={className:"linear",config:{}};return PC(e)}if("string"==typeof e){let t={};return t.className=e,t.config={},PC(t)}return e instanceof wC?e:PC(e)}function zC(e){if(null!=e&&"object"!=typeof e)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}MC.className="mish",kb.registerClass(MC);var BC=class extends kb.Serializable{},WC=class extends BC{constructor(e){super(),zC(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return Do((()=>{let t=Od([1]);return this.hasL1&&(t=Ko(t,ac(el(this.l1,nl(e))))),this.hasL2&&(t=Ko(t,ac(el(this.l2,MS(e))))),ql(t,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}};function UC(e){return zC(e),new WC({l1:null!=e?e.l1:null,l2:0})}function VC(e){return zC(e),new WC({l2:null!=e?e.l2:null,l1:0})}WC.className="L1L2",kb.registerClass(WC);var GC={l1l2:"L1L2"};function HC(e){return RI(e)}function jC(e,t={}){return DI(e,kb.SerializationMap.getMap().classNameMap,t,"regularizer")}function qC(e){if(null==e)return null;if("string"==typeof e){let t={className:e in GC?GC[e]:e,config:{}};return jC(t)}return e instanceof BC?e:jC(e)}var KC=class extends EN{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=gN(e);let n=hf(e);return null!=this.maxValue&&(n=$u(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){let e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}};KC.className="ReLU",kb.registerClass(KC);var XC=class extends EN{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=gN(e);return Pc(n,this.alpha)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};XC.className="LeakyReLU",kb.registerClass(XC);var JC=class extends EN{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=hN(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=qC(e.alphaRegularizer),this.alphaConstraint=nT(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new vI(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){e=yN(e);let t=e.slice(1);if(null!=this.sharedAxes)for(let r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let n={};if(null!=this.sharedAxes)for(let r=1;r<e.length;++r)n[r]=e[r];this.inputSpec=[new SN({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=gN(e),kh(e,this.alpha.read())}getConfig(){let e={alphaInitializer:dN(this.alphaInitializer),alphaRegularizer:HC(this.alphaRegularizer),alphaConstraint:eT(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}};JC.className="PReLU",kb.registerClass(JC);var YC=class extends EN{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new wI(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=gN(e);return Mp(n)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};YC.className="ELU",kb.registerClass(YC);var ZC=class extends EN{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){let n=gN(e);return el(n,wo(Nc(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){let e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}};ZC.className="ThresholdedReLU",kb.registerClass(ZC);var QC=class extends EN{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new RC).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){let n=gN(e);return this.softmax(n,this.axis)}computeOutputShape(e){return e}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};function eE(e,t,n){if("number"==typeof e)return SI(e,t);if(e.length!==t)throw new vI(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let r=0;r<t;++r){let a=e[r];if(!fS(a))throw new vI(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${a}`)}return e}function tE(e,t,n,r,a=1){if(null==e)return e;let s,i=t+(t-1)*(a-1);return s="same"===n?e:e-i+1,Math.floor((s+r-1)/r)}function nE(e,t,n,r){if(null==e)return null;if("valid"===r)e=e*t+yS([n-t,0]);else{if("same"!==r)throw new vI(`Unsupport padding mode: ${r}.`);e*=t}return e}function rE(e,t){return Do((()=>(tS(t),"channelsFirst"===t?Jm(e,[0,2,3,1]):e)))}function aE(e,t){return Do((()=>(tS(t),"channelsFirst"===t?Jm(e,[0,2,3,4,1]):e)))}function sE(e,t,n,r=1,a="valid",s,i=1){return Do((()=>{if(null==s&&(s=vS()),tS(s),3!==e.shape.length)throw new vI(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(3!==t.shape.length)throw new vI(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new vI(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if("channelsFirst"===s&&(e=Jm(e,[0,2,1])),"causal"===a)throw new wI("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=Vu(e,t,r,"same"===a?"same":"valid","NWC",i);return null!=n&&(o=PS(o,n)),o}))}function iE(e,t,n,r=[1,1],a="valid",s,i,o=null){return Do((()=>{if(null==s&&(s=vS()),tS(s),3!==e.rank&&4!==e.rank)throw new vI(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(3!==t.rank&&4!==t.rank)throw new vI(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=rE(e,s);if("causal"===a)throw new wI("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=hg.conv2d({x:l,filter:t,strides:r,pad:"same"===a?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),"channelsFirst"===s&&(l=Jm(l,[0,3,1,2])),l}))}function oE(e,t,n,r=[1,1,1],a="valid",s,i){return Do((()=>{if(null==s&&(s=vS()),tS(s),4!==e.rank&&5!==e.rank)throw new vI(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(4!==t.rank&&5!==t.rank)throw new vI(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=aE(e,s);if("causal"===a)throw new wI("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=Xu(o,t,r,"same"===a?"same":"valid","NDHWC",i),null!=n&&(o=PS(o,n)),"channelsFirst"===s&&(o=Jm(o,[0,4,1,2,3])),o}))}QC.className="Softmax",kb.registerClass(QC);var lE=class extends EN{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",lE.verifyArgs(t),this.rank=e,WI(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new wI(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=eE(t.kernelSize,e,"kernelSize"),this.strides=eE(null==t.strides?1:t.strides,e,"strides"),this.padding=null==t.padding?"valid":t.padding,rS(this.padding),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,tS(this.dataFormat),this.activation=LC(t.activation),this.useBias=null==t.useBias||t.useBias,this.biasInitializer=hN(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=nT(t.biasConstraint),this.biasRegularizer=qC(t.biasRegularizer),this.activityRegularizer=qC(t.activityRegularizer),this.dilationRate=eE(null==t.dilationRate?1:t.dilationRate,e,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new vI(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new vI(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new vI(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(e){if(NI("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!=typeof e.kernelSize&&!BI(e.kernelSize,"number",1,3))throw new vI(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){let e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:OC(this.activation),useBias:this.useBias,biasInitializer:dN(this.biasInitializer),biasRegularizer:HC(this.biasRegularizer),activityRegularizer:HC(this.activityRegularizer),biasConstraint:eT(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}},uE=class extends lE{constructor(e,t){super(e,t),this.kernel=null,uE.verifyArgs(t),this.filters=t.filters,WI(this.filters,"filters"),this.kernelInitializer=hN(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=nT(t.kernelConstraint),this.kernelRegularizer=qC(t.kernelRegularizer)}build(e){e=yN(e);let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new vI(`The channel dimension of the input should be defined. Found ${e[t]}`);let n=e[t],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return Do((()=>{e=gN(e);let t,n=null==this.bias?null:this.bias.read(),r=GI(this.activation.getClassName());if(null!=r&&2===this.rank)t=iE(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(1===this.rank)t=sE(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=iE(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new wI("convolutions greater than 3D are not implemented yet.");t=oE(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t}))}computeOutputShape(e){e=yN(e);let t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let a=0;a<n.length;++a){let e=tE(n[a],this.kernelSize[a],this.padding,this.strides[a],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[a]);t.push(e)}let r=[e[0]];return"channelsLast"===this.dataFormat?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){let e={filters:this.filters,kernelInitializer:dN(this.kernelInitializer),kernelRegularizer:HC(this.kernelRegularizer),kernelConstraint:eT(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!=typeof e.filters||e.filters<1)throw new vI(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}},pE=class extends uE{constructor(e){super(2,e),pE.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!BI(e.kernelSize,"number",1,2))throw new vI(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}};pE.className="Conv2D",kb.registerClass(pE);var cE=class extends uE{constructor(e){super(3,e),cE.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new vI(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}};cE.className="Conv3D",kb.registerClass(cE);var dE=class extends pE{constructor(e){if(super(e),this.inputSpec=[new SN({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new vI(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=yN(e),4!==e.length)throw new vI("Input should have rank 4; Received input shape: "+JSON.stringify(e));let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new vI("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new SN({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return Do((()=>{let t=gN(e);if(4!==t.shape.length)throw new vI(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);let n,r,a=t.shape,s=a[0];"channelsFirst"===this.dataFormat?(n=2,r=3):(n=1,r=2);let i=a[n],o=a[r],l=this.kernelSize[0],u=this.kernelSize[1],p=this.strides[0],c=this.strides[1],d=nE(i,p,l,this.padding),h=nE(o,c,u,this.padding),f=[s,d,h,this.filters];"channelsLast"!==this.dataFormat&&(t=Jm(t,[0,2,3,1]));let m=qu(t,this.kernel.read(),f,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(m=Jm(m,[0,3,1,2])),null!=this.bias&&(m=PS(m,this.bias.read(),this.dataFormat)),null!=this.activation&&(m=this.activation.apply(m)),m}))}computeOutputShape(e){e=yN(e);let t,n,r,a=e.slice();"channelsFirst"===this.dataFormat?(t=1,n=2,r=3):(t=3,n=1,r=2);let s=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return a[t]=this.filters,a[n]=nE(a[n],o,s,this.padding),a[r]=nE(a[r],l,i,this.padding),a}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};dE.className="Conv2DTranspose",kb.registerClass(dE);var hE=class extends cE{constructor(e){if(super(e),this.inputSpec=[new SN({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new vI(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=yN(e),5!==e.length)throw new vI("Input should have rank 5; Received input shape: "+JSON.stringify(e));let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new vI("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new SN({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return Do((()=>{let t=gN(e);if(5!==t.shape.length)throw new vI(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);let n,r,a,s=t.shape,i=s[0];"channelsFirst"===this.dataFormat?(a=2,n=3,r=4):(a=1,n=2,r=3);let o=s[a],l=s[n],u=s[r],p=this.kernelSize[0],c=this.kernelSize[1],d=this.kernelSize[2],h=this.strides[0],f=this.strides[1],m=this.strides[2],g=nE(o,h,p,this.padding),y=nE(l,f,c,this.padding),b=nE(u,m,d,this.padding),x=[i,g,y,b,this.filters];"channelsLast"!==this.dataFormat&&(t=Jm(t,[0,2,3,4,1]));let v=Qu(t,this.kernel.read(),x,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(v=Jm(v,[0,4,1,2,3])),null!==this.bias&&(v=PS(v,this.bias.read(),this.dataFormat)),null!==this.activation&&(v=this.activation.apply(v)),v}))}computeOutputShape(e){e=yN(e);let t,n,r,a,s=e.slice();"channelsFirst"===this.dataFormat?(t=1,n=2,r=3,a=4):(t=4,n=1,r=2,a=3);let i=this.kernelSize[0],o=this.kernelSize[1],l=this.kernelSize[2],u=this.strides[0],p=this.strides[1],c=this.strides[2];return s[t]=this.filters,s[n]=nE(s[n],u,i,this.padding),s[r]=nE(s[r],p,o,this.padding),s[a]=nE(s[a],c,l,this.padding),s}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};hE.className="Conv3DTranspose",kb.registerClass(hE);var fE=class extends uE{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new vI("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new vI("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new vI(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=hN(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=qC(t.depthwiseRegularizer),this.depthwiseConstraint=nT(t.depthwiseConstraint),this.pointwiseInitializer=hN(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=qC(t.pointwiseRegularizer),this.pointwiseConstraint=nT(t.pointwiseConstraint)}build(e){if(e=yN(e),e.length<this.rank+2)throw new vI(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new vI(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);let n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),a=[];for(let i=0;i<this.rank;++i)a.push(1);a.push(n*this.depthMultiplier,this.filters);let s=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,s,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,s,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,s,this.biasConstraint):this.bias=null,this.inputSpec=[new SN({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return Do((()=>{let t;if(e=gN(e),1===this.rank)throw new wI("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=Jm(e,[0,2,3,1])),t=Ff(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=PS(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=Jm(t,[0,3,1,2])),t}))}getConfig(){let e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=dN(this.depthwiseInitializer),e.pointwiseInitializer=dN(this.pointwiseInitializer),e.depthwiseRegularizer=HC(this.depthwiseRegularizer),e.pointwiseRegularizer=HC(this.pointwiseRegularizer),e.depthwiseConstraint=eT(this.depthwiseConstraint),e.pointwiseConstraint=eT(this.pointwiseConstraint),e}};fE.className="SeparableConv";var mE=class extends fE{constructor(e){super(2,e)}};mE.className="SeparableConv2D",kb.registerClass(mE);var gE=class extends uE{constructor(e){super(1,e),gE.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){let e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!BI(e.kernelSize,"number",1,1))throw new vI(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}};gE.className="Conv1D",kb.registerClass(gE);var yE=class extends EN{constructor(e){super(e),"number"==typeof e.cropping?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return Do((()=>{if(e=gN(e),"channelsLast"===this.dataFormat){let t=CS(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return CS(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{let t=CS(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return CS(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){let e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};yE.className="Cropping2D",kb.registerClass(yE);var bE=class extends EN{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,tS(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,nS(this.interpolation)}computeOutputShape(e){if("channelsFirst"===this.dataFormat){let t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}{let t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return Do((()=>{let t=gN(e),n=t.shape;if("channelsFirst"===this.dataFormat){t=Jm(t,[0,2,3,1]);let e=this.size[0]*n[2],r=this.size[1]*n[3],a="nearest"===this.interpolation?yb.resizeNearestNeighbor(t,[e,r]):yb.resizeBilinear(t,[e,r]);return Jm(a,[0,3,1,2])}{let e=this.size[0]*n[1],r=this.size[1]*n[2];return"nearest"===this.interpolation?yb.resizeNearestNeighbor(t,[e,r]):yb.resizeBilinear(t,[e,r])}}))}getConfig(){let e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}};function xE(e,t,n=[1,1],r="valid",a,s){return Do((()=>{null==a&&(a=vS()),tS(a);let i=rE(e,a);if(4!==e.rank)throw new vI(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(4!==t.rank)throw new vI(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=hp(i,t,n,"same"===r?"same":"valid","NHWC",s),"channelsFirst"===a&&(i=Jm(i,[0,3,1,2])),i}))}bE.className="UpSampling2D",kb.registerClass(bE);var vE=class extends lE{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=hN(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=nT(e.depthwiseConstraint),this.depthwiseRegularizer=qC(e.depthwiseRegularizer)}build(e){if(e=yN(e),e.length<4)throw new vI(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);let t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new vI(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);let n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Do((()=>{e=gN(e);let t=xE(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=PS(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t}))}computeOutputShape(e){e=yN(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,a=tE(t,this.kernelSize[0],this.padding,this.strides[0]),s=tE(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],r,a,s]:[e[0],a,s,r]}getConfig(){let e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=dN(this.depthwiseInitializer),e.depthwiseRegularizer=HC(this.depthwiseRegularizer),e.depthwiseConstraint=eT(this.depthwiseRegularizer),e}};function wE(e,t,n,r){if(Array.isArray(e)){if(null!=t||null!=n)throw new vI("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function a(e){return null==e||Array.isArray(e)?e:[e]}return t=a(t),n=a(n),{inputs:e,initialState:t,constants:n}}function kE(e,t,n,r=!1,a,s,i=!1,o=!1){return Do((()=>{let l=t.shape.length;if(l<3)throw new vI(`Input should be at least 3D, but is ${l}D.`);let u=[1,0].concat(bS(2,l));if(t=Jm(t,u),null!=s)throw new wI("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=a&&(a=wo(wo(a,"bool"),"float32"),a.rank===l-1&&(a=hc(a,-1)),a=Jm(a,u)),r&&(t=yf(t,0),null!=a&&(a=yf(a,0)));let p,c,d,h=[],f=n,m=t.shape[0],g=Wm(t);null!=a&&(c=Wm(a));for(let t=0;t<m;++t){let n=g[t],r=Do((()=>e(n,f)));if(null==a)p=r[0],f=r[1];else{let e=Do((()=>{let e=c[t],n=ud(nh(e),e),a=Ko(el(r[0],e),el(f[0],n)),s=f.map(((t,a)=>Ko(el(r[1][a],e),el(t,n))));return{output:a,newStates:s}}));p=e.output,f=e.newStates}o&&h.push(p)}return o&&(d=hm(h,1)),[p,d,f]}))}vE.className="DepthwiseConv2D",kb.registerClass(vE);var IE=class extends EN{constructor(e){let t;if(super(e),null==e.cell)throw new vI("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new $E({cells:e.cell}):e.cell,null==t.stateSize)throw new vI("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new SN({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return bS(0,e).map((e=>null))}return this.states_}setStates(e){this.states_=e}computeOutputShape(e){fN(e)&&(e=e[0]);let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);let n,r=t[0];if(n=this.returnSequences?[e[0],e[1],r]:[e[0],r],this.returnState){let r=[];for(let n of t)r.push([e[0],n]);return[n].concat(r)}return n}computeMask(e,t){return Do((()=>{Array.isArray(t)&&(t=t[0]);let e=this.returnSequences?t:null;if(this.returnState){let t=this.states.map((e=>null));return[e].concat(t)}return e}))}get states(){if(null==this.states_){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new wI("Constants support is not implemented in RNN yet.");fN(e)&&(e=e[0]);let t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new SN({shape:[t,null,...n]});let r,a=[e[0]].concat(e.slice(2));if(this.cell.build(a),r=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!Sa.arraysEqual(this.stateSpec.map((e=>e.shape[e.shape.length-1])),r))throw new vI(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=r.map((e=>new SN({shape:[null,e]})));this.stateful&&this.resetStates()}resetStates(e,t=!1){Do((()=>{if(!this.stateful)throw new bI("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape[0];if(null==n)throw new vI("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>Od([n,e]))):this.states_=[Od([n,this.cell.stateSize])];else if(null==e)Mo(this.states_),null!=this.keptStates&&(Mo(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>Od([n,e]))):this.states_[0]=Od([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new vI(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===t?this.keptStates.push(this.states_.slice()):Mo(this.states_);for(let t=0;t<this.states_.length;++t){let r=e[t],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,s=[n,a];if(!Sa.arraysEqual(r.shape,s))throw new vI(`State ${t} is incompatible with layer ${this.name}: expected shape=${s}, received shape=${r.shape}`);this.states_[t]=r}}this.states_=this.states_.map((e=>Oo(e.clone())))}))}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});let a=wE(e,n,r,this.numConstants);e=a.inputs,n=a.initialState,r=a.constants;let s=[],i=[];if(null!=n){t.initialState=n,s=s.concat(n),this.stateSpec=[];for(let e of n)this.stateSpec.push(new SN({shape:e.shape}));i=i.concat(this.stateSpec)}if(null!=r&&(t.constants=r,s=s.concat(r),this.numConstants=r.length),s[0]instanceof NN){let n=[e].concat(s),r=this.inputSpec.concat(i),a=this.inputSpec;this.inputSpec=r;let o=super.apply(n,t);return this.inputSpec=a,o}return super.apply(e,t)}call(e,t){return Do((()=>{let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;e=gN(e),null==a&&(a=this.stateful?this.states_:this.getInitialState(e));let s=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(a.length!==s)throw new vI(`RNN Layer has ${s} state(s) but was passed ${a.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let i={training:r},o=kE(((e,t)=>{let n=this.cell.call([e].concat(t),i);return[n[0],n.slice(1)]}),e,a,this.goBackwards,n,null,this.unroll,this.returnSequences),l=o[0],u=o[1],p=o[2];this.stateful&&this.resetStates(p,r);let c=this.returnSequences?u:l;return this.returnState?[c].concat(p):c}))}getInitialState(e){return Do((()=>{let t=Od(e.shape);return t=ac(t,[1,2]),t=kS(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((e=>e>1?$S(t,[1,e]):t)):this.cell.stateSize>1?[$S(t,[1,this.cell.stateSize])]:[t]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){let e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);let n=this.cell.getConfig();return this.getClassName()===IE.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign(Object.assign(Object.assign({},n),e),t)}static fromConfig(e,t,n={}){let r=t.cell,a=OT(r,n);return new e(Object.assign(t,{cell:a}))}};IE.className="RNN",kb.registerClass(IE);var SE=class extends EN{},NE=class extends SE{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,WI(this.units,"units"),this.activation=LC(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=hN(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=hN(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=hN(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=qC(e.kernelRegularizer),this.recurrentRegularizer=qC(e.recurrentRegularizer),this.biasRegularizer=qC(e.biasRegularizer),this.kernelConstraint=nT(e.kernelConstraint),this.recurrentConstraint=nT(e.recurrentConstraint),this.biasConstraint=nT(e.biasConstraint),this.dropout=gS([1,yS([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=gS([1,yS([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=yN(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Do((()=>{if(2!==e.length)throw new vI(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];let r=null!=t.training&&t.training;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=RE({ones:()=>nh(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=RE({ones:()=>nh(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let a,s=this.dropoutMask,i=this.recurrentDropoutMask;a=FS(null!=s?el(e,s):e,this.kernel.read()),null!=this.bias&&(a=PS(a,this.bias.read())),null!=i&&(n=el(n,i));let o=Ko(a,FS(n,this.recurrentKernel.read()));return null!=this.activation&&(o=this.activation.apply(o)),[o,o]}))}getConfig(){let e=super.getConfig(),t={units:this.units,activation:OC(this.activation),useBias:this.useBias,kernelInitializer:dN(this.kernelInitializer),recurrentInitializer:dN(this.recurrentInitializer),biasInitializer:dN(this.biasInitializer),kernelRegularizer:HC(this.kernelRegularizer),recurrentRegularizer:HC(this.recurrentRegularizer),biasRegularizer:HC(this.biasRegularizer),activityRegularizer:HC(this.activityRegularizer),kernelConstraint:eT(this.kernelConstraint),recurrentConstraint:eT(this.recurrentConstraint),biasConstraint:eT(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}};NE.className="SimpleRNNCell",kb.registerClass(NE);var TE=class extends IE{constructor(e){e.cell=new NE(e),super(e)}call(e,t){return Do((()=>{null!=this.cell.dropoutMask&&(Mo(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Mo(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return new e(t)}};TE.className="SimpleRNN",kb.registerClass(TE);var _E=class extends SE{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new vI("GRUCell does not support reset_after parameter set to true.");this.units=e.units,WI(this.units,"units"),this.activation=LC(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=LC(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=hN(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=hN(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=hN(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=qC(e.kernelRegularizer),this.recurrentRegularizer=qC(e.recurrentRegularizer),this.biasRegularizer=qC(e.biasRegularizer),this.kernelConstraint=nT(e.kernelConstraint),this.recurrentConstraint=nT(e.recurrentConstraint),this.biasConstraint=nT(e.biasConstraint),this.dropout=gS([1,yS([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=gS([1,yS([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=yN(e);let t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Do((()=>{if(2!==e.length)throw new vI(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);let n=null!=t.training&&t.training,r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=RE({ones:()=>nh(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=RE({ones:()=>nh(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));let a,s,i,o=this.dropoutMask,l=this.recurrentDropoutMask;0<this.dropout&&this.dropout<1&&(e=el(e,o[0]));let u=FS(e,this.kernel.read());this.useBias&&(u=PS(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=el(r,l[0]));let p=this.recurrentKernel.read(),[c,d]=sm(p,[2*this.units,this.units],p.rank-1),h=FS(r,c),[f,m,g]=sm(u,3,u.rank-1),[y,b]=sm(h,2,h.rank-1);a=this.recurrentActivation.apply(Ko(f,y)),s=this.recurrentActivation.apply(Ko(m,b));let x=FS(el(s,r),d);i=this.activation.apply(Ko(g,x));let v=Ko(el(a,r),el(Ko(1,rd(a)),i));return[v,v]}))}getConfig(){let e=super.getConfig(),t={units:this.units,activation:OC(this.activation),recurrentActivation:OC(this.recurrentActivation),useBias:this.useBias,kernelInitializer:dN(this.kernelInitializer),recurrentInitializer:dN(this.recurrentInitializer),biasInitializer:dN(this.biasInitializer),kernelRegularizer:HC(this.kernelRegularizer),recurrentRegularizer:HC(this.recurrentRegularizer),biasRegularizer:HC(this.biasRegularizer),activityRegularizer:HC(this.activityRegularizer),kernelConstraint:eT(this.kernelConstraint),recurrentConstraint:eT(this.recurrentConstraint),biasConstraint:eT(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}};_E.className="GRUCell",kb.registerClass(_E);var CE=class extends IE{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new _E(e),super(e)}call(e,t){return Do((()=>{null!=this.cell.dropoutMask&&(Mo(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Mo(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}};CE.className="GRU",kb.registerClass(CE);var EE=class extends SE{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,WI(this.units,"units"),this.activation=LC(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=LC(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=hN(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=hN(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=hN(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=qC(e.kernelRegularizer),this.recurrentRegularizer=qC(e.recurrentRegularizer),this.biasRegularizer=qC(e.biasRegularizer),this.kernelConstraint=nT(e.kernelConstraint),this.recurrentConstraint=nT(e.recurrentConstraint),this.biasConstraint=nT(e.biasConstraint),this.dropout=gS([1,yS([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=gS([1,yS([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=yN(e);let n,r=e[e.length-1];if(this.kernel=this.addWeight("kernel",[r,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){let e=this.biasInitializer,r=this.units;n=new(t=class extends qS{apply(t,n){let a=e.apply([r]),s=(new XS).apply([r]),i=e.apply([2*r]);return AS(AS(a,s),i)}},t.className="CustomInit",t)}else n=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,n,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return Do((()=>{let n=null!=t.training&&t.training;if(3!==e.length)throw new vI(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1],a=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=RE({ones:()=>nh(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=RE({ones:()=>nh(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let s,i,o,l,u=this.dropoutMask,p=this.recurrentDropoutMask;0<this.dropout&&this.dropout<1&&(e=el(e,u[0]));let c=FS(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=el(r,p[0])),c=Ko(c,FS(r,this.recurrentKernel.read())),this.useBias&&(c=PS(c,this.bias.read()));let[d,h,f,m]=sm(c,4,c.rank-1);s=this.recurrentActivation.apply(d),i=this.recurrentActivation.apply(h),o=Ko(el(i,a),el(s,this.activation.apply(f))),l=this.recurrentActivation.apply(m);let g=el(l,this.activation.apply(o));return[g,g,o]}))}getConfig(){let e=super.getConfig(),t={units:this.units,activation:OC(this.activation),recurrentActivation:OC(this.recurrentActivation),useBias:this.useBias,kernelInitializer:dN(this.kernelInitializer),recurrentInitializer:dN(this.recurrentInitializer),biasInitializer:dN(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:HC(this.kernelRegularizer),recurrentRegularizer:HC(this.recurrentRegularizer),biasRegularizer:HC(this.biasRegularizer),activityRegularizer:HC(this.activityRegularizer),kernelConstraint:eT(this.kernelConstraint),recurrentConstraint:eT(this.recurrentConstraint),biasConstraint:eT(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}};EE.className="LSTMCell",kb.registerClass(EE);var AE=class extends IE{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new EE(e),super(e)}call(e,t){return Do((()=>{null!=this.cell.dropoutMask&&(Mo(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Mo(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}};AE.className="LSTM",kb.registerClass(AE);var $E=class extends SE{constructor(e){super(e),this.cells=e.cells}get stateSize(){let e=[];for(let t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return Do((()=>{let n=e.slice(1),r=[];for(let e of this.cells.slice().reverse())Array.isArray(e.stateSize)?r.push(n.splice(0,e.stateSize.length)):r.push(n.splice(0,1));r.reverse();let a,s=[];for(let i=0;i<this.cells.length;++i){let o=this.cells[i];n=r[i],a=0===i?[e[0]].concat(n):[a[0]].concat(n),a=o.call(a,t),s.push(a.slice(1))}n=[];for(let e of s.slice().reverse())n.push(...e);return[a[0]].concat(n)}))}build(e){let t;fN(e)&&(e=e[0]),this.cells.forEach(((n,r)=>{oS(`RNNCell_${r}`,(()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]}))})),this.built=!0}getConfig(){let e=super.getConfig(),t=e=>({className:e.getClassName(),config:e.getConfig()}),n={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),n)}static fromConfig(e,t,n={}){let r=[];for(let a of t.cells)r.push(OT(a,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];let e=[];for(let t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){let e=[];for(let t of this.cells)e.push(...t.weights);return kN(e)}setWeights(e){let t=[];for(let n of this.cells){let r=n.weights.length,a=e.splice(r);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],a[e]])}IN(t)}};function RE(e){let{ones:t,rate:n,training:r=!1,count:a=1,dropoutFunc:s}=e,i=()=>null!=s?s(t(),n):BS(t(),n),o=()=>US(i,t,r);return!a||a<=1?Oo(o().clone()):Array(a).fill(void 0).map(o).map((e=>Oo(e.clone())))}$E.className="StackedRNNCells",kb.registerClass($E);var FE=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]])}return n},DE=class extends IE{constructor(e){if(e.unroll)throw new wI("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new wI("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new SN({ndim:5})]}call(e,t){return Do((()=>{if(null!=this.cell.dropoutMask&&(Mo(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Mo(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new vI("ConvRNN2D cell does not support constants");let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return Do((()=>{let{stateSize:t}=this.cell,n=e.shape,r=this.computeSingleOutputShape(n),a=[r[0],...r.slice(2)],s=Od(a);return Array.isArray(t)?Array(t.length).fill(s):[s]}))}resetStates(e,t=!1){Do((()=>{if(!this.stateful)throw new bI("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),a=[r[0],...r.slice(2)];if(null==n[0])throw new vI("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>Od(a))):this.states_=[Od(a)];else if(null==e)Mo(this.states_),null!=this.keptStates&&(Mo(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>Od(a))):this.states_[0]=Od(a);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new vI(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):Mo(this.states_);for(let t=0;t<this.states_.length;++t){let n=e[t],r=a;if(!Sa.arraysEqual(n.shape,r))throw new vI(`State ${t} is incompatible with layer ${this.name}: expected shape=${r}, received shape=${n.shape}`);this.states_[t]=n}}this.states_=this.states_.map((e=>Oo(e.clone())))}))}computeSingleOutputShape(e){let{dataFormat:t,filters:n,kernelSize:r,padding:a,strides:s,dilationRate:i}=this.cell,o="channelsFirst"===t,l=e[o?3:2],u=e[o?4:3],p=tE(l,r[0],a,s[0],i[0]),c=tE(u,r[1],a,s[1],i[1]);return[...e.slice(0,2),...o?[n,p,c]:[p,c,n]]}};DE.className="ConvRNN2D";var ME=class extends EE{constructor(e){let{filters:t,kernelSize:n,strides:r,padding:a,dataFormat:s,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,WI(this.filters,"filters"),this.kernelSize=eE(n,2,"kernelSize"),this.kernelSize.forEach((e=>WI(e,"kernelSize"))),this.strides=eE(r||1,2,"strides"),this.strides.forEach((e=>WI(e,"strides"))),this.padding=a||"valid",rS(this.padding),this.dataFormat=s||"channelsLast",tS(this.dataFormat),this.dilationRate=eE(i||1,2,"dilationRate"),this.dilationRate.forEach((e=>WI(e,"dilationRate")))}build(e){var t;e=yN(e);let n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new vI(`The channel dimension of the input should be defined. Found ${e[n]}`);let r=e[n],a=4,s=this.kernelSize.concat([r,this.filters*a]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let i=this.kernelSize.concat([this.filters,this.filters*a]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",i,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){let n=this.biasInitializer,r=this.filters;e=new(t=class extends qS{apply(e,t){let a=n.apply([r]),s=Pd([r]),i=n.apply([2*r]);return ES([a,s,i])}},t.className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*a],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return Do((()=>{if(3!==e.length)throw new vI(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training||!1,r=e[0],a=e[1],s=e[2],i=4;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=RE({ones:()=>nh(r),rate:this.dropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));let o=this.dropoutMask,l=(e,t,n)=>t&&t[n]?el(t[n],e):e,u=l(r,o,0),p=l(r,o,1),c=l(r,o,2),d=l(r,o,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=RE({ones:()=>nh(a),rate:this.recurrentDropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));let h=this.recurrentDropoutMask,f=l(a,h,0),m=l(a,h,1),g=l(a,h,2),y=l(a,h,3),b=3,[x,v,w,k]=sm(this.kernel.read(),i,b),[I,S,N,T]=this.useBias?sm(this.bias.read(),i):[null,null,null,null];u=this.inputConv(u,x,I,this.padding),p=this.inputConv(p,v,S,this.padding),c=this.inputConv(c,w,N,this.padding),d=this.inputConv(d,k,T,this.padding);let[_,C,E,A]=sm(this.recurrentKernel.read(),i,b);f=this.recurrentConv(f,_),m=this.recurrentConv(m,C),g=this.recurrentConv(g,E),y=this.recurrentConv(y,A);let $=this.recurrentActivation.apply(Ko(u,f)),R=this.recurrentActivation.apply(Ko(p,m)),F=Ko(el(R,s),el($,this.activation.apply(Ko(c,g)))),D=el(this.recurrentActivation.apply(Ko(d,y)),this.activation.apply(F));return[D,D,F]}))}getConfig(){let e=super.getConfig(),{units:t}=e,n=FE(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),r)}inputConv(e,t,n,r){let a=Wu(e,t,this.strides,r||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?PS(a,n,this.dataFormat):a}recurrentConv(e,t){return Wu(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}};ME.className="ConvLSTM2DCell",kb.registerClass(ME);var OE=class extends DE{constructor(e){let t=new ME(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}};OE.className="ConvLSTM2D",kb.registerClass(OE);var PE=class extends EN{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;let t=e.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(null==this.noiseShape[r]?t[r]:this.noiseShape[r]);return n}call(e,t){return Do((()=>{this.invokeCallHook(e,t);let n=gN(e);if(0<this.rate&&this.rate<1){let e=null!=t.training&&t.training,r=this.getNoiseShape(n);return US((()=>BS(n,this.rate,r,this.seed)),(()=>n),e)}return e}))}getConfig(){let e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}};PE.className="Dropout",kb.registerClass(PE);var LE=class extends PE{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){let t=e.shape;return[t[0],1,t[2]]}};LE.className="SpatialDropout1D",kb.registerClass(LE);var zE=class extends EN{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,WI(this.units,"units"),this.activation=LC(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=hN(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=hN(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=nT(e.kernelConstraint),this.biasConstraint=nT(e.biasConstraint),this.kernelRegularizer=qC(e.kernelRegularizer),this.biasRegularizer=qC(e.biasRegularizer),this.activityRegularizer=qC(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=yN(e);let t=e[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=yN(e);let t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return Do((()=>{this.invokeCallHook(e,t);let n,r=gN(e),a=GI(this.activation.getClassName());return null!=a?n=FS(r,this.kernel.read(),a,this.bias?this.bias.read():null):(n=FS(r,this.kernel.read()),null!=this.bias&&(n=PS(n,this.bias.read())),null!=this.activation&&(n=this.activation.apply(n))),n}))}getConfig(){let e={units:this.units,activation:OC(this.activation),useBias:this.useBias,kernelInitializer:dN(this.kernelInitializer),biasInitializer:dN(this.biasInitializer),kernelRegularizer:HC(this.kernelRegularizer),biasRegularizer:HC(this.biasRegularizer),activityRegularizer:HC(this.activityRegularizer),kernelConstraint:eT(this.kernelConstraint),biasConstraint:eT(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}};zE.className="Dense",kb.registerClass(zE);var BE=class extends EN{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=yN(e);for(let t of e.slice(1))if(null==t)throw new vI(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],mS(e,1)]}call(e,t){return Do((()=>{this.invokeCallHook(e,t);let n=gN(e);if("channelsFirst"===this.dataFormat&&n.rank>1){let e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=Jm(n,e)}return NS(n)}))}getConfig(){let e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);let t=super.getConfig();return Object.assign(e,t),e}};BE.className="Flatten",kb.registerClass(BE);var WE=class extends EN{constructor(e){super(e),this.supportsMasking=!0,this.activation=LC(e.activation)}call(e,t){return Do((()=>{this.invokeCallHook(e,t);let n=gN(e);return this.activation.apply(n)}))}getConfig(){let e={activation:OC(this.activation)},t=super.getConfig();return Object.assign(e,t),e}};WE.className="Activation",kb.registerClass(WE);var UE=class extends EN{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return Do((()=>(e=gN(e),IS(e,this.n))))}getConfig(){let e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}};UE.className="RepeatVector",kb.registerClass(UE);var VE=class extends EN{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){let n="Total size of new array must be unchanged.",r=t.slice(),a=1,s=null;for(let o=0;o<r.length;++o){let e=r[o];if(this.isUnknown(e)){if(null!==s)throw new vI("Can only specifiy one unknown dimension.");s=o}else a*=e}let i=mS(e);if(null!==s){if(0===a||i%a!==0)throw new vI(n);r[s]=i/a}else if(i!==a)throw new vI(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return Do((()=>{this.invokeCallHook(e,t);let n=gN(e),r=n.shape,a=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return ql(n,a)}))}getConfig(){let e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}};VE.className="Reshape",kb.registerClass(VE);var GE=class extends EN{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);let t=bS(1,e.dims.length+1);if(!Sa.arraysEqual(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new SN({ndim:this.dims.length+1})]}computeOutputShape(e){e=yN(e);let t=e.slice();return this.dims.forEach(((n,r)=>{t[r+1]=e[n]})),t}call(e,t){return Jm(gN(e),this.dimsIncludingBatch)}getConfig(){let e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}};GE.className="Permute",kb.registerClass(GE);var HE=class extends EN{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){let n=gN(e),r=-1;return dl(Zd(n,this.maskValue),r)}call(e,t){return Do((()=>{this.invokeCallHook(e,t);let n=gN(e),r=-1,a=!0,s=dl(Zd(n,this.maskValue),r,a);return el(n,wo(s,n.dtype))}))}};HE.className="Masking",kb.registerClass(HE);var jE=class extends EN{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(CI(e.inputLength))}this.inputDim=e.inputDim,WI(this.inputDim,"inputDim"),this.outputDim=e.outputDim,WI(this.outputDim,"outputDim"),this.embeddingsInitializer=hN(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=qC(e.embeddingsRegularizer),this.activityRegularizer=qC(e.activityRegularizer),this.embeddingsConstraint=nT(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return Do((()=>this.maskZero?(e=gN(e),Zd(e,_p(e))):null))}computeOutputShape(e){if(e=yN(e),null==this.inputLength)return[...e,this.outputDim];let t=CI(this.inputLength);if(t.length!==e.length-1)throw new vI(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let r=0;r<t.length;++r){let a=t[r],s=e[r+1];if(null!=a&&null!=s&&a!==s)throw new vI(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==a&&(t[n]=s),n++}}return[e[0],...t,this.outputDim]}call(e,t){return Do((()=>{this.invokeCallHook(e,t);let n=gN(e);"int32"!==n.dtype&&(n=wS(n,"int32"));let r=DS(this.embeddings.read(),ql(n,[n.size]));return ql(r,yN(this.computeOutputShape(n.shape)))}))}getConfig(){let e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:dN(this.embeddingsInitializer),embeddingsRegularizer:HC(this.embeddingsRegularizer),activityRegularizer:HC(this.activityRegularizer),embeddingsConstraint:eT(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}};jE.className="Embedding",kb.registerClass(jE);var qE=class extends EN{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new wI}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;let n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){let a=e[e.length-t.length+r],s=t[r];if(null==a||null==s||a<0||s<0)n.push(null);else if(1===a)n.push(s);else if(1===s)n.push(a);else{if(a!==s)throw new vI("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(a)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[yN(e)]),e.length<2)throw new vI(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(let a of e)null!=a&&null!==a[0]&&t.push(a[0]);if(t=PI(t),t.length>1)throw new vI(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=null==e[0]?null:e[0].slice(1);for(let a=1;a<e.length;++a){let t=null==e[a]?null:e[a].slice(1);n=this.computeElementwiseOpOutputShape(n,t)}let r=e.map((e=>e.length));-1===e.indexOf(null)&&1===PI(r).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return Do((()=>{if(this.reshapeRequired){let t=[],n=e.map((e=>e.rank));if(-1===n.indexOf(null)){let r=yS(n);for(let n of e){let e=n.rank;for(let t=0;t<r-e;++t)n=kS(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(let s of e){let e=s.rank;if(null==e){let e=s.shape,r=e[0],a=e.slice(1).concat([r]),i=ql(s,[r].concat(mS(e.slice(1))));i=Jm(i,[1,0]),i=ql(i,a),t.push(i),n=!0}else if(e>1){let r=bS(1,e).concat([0]);t.push(Jm(s,r)),n=!0}else t.push(s)}let r=this.mergeFunction(t),a=r.rank;if(n)if(null==a){let e=r.shape,t=e.length,n=e[t-1],a=[n].concat(e.slice(0,e.length-1));r=ql(Jm(ql(r,[-1,n]),[1,0]),a)}else if(a>1){let e=[a-1].concat(bS(0,a-1));r=Jm(r,e)}return r}}return this.mergeFunction(e)}))}computeOutputShape(e){let t;t=null==e[0]?null:e[0].slice(1);for(let r=1;r<e.length;++r){let n=null==e[r]?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,n)}let n=[];for(let r of e)null!=r&&null!==r[0]&&n.push(r[0]);return n=PI(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return Do((()=>{if(null==t)return null;if(!Array.isArray(t))throw new vI("`mask` should be an Array");if(!Array.isArray(e))throw new vI("`inputs` should be an Array");if(t.length!==e.length)throw new vI(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every((e=>null==e)))return null;t=t.map((e=>null==e?e:hc(e,0)));let n=t[0];for(let e=1;e<t.length-1;++e)n=md(n,t[e]);return n}))}},KE=class extends qE{constructor(e){super(e)}mergeFunction(e){return Do((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Ko(t,e[n]);return t}))}};KE.className="Add",kb.registerClass(KE);var XE=class extends qE{constructor(e){super(e)}mergeFunction(e){return Do((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=el(t,e[n]);return t}))}};XE.className="Multiply",kb.registerClass(XE);var JE=class extends qE{constructor(e){super(e)}mergeFunction(e){return Do((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Ko(t,e[n]);return el(1/e.length,t)}))}};JE.className="Average",kb.registerClass(JE);var YE=class extends qE{constructor(e){super(e)}mergeFunction(e){return Do((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Fd(t,e[n]);return t}))}};YE.className="Maximum",kb.registerClass(YE);var ZE=class extends qE{constructor(e){super(e)}mergeFunction(e){return Do((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Bd(t,e[n]);return t}))}};ZE.className="Minimum",kb.registerClass(ZE);var QE=class extends qE{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new vI("A `Concatenate` layer should be called on a list of at least 2 inputs");let t=!0;for(let r of e)if(null!=r){t=!1;break}if(t)return;let n=[];for(let r=0;r<e.length;++r){let t=e[r].slice();t.splice(this.axis,1);let a=!1;for(let e of n)if(Sa.arraysEqual(e,t)){a=!0;break}a||n.push(t)}if(n.length>1)throw new vI("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return Do((()=>ES(e,this.axis)))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new vI("A `Concatenate` layer should be called on a list of inputs.");let t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(let a of t.slice(1)){if(null==n[r]||null==a[r]){n[r]=null;break}n[r]+=a[r]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new vI("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new vI("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new vI(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return Do((()=>{let n=!0;if(t.forEach((e=>{null==e||(n=!1)})),n)return null;let r=[];for(let s=0;s<e.length;++s)null==t[s]?r.push(wo(nh(e[s]),"bool")):t[s].rank<e[s].rank?r.push(hc(t[s],-1)):r.push(t[s]);let a=Ql(r,this.axis);return pl(a,-1,!1)}))}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};function eA(e,t){for(;e<0;)e+=t;return e}function tA(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new wI("batchDot is not implemented for tensors of 4D or higher rank yet");if(Sa.assert(e.shape.length>=2,(()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`)),Sa.assert(e.shape.length>=2,(()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`)),"number"==typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new wI("batchDot is not implemented for complex64-type Tensors yet.");let r=e.shape.length,a=t.shape.length;null==n&&(n=[r-1,a-2]);let s=n;return Do((()=>{let n,i;if(r>a){n=r-a;let e=[];for(let t=0;t<n;++t)e.push(1);t=ql(t,t.shape.concat(e))}else if(a>r){n=a-r;let t=[];for(let e=0;e<n;++e)t.push(1);e=ql(e,e.shape.concat(t))}else n=0;if(2===e.shape.length&&2===t.shape.length)i=s[0]===s[1]?ac(el(e,t),s[0]):ac(el(Jm(e,[1,0]),t),s[1]);else{let n=s[0]!==e.shape.length-1,r=s[1]===t.shape.length-1;i=tu(e,t,n,r)}if(n>0){let e;e=r>a?r+a-3:r-1;let t=[];for(let r=e;r<e+n;++r)t.push(r);i=cm(i,t)}return 1===i.shape.length&&(i=hc(i,1)),i}))}QE.className="Concatenate",kb.registerClass(QE);var nA=class extends qE{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){Sa.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));let t=e[0],n=e[1];if(t.length>3||n.length>3)throw new wI("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new vI(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){if(2!==e.length)throw new vI(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t,n=e[0],r=e[1];return t=Array.isArray(this.axes)?this.axes.map(((t,n)=>eA(t,e[n].shape.length))):[eA(this.axes,n.shape.length),eA(this.axes,r.shape.length)],this.normalize&&(n=PT(n,t[0]),r=PT(r,t[1])),tA(n,r,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[eA(this.axes,e.length),eA(this.axes,t.length)],n}computeOutputShape(e){Sa.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));let t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new wI("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);let a=t.concat(n);return 1===a.length&&a.push(1),a}computeMask(e,t){return null}getConfig(){let e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}};nA.className="Dot",kb.registerClass(nA);var rA=class extends EN{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return Do((()=>{this.invokeCallHook(e,t);let n=gN(e);return US((()=>Ko(RS(n.shape,0,this.stddev),n)),(()=>n),t.training||!1)}))}};rA.className="GaussianNoise",kb.registerClass(rA);var aA=class extends EN{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Do((()=>{this.invokeCallHook(e,t);let n=gN(e);return this.rate>0&&this.rate<1?US((()=>{let e=Math.sqrt(this.rate/(1-this.rate));return el(n,RS(n.shape,1,e))}),(()=>n),t.training||!1):n}))}};aA.className="GaussianDropout",kb.registerClass(aA);var sA=class extends EN{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||gN(e).shape}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Do((()=>{if(this.rate<1&&this.rate>0){let n=this._getNoiseShape(e);return US((()=>{let t=gN(e),r=1.6732632423543772,a=1.0507009873554805,s=-r*a,i=_c(sf(n),this.rate);i=wS(i,"float32");let o=((1-this.rate)*(1+this.rate*s**2))**-.5,l=-o*s*this.rate,u=Ko(el(t,i),el(Ko(i,-1),s));return Ko(el(u,o),l)}),(()=>gN(e)),t.training||!1)}return e}))}};function iA(e,t,n,r,a,s=.001){let i;if(2===e.rank)i=gu(e,t,n,r,a,s);else if(3===e.rank)i=bu(e,t,n,r,a,s);else{if(4!==e.rank)throw new wI(`batchNormalization is not implemented for array of rank ${e.rank} yet`);i=vu(e,t,n,r,a,s)}return i}function oA(e,t,n,r,a=.001){return Do((()=>{let s=jd(e,r),i=s.mean,o=s.variance;return[iA(e,i,o,n,t,a),i,o]}))}function lA(e,t,n,r,a=.001){return Do((()=>{let s=jd(e,r),i=s.mean,o=s.variance,l=[];for(let t of bS(0,e.rank))-1!==r.indexOf(t)?l.push(1):l.push(e.shape[t]);let u=ql(i,l),p=ql(o,l),c=null==t?null:ql(t,l),d=null==n?null:ql(n,l);return[iA(e,u,p,d,c,a),i,o]}))}function uA(e,t,n,r,a=.001){return Sa.arraysEqual(r.slice().sort(),bS(0,e.rank-1))?oA(e,t,n,r,a):lA(e,t,n,r,a)}sA.className="AlphaDropout",kb.registerClass(sA);var pA=class extends EN{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=hN(e.betaInitializer||"zeros"),this.gammaInitializer=hN(e.gammaInitializer||"ones"),this.movingMeanInitializer=hN(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=hN(e.movingVarianceInitializer||"ones"),this.betaConstraint=nT(e.betaConstraint),this.gammaConstraint=nT(e.gammaConstraint),this.betaRegularizer=qC(e.betaRegularizer),this.gammaRegularizer=qC(e.gammaRegularizer)}build(e){e=yN(e);let t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new vI(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new SN({ndim:e.length,axes:{[t]:n}})];let r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return Do((()=>{let n=null!=t.training&&t.training,r=gN(e),a=r.shape,s=a.length,i=bS(0,s),o=this.axis>=0?this.axis:this.axis+s;i.splice(o,1);let l=SI(1,s);l[o]=a[o];let u=i.slice();u.sort();let p=!Sa.arraysEqual(u,bS(0,s).slice(0,s-1)),c=()=>{if(p){let e=ql(this.movingMean.read(),l),t=ql(this.movingVariance.read(),l),n=this.center?ql(this.beta.read(),l):null,a=this.scale?ql(this.gamma.read(),l):null;return iA(r,e,t,n,a,this.epsilon)}return iA(r,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)};if(!n)return c();let[d,h,f]=uA(r,this.gamma.read(),this.beta.read(),i,this.epsilon),m=(e,t,n)=>{Do((()=>{let r=1-n,a=e.read(),s=el(ud(a,t),r);e.write(ud(a,s))}))};return m(this.movingMean,h,this.momentum),m(this.movingVariance,f,this.momentum),d}))}getConfig(){let e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:dN(this.betaInitializer),gammaInitializer:dN(this.gammaInitializer),movingMeanInitializer:dN(this.movingMeanInitializer),movingVarianceInitializer:dN(this.movingVarianceInitializer),betaRegularizer:HC(this.betaRegularizer),gammaRegularizer:HC(this.gammaRegularizer),betaConstraint:eT(this.betaConstraint),gammaConstraint:eT(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}};pA.className="BatchNormalization",kb.registerClass(pA);var cA=class extends EN{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(let e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=hN(e.betaInitializer||"zeros"),this.gammaInitializer=hN(e.gammaInitializer||"ones"),this.betaRegularizer=qC(e.betaRegularizer),this.gammaRegularizer=qC(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=yN(e);let t=e.length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let a=0;a<this.axis.length;++a)this.axis[a]<0&&(this.axis[a]+=t);for(let a of this.axis)if(a<0||a>=t)throw new Error(`Invalid axis: ${a}`);if(this.axis.length!==PI(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let n=this.axis.map((t=>e[t])),r=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){let n=gN(e),r=n.shape,a=r.length;return Do((()=>{let{mean:e,variance:t}=jd(n,this.axis,!0),s=SI(1,a);for(let n of this.axis)s[n]=r[n];let i=e=>null!=e&&e.shape.length!==a?ql(e,s):e,o=this.scale?i(this.gamma.read()):null,l=this.center?i(this.beta.read()):null,u=[],p=[];for(let n=0;n<a;++n)-1!==this.axis.indexOf(n)?(u.push(r[n]),p.push(1)):(u.push(1),p.push(r[n]));return e=yc(e,u),t=yc(t,u),null!=o&&(o=yc(o,p)),null!=l&&(l=yc(l,p)),iA(n,e,t,l,o,this.epsilon)}))}getConfig(){let e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:dN(this.betaInitializer),gammaInitializer:dN(this.gammaInitializer),betaRegularizer:HC(this.betaRegularizer),gammaRegularizer:HC(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}};function dA(e,t,n){return Do((()=>{if(4!==e.rank)throw new vI(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(null==t&&(t=[[1,1],[1,1]]),2!==t.length||2!==t[0].length||2!==t[1].length)throw new vI("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==n&&(n=vS()),"channelsLast"!==n&&"channelsFirst"!==n)throw new vI(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return r="channelsFirst"===n?[[0,0],[0,0],t[0],t[1]]:[[0,0],t[0],t[1],[0,0]],ih(e,r)}))}cA.className="LayerNormalization",kb.registerClass(cA);var hA=class extends EN{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?vS():e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new vI(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if("number"==typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new vI(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],2!==e.padding[1].length)throw new vI(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new SN({ndim:4})]}computeOutputShape(e){let t,n;return e=yN(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return Do((()=>dA(gN(e),this.padding,this.dataFormat)))}getConfig(){let e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};function fA(e,t,n,r,a,s){return Do((()=>{tS(a),aS(s),rS(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==a&&(a=vS()),null==s&&(s="max"),e=rE(e,a);let i,o="same"===r?"same":"valid";return i="max"===s?_d(e,t,n,o):Xl(e,t,n,o),"channelsFirst"===a&&(i=Jm(i,[0,3,1,2])),i}))}function mA(e,t,n,r,a,s){return Do((()=>{tS(a),aS(s),rS(r),null==n&&(n=[1,1,1]),null==r&&(r="valid"),null==a&&(a=vS()),null==s&&(s="max"),e=aE(e,a);let i,o="same"===r?"same":"valid";return i="max"===s?Ed(e,t,n,o):Yl(e,t,n,o),"channelsFirst"===a&&(i=Jm(i,[0,4,1,2,3])),i}))}hA.className="ZeroPadding2D",kb.registerClass(hA);var gA=class extends EN{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"==typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!=typeof e.poolSize[0])throw new vI(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);this.poolSize=e.poolSize}if(WI(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"==typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!=typeof e.strides[0])throw new vI(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);this.strides=e.strides}WI(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,rS(this.padding),this.inputSpec=[new SN({ndim:3})]}computeOutputShape(e){e=yN(e);let t=tE(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return Do((()=>{this.invokeCallHook(e,t),e=kS(gN(e),2);let n=this.poolingFunction(gN(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return cm(n,[2])}))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}},yA=class extends gA{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return tS(a),rS(r),fA(e,t,n,r,a,"max")}};yA.className="MaxPooling1D",kb.registerClass(yA);var bA=class extends gA{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return tS(a),rS(r),fA(e,t,n,r,a,"avg")}};bA.className="AveragePooling1D",kb.registerClass(bA);var xA=class extends EN{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new vI(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];WI(this.poolSize,"poolSize"),WI(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,tS(this.dataFormat),rS(this.padding),this.inputSpec=[new SN({ndim:4})]}computeOutputShape(e){e=yN(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=tE(t,this.poolSize[0],this.padding,this.strides[0]),n=tE(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return Do((()=>(this.invokeCallHook(e,t),this.poolingFunction(gN(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},vA=class extends xA{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return tS(a),rS(r),fA(e,t,n,r,a,"max")}};vA.className="MaxPooling2D",kb.registerClass(vA);var wA=class extends xA{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return tS(a),rS(r),fA(e,t,n,r,a,"avg")}};wA.className="AveragePooling2D",kb.registerClass(wA);var kA=class extends EN{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new vI(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];WI(this.poolSize,"poolSize"),WI(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,tS(this.dataFormat),rS(this.padding),this.inputSpec=[new SN({ndim:5})]}computeOutputShape(e){e=yN(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[4]:e[3];return t=tE(t,this.poolSize[0],this.padding,this.strides[0]),n=tE(n,this.poolSize[1],this.padding,this.strides[1]),r=tE(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return Do((()=>(this.invokeCallHook(e,t),this.poolingFunction(gN(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},IA=class extends kA{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return tS(a),rS(r),mA(e,t,n,r,a,"max")}};IA.className="MaxPooling3D",kb.registerClass(IA);var SA=class extends kA{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return tS(a),rS(r),mA(e,t,n,r,a,"avg")}};SA.className="AveragePooling3D",kb.registerClass(SA);var NA=class extends EN{constructor(e){super(e),this.inputSpec=[new SN({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new wI}},TA=class extends NA{constructor(e){super(e||{})}call(e,t){return Do((()=>{let t=gN(e);return Md(t,1)}))}};TA.className="GlobalAveragePooling1D",kb.registerClass(TA);var _A=class extends NA{constructor(e){super(e||{})}call(e,t){return Do((()=>{let t=gN(e);return qp(t,1)}))}};_A.className="GlobalMaxPooling1D",kb.registerClass(_A);var CA=class extends EN{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,tS(this.dataFormat),this.inputSpec=[new SN({ndim:4})]}computeOutputShape(e){return"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new wI}getConfig(){let e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},EA=class extends CA{call(e,t){return Do((()=>{let t=gN(e);return"channelsLast"===this.dataFormat?Md(t,[1,2]):Md(t,[2,3])}))}};EA.className="GlobalAveragePooling2D",kb.registerClass(EA);var AA=class extends CA{call(e,t){return Do((()=>{let t=gN(e);return"channelsLast"===this.dataFormat?qp(t,[1,2]):qp(t,[2,3])}))}};AA.className="GlobalMaxPooling2D",kb.registerClass(AA);var $A=class extends EN{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){let e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){let r=t.layer,a=OT(r,n);delete t.layer;let s={layer:a};return Object.assign(s,t),new e(s)}},RA=class extends $A{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=yN(e),e.length<3)throw new vI(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];let t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=yN(e);let t=[e[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))}call(e,t){return Do((()=>(e=gN(e),kE(((e,n)=>[gN(this.layer.call(e,t)),[]]),e,[],!1,null,null,!1,!0)[1])))}};function FA(e){zI(QI,"BidirectionalMergeMode",e)}RA.className="TimeDistributed",kb.registerClass(RA);var DA="concat",MA=class extends $A{constructor(e){super(e);let t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=OT(n),t.goBackwards=!0!==t.goBackwards;let r={};if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=OT(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?DA:e.mergeMode,FA(this.mergeMode),e.weights)throw new wI("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){let t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t,n,r,a=this.forwardLayer.computeOutputShape(e);return Array.isArray(a)&&Array.isArray(a[0])||(a=[a]),this.returnState&&(r=a.slice(1)),t=a[0],"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[t].concat(r).concat(r.slice()):_I(n)}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});let a=wE(e,n,r,this.numConstants);if(e=a.inputs,n=a.initialState,r=a.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==r)return super.apply(e,t);let s=[],i=[];if(null!=n){let e=n.length;if(e%2>0)throw new vI("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,s.push(...n);let r=n.map((e=>new SN({shape:e.shape})));this.forwardLayer.stateSpec=r.slice(0,e/2),this.backwardLayer.stateSpec=r.slice(e/2),i.push(...r)}if(null!=r)throw new wI("Support for constants in Bidirectional layers is not implemented yet.");let o=s[0]instanceof NN;for(let l of s)if(l instanceof NN!==o)throw new vI("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){let n=[e].concat(s),r=this.inputSpec.concat(i),a=this.inputSpec;this.inputSpec=r;let o=super.apply(n,t);return this.inputSpec=a,o}return super.apply(e,t)}call(e,t){return Do((()=>{let n,r,a,s,i=t.initialState;if(null==i)n=this.forwardLayer.call(e,t),r=this.backwardLayer.call(e,t);else{let a=i.slice(0,i.length/2),s=i.slice(i.length/2);n=this.forwardLayer.call(e,Object.assign(t,{initialState:a})),r=this.backwardLayer.call(e,Object.assign(t,{initialState:s}))}return this.returnState&&(Array.isArray(n)&&(a=n.slice(1).concat(r.slice(1))),n=n[0],r=r[0]),this.returnSequences&&(r=yf(r,1)),"concat"===this.mergeMode?s=ES([n,r]):"sum"===this.mergeMode?s=Ko(n,r):"ave"===this.mergeMode?s=el(.5,Ko(n,r)):"mul"===this.mergeMode?s=el(n,r):null==this.mergeMode&&(s=[n,r]),this.returnState?null==this.mergeMode?s.concat(a):[s].concat(a):s}))}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){oS(this.forwardLayer.name,(()=>{this.forwardLayer.build(e)})),oS(this.backwardLayer.name,(()=>{this.backwardLayer.build(e)})),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){let e=this.forwardLayer.states.map((e=>null));return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){let e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){let n=OT(t.layer);if(delete t.layer,null!=t.numConstants)throw new wI("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let r=t;return r.layer=n,new e(r)}};MA.className="Bidirectional",kb.registerClass(MA);var OA=class extends EN{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){let e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return Do((()=>(e=gN(e),"float32"!==e.dtype&&(e=wS(e,"float32")),Ko(el(e,this.scale),this.offset))))}};OA.className="Rescaling",kb.registerClass(OA);var{resizeBilinear:PA,cropAndResize:LA}=yb,zA=class extends EN{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,r,a,s,i,o){return Do((()=>{let l,u=!1,p=t/s,c=n/i,d=(r+t)/s,h=(a+n)/i,f=[p,c,d,h],m=[];3===e.rank?(u=!0,l=hm([e])):l=e;for(let e=0;e<l.shape[0];e++)m.push(f);let g=li(m,[m.length,4]),y=of(0,m.length,1,"int32"),b=LA(l,g,y,[r,a],"nearest");return wS(u?gN(Wm(b)):b,o)}))}upsize(e,t,n,r){return Do((()=>{let a=PA(e,[t,n]);return wS(a,r)}))}call(e,t){return Do((()=>{let t=gN(e),n=t.dtype,r=t.shape,a=r[r.length-3],s=r[r.length-2],i=0;a!==this.height&&(i=Math.floor((a-this.height)/2));let o=0;return s!==this.width&&(o=Math.floor((s-this.width)/2),0===o&&(o=1)),i>=0&&o>=0?this.centerCrop(t,i,o,this.height,this.width,a,s,n):this.upsize(e,this.height,this.width,n)}))}getConfig(){let e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=yN(e);let t=e.length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}};function BA(e,t,n,r){let a=gN(e);if("int32"!==a.dtype&&(a=wS(a,"int32")),"int"===t)return a;let s=a.shape;if(0===a.rank&&(a=hc(a,-1)),"oneHot"===t&&1!==a.shape[a.shape.length-1]&&(a=hc(a,-1)),a.rank>2)throw new vI(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${s} which would result in output rank ${a.rank}.`);let i,o=["multiHot","oneHot"].includes(t),l=a;if(i=up(l,"undefined"!=typeof r&&"count"===t?r:[],n,o),"tfIdf"!==t)return i;if(r)return el(i,r);throw new vI("When outputMode is 'tfIdf', weights must be provided.")}zA.className="CenterCrop",kb.registerClass(zA);var WA=class extends EN{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){let e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=yN(e),null==e?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return Do((()=>{let n;if(e=gN(e),"int32"!==e.dtype&&(e=wS(e,"int32")),"undefined"!=typeof t.countWeights){if("count"!==this.outputMode)throw new vI(`countWeights is not used when outputMode !== count.\n              Received countWeights=${t.countWeights}`);n=gN(t.countWeights)}let r=qp(e),a=Xp(e),s=Nc(this.numTokens,r).bufferSync().get(0),i=_c(a,0).bufferSync().get(0);if(!s||!i)throw new vI(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return BA(e,this.outputMode,this.numTokens,n)}))}};WA.className="CategoryEncoding",kb.registerClass(WA);var UA=["bilinear","nearest"],VA=new Set(UA),GA=class extends EN{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!VA.has(e.interpolation))throw new vI(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=yN(e);let t=e[2];return[this.height,this.width,t]}getConfig(){let e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return Do((()=>{let t=[this.height,this.width];if("bilinear"===this.interpolation)return yb.resizeBilinear(e,t,!this.cropToAspectRatio);if("nearest"===this.interpolation)return yb.resizeNearestNeighbor(e,t,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...VA]} are supported`)}))}};function HA(e){return new FN(e)}function jA(e){return new YC(e)}function qA(e){return new KC(e)}function KA(e){return new XC(e)}function XA(e){return new JC(e)}function JA(e){return new QC(e)}function YA(e){return new ZC(e)}function ZA(e){return new gE(e)}function QA(e){return new pE(e)}function e$(e){return new dE(e)}function t$(e){return new cE(e)}function n$(e){return new hE(e)}function r$(e){return new mE(e)}function a$(e){return new yE(e)}function s$(e){return new bE(e)}function i$(e){return new vE(e)}function o$(e){return new WE(e)}function l$(e){return new zE(e)}function u$(e){return new PE(e)}function p$(e){return new LE(e)}function c$(e){return new BE(e)}function d$(e){return new UE(e)}function h$(e){return new VE(e)}function f$(e){return new GE(e)}function m$(e){return new jE(e)}function g$(e){return new KE(e)}function y$(e){return new JE(e)}function b$(e){return new QE(e)}function x$(e){return new YE(e)}function v$(e){return new ZE(e)}function w$(e){return new XE(e)}function k$(e){return new nA(e)}function I$(e){return new pA(e)}function S$(e){return new cA(e)}function N$(e){return new hA(e)}function T$(e){return new bA(e)}function _$(e){return T$(e)}function C$(e){return T$(e)}function E$(e){return new wA(e)}function A$(e){return E$(e)}function $$(e){return E$(e)}function R$(e){return new SA(e)}function F$(e){return R$(e)}function D$(e){return R$(e)}function M$(e){return new TA(e)}function O$(e){return new EA(e)}function P$(e){return new _A(e)}function L$(e){return new AA(e)}function z$(e){return new yA(e)}function B$(e){return new vA(e)}function W$(e){return new IA(e)}function U$(e){return new CE(e)}function V$(e){return new _E(e)}function G$(e){return new AE(e)}function H$(e){return new EE(e)}function j$(e){return new TE(e)}function q$(e){return new NE(e)}function K$(e){return new OE(e)}function X$(e){return new ME(e)}function J$(e){return new IE(e)}function Y$(e){return new $E(e)}function Z$(e){return new MA(e)}function Q$(e){return new RA(e)}GA.className="Resizing",kb.registerClass(GA);var eR=P$,tR=L$,nR=z$,rR=B$;function aR(e){return new rA(e)}function sR(e){return new aA(e)}function iR(e){return new sA(e)}function oR(e){return new HE(e)}function lR(e){return new OA(e)}function uR(e){return new zA(e)}function pR(e){return new GA(e)}function cR(e){return new WA(e)}var dR={};function hR(e,t){return t_(e,t)}function fR(e,t){return l_(e,t)}function mR(e,t){return u_(e,t)}function gR(e,t){return n_(e,t)}function yR(e,t){return g_(e,t)}function bR(e,t){return i_(e,t)}function xR(e,t){return o_(e,t)}function vR(e,t){return ZT(e,t)}function wR(e,t){return zT(e,t)}function kR(e,t){return BT(e,t)}function IR(e,t){return BT(e,t)}function SR(e,t){return BT(e,t)}function NR(e,t){return LT(e,t)}function TR(e,t){return LT(e,t)}function _R(e,t){return LT(e,t)}g(dR,{MAPE:()=>IR,MSE:()=>TR,binaryAccuracy:()=>hR,binaryCrossentropy:()=>fR,categoricalAccuracy:()=>gR,categoricalCrossentropy:()=>yR,cosineProximity:()=>vR,mape:()=>SR,meanAbsoluteError:()=>wR,meanAbsolutePercentageError:()=>kR,meanSquaredError:()=>NR,mse:()=>_R,precision:()=>bR,recall:()=>xR,sparseCategoricalAccuracy:()=>mR});var CR={};g(CR,{modelFromJSON:()=>dC});var ER={};function AR(e){return new WC(e)}function $R(e){return UC(e)}function RR(e){return VC(e)}g(ER,{l1:()=>$R,l1l2:()=>AR,l2:()=>RR});var FR=class extends CT{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof pC))throw new Error("model must be a LayersModel, not some other Container");this.model=e}};function DR(e,t){return e<t}function MR(e,t){return e>t}var OR=class extends FR{constructor(e){if(super(),null==e&&(e={}),e.restoreBestWeights)throw new wI("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,-1===["auto","min","max"].indexOf(this.mode)&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),"min"===this.mode?this.monitorFunc=DR:"max"===this.mode||-1!==this.monitor.indexOf("acc")?this.monitorFunc=MR:this.monitorFunc=DR,this.monitorFunc===DR&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,null!=this.baseline?this.best=this.baseline:this.best=this.monitorFunc===DR?1/0:-1/0}async onEpochEnd(e,t){await NT(t);let n=this.getMonitorValue(t);null!=n&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){null==e&&(e={});let t=e[this.monitor];return null==t&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}};function PR(e){return new OR(e)}var LR,zR,BR={earlyStopping:PR},WR=We();WR.registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"}(LR||(LR={})),function(e){let t;(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(zR||(zR={}));var UR={};function VR(e,t){let n={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t};UR[e]=n}function GR(e){return UR[e]}function HR(e){delete UR[e]}function jR(e,t,n,r,a){let s=t.inputParams[e];if(s&&void 0!==s.inputIndexStart){let e=s.inputIndexStart,i=0===s.inputIndexEnd?void 0:void 0===s.inputIndexEnd?e+1:s.inputIndexEnd,o=e<0?t.inputNames.length+e:e;if("tensor"===s.type)return qR(t.inputNames[o],n,r,a);if("tensors"===s.type){let s=t.inputs.slice(e,i);return t.inputNames.slice(e,i).filter(((e,t)=>{var n;return"NoOp"!==(null===(n=s[t])||void 0===n?void 0:n.op)})).map((e=>qR(e,n,r,a)))}let l=qR(t.inputNames[o],n,r,a),u=l.dataSync();return"number"===s.type?u[0]:Sa.toNestedArray(l.shape,u)}let i=t.attrParams[e];return i&&i.value}function qR(e,t,n,r){let[a,s]=YR(e,n);if(null!=r){let e=r.getHashTableHandleByName(a);if(null!=e)return e}let i=n.currentContextIds.find((e=>!!t[JR(a,e)]));return void 0!==i?t[JR(a,i)][s]:void 0}function KR(e,t,n){return t[JR(e,n.currentContextId)]}function XR(e,t){let[n,r,a]=YR(e,t);return[JR(n,t&&t.currentContextId),r,a]}function JR(e,t){return t?`${e}-${t}`:e}function YR(e,t){if(""===e)return["",0,void 0];let n=null!=t&&null!=t.parseNodeNameCache;if(n){let n=t.parseNodeNameCache.get(e);if(null!=n)return n}let r,a=e.split(":");if(1===a.length)r=[e,0,void 0];else{let e=a[0],t=3===a.length?a[1]:void 0,n=Number(a[a.length-1]);r=[e,n,t]}return n&&t.parseNodeNameCache.set(e,r),r}function ZR(e,t,n){let r=jR("pad",e,t,n);if("explicit"===r){r=jR("explicitPaddings",e,t,n);let a=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)a[e][0]=r[2*e],a[e][1]=r[2*e+1];return a}return r}function QR(e){return e.kept?e:Io(e)}var eF={};g(eF,{json:()=>tF});var tF=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],nF={};g(nF,{json:()=>rF});var rF=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],aF={};g(aF,{json:()=>sF});var sF=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],iF={};g(iF,{json:()=>oF});var oF=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],lF={};g(lF,{json:()=>uF});var uF=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],pF={};g(pF,{json:()=>cF});var cF=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],dF={};g(dF,{json:()=>hF});var hF=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],fF={};g(fF,{json:()=>mF});var mF=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],gF={};g(gF,{json:()=>yF});var yF=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],bF={};g(bF,{json:()=>xF});var xF=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],vF={};g(vF,{json:()=>wF});var wF=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],kF={};g(kF,{json:()=>IF});var IF=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],SF={};g(SF,{json:()=>NF});var NF=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],TF={};g(TF,{json:()=>_F});var _F=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],CF={};g(CF,{json:()=>EF});var EF=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],AF={};g(AF,{json:()=>$F});var $F=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],RF={};g(RF,{json:()=>FF});var FF=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],DF={};g(DF,{json:()=>MF});var MF=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],OF={};g(OF,{json:()=>PF});var PF=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],LF=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let e=[eF,nF,aF,iF,lF,pF,dF,fF,gF,bF,vF,kF,SF,TF,CF,AF,RF,DF,OF],t=[].concat(...e.map((e=>e.json)));this.opMappers=t.reduce(((e,t)=>(e[t.tfOpName]=t,e)),{})}transformGraph(e,t={}){let n=e.node,r=[],a=[],s=[],i=n.reduce(((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?r.push(e[t.name]):"Const"===t.op?a.push(e[t.name]):(null==t.input||0===t.input.length)&&s.push(e[t.name]),e)),{}),o=[],l=[],u={},p={};null!=t&&(u=this.mapSignatureEntries(t.inputs),p=this.mapSignatureEntries(t.outputs));let c=Object.keys(i);c.forEach((e=>{let t=i[e];t.inputNames.forEach(((e,n)=>{let[r,,a]=XR(e),s=i[r];if(null!=s.outputs){let e=s.outputs.indexOf(a);if(-1!==e){let a=`${r}:${e}`;t.inputNames[n]=a}}t.inputs.push(s),s.children.push(t)}))})),0===Object.keys(p).length?c.forEach((e=>{let t=i[e];0===t.children.length&&l.push(t)})):Object.keys(p).forEach((e=>{let[t]=XR(e),n=i[t];null!=n&&(n.signatureKey=p[e],l.push(n))})),Object.keys(u).length>0?Object.keys(u).forEach((e=>{let[t]=XR(e),n=i[t];n&&(n.signatureKey=u[e],o.push(n))})):o=r;let d={};null!=e.library&&null!=e.library.function&&(d=e.library.function.reduce(((e,t)=>(e[t.signature.name]=this.mapFunction(t),e)),{}));let h={nodes:i,inputs:o,outputs:l,weights:a,placeholders:r,signature:t,functions:d};return s.length>0&&(h.initNodes=s),h}mapSignatureEntries(e){return Object.keys(e||{}).reduce(((t,n)=>(t[e[n].name]=n,t)),{})}mapNode(e){let t=GR(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});let n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map((e=>e.startsWith("^")?e.slice(1):e)),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(n.inputParams=t.inputs.reduce(((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e)),{})),null!=t.attrs&&(n.attrParams=t.attrs.reduce(((t,n)=>{let r,a=n.type;switch(n.type){case"string":r=WF(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=WF(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":r=YF(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=YF(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":r=VF(e.attr,n.tfName,n.defaultValue||0),void 0===r&&n.tfDeprecatedName&&(r=VF(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":r=JF(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=JF(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":r=UF(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=UF(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":r=QF(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=QF(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":r=XF(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=XF(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":r=ZF(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=ZF(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":r=jF(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=jF(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":r=qF(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=qF(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":r=HF(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=HF(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${n.type} for op: ${e.op}`)}return t[n.name]={value:r,type:a},t}),{})),n}mapFunction(e){let t=e.nodeDef,n=[],r=[],a={};null!=t&&(a=t.reduce(((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&r.push(e[t.name]),e)),{}));let s=[],i=[];e.signature.inputArg.forEach((e=>{let[t]=XR(e.name),n={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:GF(e.type),type:"dtype"}},children:[]};n.signatureKey=e.name,s.push(n),a[t]=n})),Object.keys(a).forEach((e=>{let t=a[e];t.inputNames.forEach(((e,n)=>{let[r,,s]=XR(e),i=a[r];if(null!=i.outputs){let e=i.outputs.indexOf(s);if(-1!==e){let a=`${r}:${e}`;t.inputNames[n]=a}}t.inputs.push(i),i.children.push(t)}))}));let o=e.ret;e.signature.outputArg.forEach((e=>{let[t,n]=XR(o[e.name]),r=a[t];null!=r&&(r.defaultOutput=n,i.push(r))}));let l=this.mapArgsToSignature(e);return{nodes:a,inputs:s,outputs:i,weights:r,placeholders:n,signature:l}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce(((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e)),{}),outputs:e.signature.outputArg.reduce(((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t)),{})}}mapArgToTensorInfo(e,t){let n=e.name;return null!=t&&(n=t[n]),{name:n,dtype:e.type}}};function zF(e){let t=We().global;if("undefined"!=typeof t.atob)return t.atob(e);if("undefined"!=typeof Buffer)return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function BF(e,t){let n=Array.isArray(e)?String.fromCharCode.apply(null,e):zF(e);return t?n:n.toLowerCase()}function WF(e,t,n,r=!1){let a=e[t];return null!=a?BF(a.s,r):n}function UF(e,t,n){let r=e[t];return r?r.b:n}function VF(e,t,n){let r=e[t]||{},a=null!=r.i?r.i:null!=r.f?r.f:n;return"number"==typeof a?a:parseInt(a,10)}function GF(e){switch("string"==typeof e&&(e=LR[e]),e){case LR.DT_FLOAT:case LR.DT_HALF:return"float32";case LR.DT_INT32:case LR.DT_INT64:case LR.DT_INT8:case LR.DT_UINT8:return"int32";case LR.DT_BOOL:return"bool";case LR.DT_DOUBLE:return"float32";case LR.DT_STRING:return"string";default:return null}}function HF(e,t,n){let r=e[t];return r&&r.func?r.func.name:n}function jF(e,t,n){let r=e[t];return r&&r.type?GF(r.type):n}function qF(e,t,n){let r=e[t];return r&&r.list&&r.list.type?r.list.type.map((e=>GF(e))):n}function KF(e){if(!e.unknownRank)return null!=e.dim?e.dim.map((e=>"number"==typeof e.size?e.size:parseInt(e.size,10))):[]}function XF(e,t,n){let r=e[t];return r&&r.shape?KF(r.shape):n}function JF(e,t,n){let r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map((e=>"number"==typeof e?e:parseInt(e,10))):n}function YF(e,t,n,r=!1){let a=e[t];return a&&a.list&&a.list.s?a.list.s.map((e=>BF(e,r))):n}function ZF(e,t,n){let r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map((e=>KF(e))):n}function QF(e,t,n){let r=e[t];return r&&r.list&&r.list.b?r.list.b:n}var eD=class{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map((e=>this.getInput(e))),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce(((e,t)=>(e[t]=this.getAttr(t),e)),{}))}getInput(e){return qR(e,this.tensorMap,this.context)}getAttr(e,t){let n=this.node.rawAttrs[e];if(null!=n.tensor)return qR(e,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return VF(this.node.rawAttrs,e,t);if(null!=n.s)return WF(this.node.rawAttrs,e,t);if(null!=n.b)return UF(this.node.rawAttrs,e,t);if(null!=n.shape)return XF(this.node.rawAttrs,e,t);if(null!=n.type)return jF(this.node.rawAttrs,e,t);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return JF(this.node.rawAttrs,e,t);if(null!=n.list.s)return YF(this.node.rawAttrs,e,t);if(null!=n.list.shape)return ZF(this.node.rawAttrs,e,t);if(null!=n.list.b)return QF(this.node.rawAttrs,e,t);if(null!=n.list.type)return qF(this.node.rawAttrs,e,t)}return t}},tD={};g(tD,{OP_SCOPE_SUFFIX:()=>ri,abs:()=>nl,acos:()=>al,acosh:()=>il,add:()=>Ko,addN:()=>ll,all:()=>pl,any:()=>dl,argMax:()=>fl,argMin:()=>gl,asin:()=>bl,asinh:()=>vl,atan:()=>kl,atan2:()=>Sl,atanh:()=>Tl,avgPool:()=>Xl,avgPool3d:()=>Yl,basicLSTMCell:()=>uu,batchNorm:()=>fu,batchNorm2d:()=>gu,batchNorm3d:()=>bu,batchNorm4d:()=>vu,batchToSpaceND:()=>cu,bincount:()=>ku,booleanMaskAsync:()=>Km,broadcastArgs:()=>Su,broadcastTo:()=>Tu,buffer:()=>xo,cast:()=>wo,ceil:()=>Cu,clipByValue:()=>$u,clone:()=>Io,complex:()=>ii,concat:()=>Ql,concat1d:()=>Fu,concat2d:()=>Mu,concat3d:()=>Pu,concat4d:()=>zu,conv1d:()=>Vu,conv2d:()=>Wu,conv2dTranspose:()=>qu,conv3d:()=>Xu,conv3dTranspose:()=>Qu,cos:()=>tp,cosh:()=>rp,cosineWindow:()=>pg,cumprod:()=>sp,cumsum:()=>op,denseBincount:()=>up,depthToSpace:()=>cp,depthwiseConv2d:()=>hp,diag:()=>mp,dilation2d:()=>yp,div:()=>Zo,divNoNan:()=>Ep,dot:()=>$p,dropout:()=>lg,einsum:()=>Fp,elu:()=>Mp,enclosingPowerOfTwo:()=>ug,equal:()=>Ip,erf:()=>Pp,euclideanNorm:()=>uc,exp:()=>cc,expandDims:()=>hc,expm1:()=>mc,eye:()=>xc,fft:()=>Qf,fill:()=>Eu,floor:()=>wc,floorDiv:()=>Jo,fused:()=>hg,gather:()=>Ic,gatherND:()=>sg,greater:()=>Nc,greaterEqual:()=>_c,ifft:()=>tm,imag:()=>Ec,image:()=>yb,inTopKAsync:()=>dg,irfft:()=>rm,isFinite:()=>$c,isInf:()=>Fc,isNaN:()=>Mc,leakyRelu:()=>Pc,less:()=>zc,lessEqual:()=>Wc,linalg:()=>bb,linspace:()=>Uc,localResponseNormalization:()=>Gc,log:()=>jc,log1p:()=>Kc,logSigmoid:()=>od,logSoftmax:()=>cd,logSumExp:()=>hd,logicalAnd:()=>md,logicalNot:()=>yd,logicalOr:()=>xd,logicalXor:()=>wd,losses:()=>xb,lowerBound:()=>Nd,matMul:()=>tu,max:()=>qp,maxPool:()=>_d,maxPool3d:()=>Ed,maxPoolWithArgmax:()=>$d,maximum:()=>Fd,mean:()=>Md,meshgrid:()=>Ld,min:()=>Xp,minimum:()=>Bd,mirrorPad:()=>Ud,mod:()=>Gd,moments:()=>jd,movingAverage:()=>Zm,mul:()=>el,multiRNNCell:()=>Kd,multinomial:()=>Jd,neg:()=>rd,norm:()=>oc,notEqual:()=>Zd,oneHot:()=>eh,ones:()=>Pd,onesLike:()=>nh,op:()=>ai,outerProduct:()=>ah,pad:()=>ih,pad1d:()=>lh,pad2d:()=>ph,pad3d:()=>dh,pad4d:()=>fh,pool:()=>vh,pow:()=>Yp,prelu:()=>kh,print:()=>So,prod:()=>Sh,raggedGather:()=>Th,raggedRange:()=>Ch,raggedTensorToTensor:()=>Ah,rand:()=>Rh,randomGamma:()=>Qh,randomNormal:()=>tf,randomStandardNormal:()=>rf,randomUniform:()=>sf,range:()=>of,real:()=>uf,reciprocal:()=>cf,relu:()=>hf,relu6:()=>mf,reshape:()=>ql,reverse:()=>yf,reverse1d:()=>xf,reverse2d:()=>wf,reverse3d:()=>If,reverse4d:()=>Nf,rfft:()=>om,round:()=>_f,rsqrt:()=>Ef,scalar:()=>Zp,scatterND:()=>eg,searchSorted:()=>Sd,selu:()=>$f,separableConv2d:()=>Ff,setdiff1dAsync:()=>Mf,sigmoid:()=>ru,sign:()=>Pf,signal:()=>gb,sin:()=>zf,sinh:()=>Wf,slice:()=>su,slice1d:()=>Vf,slice2d:()=>Hf,slice3d:()=>qf,slice4d:()=>Xf,softmax:()=>Yf,softplus:()=>sd,spaceToBatchND:()=>gh,sparse:()=>vb,sparseToDense:()=>rg,spectral:()=>mb,split:()=>sm,sqrt:()=>ec,square:()=>nc,squaredDifference:()=>um,squeeze:()=>cm,stack:()=>hm,step:()=>mm,stridedSlice:()=>ym,string:()=>wb,sub:()=>ud,sum:()=>ac,tan:()=>xm,tanh:()=>ou,tensor:()=>li,tensor1d:()=>vm,tensor2d:()=>wm,tensor3d:()=>km,tensor4d:()=>Im,tensor5d:()=>Sm,tensor6d:()=>Nm,tensorScatterUpdate:()=>$m,tile:()=>yc,topk:()=>Fm,transpose:()=>Jm,truncatedNormal:()=>Mm,unique:()=>Pm,unsortedSegmentSum:()=>zm,unstack:()=>Wm,upperBound:()=>Um,variable:()=>Vm,where:()=>Np,whereAsync:()=>jm,zeros:()=>Od,zerosLike:()=>_p});var nD=(e,t,n,r=tD)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(jR("a",e,t,n),jR("b",e,t,n))];case"AddN":return[r.addN(jR("tensors",e,t,n))];case"FloorMod":case"Mod":return[r.mod(jR("a",e,t,n),jR("b",e,t,n))];case"Mul":return[r.mul(jR("a",e,t,n),jR("b",e,t,n))];case"RealDiv":case"Div":return[r.div(jR("a",e,t,n),jR("b",e,t,n))];case"DivNoNan":return[r.divNoNan(jR("a",e,t,n),jR("b",e,t,n))];case"FloorDiv":return[r.floorDiv(jR("a",e,t,n),jR("b",e,t,n))];case"Sub":return[r.sub(jR("a",e,t,n),jR("b",e,t,n))];case"Minimum":return[r.minimum(jR("a",e,t,n),jR("b",e,t,n))];case"Maximum":return[r.maximum(jR("a",e,t,n),jR("b",e,t,n))];case"Pow":return[r.pow(jR("a",e,t,n),jR("b",e,t,n))];case"SquaredDifference":return[r.squaredDifference(jR("a",e,t,n),jR("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},rD=(e,t,n,r=tD)=>{switch(e.op){case"Abs":case"ComplexAbs":return[r.abs(jR("x",e,t,n))];case"Acos":return[r.acos(jR("x",e,t,n))];case"Acosh":return[r.acosh(jR("x",e,t,n))];case"Asin":return[r.asin(jR("x",e,t,n))];case"Asinh":return[r.asinh(jR("x",e,t,n))];case"Atan":return[r.atan(jR("x",e,t,n))];case"Atan2":return[r.atan2(jR("x",e,t,n),jR("y",e,t,n))];case"Atanh":return[r.atanh(jR("x",e,t,n))];case"Ceil":return[r.ceil(jR("x",e,t,n))];case"Complex":return[r.complex(jR("real",e,t,n),jR("imag",e,t,n))];case"Cos":return[r.cos(jR("x",e,t,n))];case"Cosh":return[r.cosh(jR("x",e,t,n))];case"Elu":return[r.elu(jR("x",e,t,n))];case"Erf":return[r.erf(jR("x",e,t,n))];case"Exp":return[r.exp(jR("x",e,t,n))];case"Expm1":return[r.expm1(jR("x",e,t,n))];case"Floor":return[r.floor(jR("x",e,t,n))];case"Log":return[r.log(jR("x",e,t,n))];case"Log1p":return[r.log1p(jR("x",e,t,n))];case"Imag":return[r.imag(jR("x",e,t,n))];case"Neg":return[r.neg(jR("x",e,t,n))];case"Reciprocal":return[r.reciprocal(jR("x",e,t,n))];case"Real":return[r.real(jR("x",e,t,n))];case"Relu":return[r.relu(jR("x",e,t,n))];case"Round":return[r.round(jR("x",e,t,n))];case"Selu":return[r.selu(jR("x",e,t,n))];case"Sigmoid":return[r.sigmoid(jR("x",e,t,n))];case"Sin":return[r.sin(jR("x",e,t,n))];case"Sign":return[r.sign(jR("x",e,t,n))];case"Sinh":return[r.sinh(jR("x",e,t,n))];case"Softplus":return[r.softplus(jR("x",e,t,n))];case"Sqrt":return[r.sqrt(jR("x",e,t,n))];case"Square":return[r.square(jR("x",e,t,n))];case"Tanh":return[r.tanh(jR("x",e,t,n))];case"Tan":return[r.tan(jR("x",e,t,n))];case"ClipByValue":return[r.clipByValue(jR("x",e,t,n),jR("clipValueMin",e,t,n),jR("clipValueMax",e,t,n))];case"Relu6":return[r.relu6(jR("x",e,t,n))];case"Rsqrt":return[r.rsqrt(qR(e.inputNames[0],t,n))];case"Prod":return[r.prod(jR("x",e,t,n),jR("axes",e,t,n))];case"LeakyRelu":return[r.leakyRelu(jR("x",e,t,n),jR("alpha",e,t,n))];case"Prelu":return[r.prelu(jR("x",e,t,n),jR("alpha",e,t,n))];case"IsNan":return[r.isNaN(qR(e.inputNames[0],t,n))];case"IsInf":return[r.isInf(qR(e.inputNames[0],t,n))];case"IsFinite":return[r.isFinite(qR(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function aD(e,t,n=""){if("number"!=typeof e&&"number"!=typeof t){Sa.assert(e.length===t.length,(()=>n+` Shapes ${e} and ${t} must match`));for(let r=0;r<e.length;r++){let a=e[r],s=t[r];Sa.assert(a<0||s<0||a===s,(()=>n+` Shapes ${e} and ${t} must match`))}}}function sD(e){return!("number"==typeof e||e.some((e=>e<0)))}function iD(e,t,n){let r=oD(e,n),a=!sD(r);if(a&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(a&&t.forEach((e=>{r=oD(e.shape,r)})),!sD(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function oD(e,t){if("number"==typeof e)return t;if("number"==typeof t)return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);let n=[];for(let r=0;r<e.length;++r){let a=e[r],s=t[r];if(a>=0&&s>=0&&a!==s)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[r]=a>=0?a:s}return n}var lD=class{constructor(e,t,n,r,a,s,i){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=a,this.dynamicSize=s,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=Zp(0),Oo(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach((t=>{(null==e||!e.has(t.tensor.id))&&t.tensor.dispose()})),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);let t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map((e=>this.read(e)))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);let n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0===this.size()&&(null==this.elementShape||0===this.elementShape.length)&&(this.elementShape=t.shape),aD(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,Oo(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach(((e,n)=>this.write(e,t[n])))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return li([],[0].concat(this.elementShape));let n=this.readMany(e);return aD(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),hm(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return li([],[0].concat(this.elementShape));let t=[];for(let r=0;r<this.size();r++)t.push(r);let n=this.readMany(t);return aD(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),Ql(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);let n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,Wm(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0,r=e.map((e=>(n+=e,n)));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);let a=0===n?0:t.size/n,s=[];Do((()=>{t=ql(t,[1,n,a]);for(let n=0;n<e.length;++n){let i=[0,0===n?0:r[n-1],0],o=[1,e[n],a];s[n]=ql(su(t,i,o),this.elementShape)}return s}));let i=[];for(let o=0;o<e.length;o++)i[o]=o;this.writeMany(i,s)}},uD=class{get id(){return this.idTensor.id}constructor(e,t,n,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=n,null!=e&&e.forEach((e=>{if(n!==e.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${e.dtype}`);aD(t,e.shape,"TensorList shape mismatch: "),Oo(e)})),this.idTensor=Zp(0),this.maxNumElements=r,Oo(this.idTensor)}copy(){return new uD([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach((t=>{(null==e||!e.has(t.id))&&t.dispose()})),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,n=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(-1!==n&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);aD(e,this.elementShape,"TensorList shape mismatch: ");let r=iD(this.elementShape,this.tensors,e);return Do((()=>{let e=this.tensors.map((e=>ql(e,r)));return hm(e,0)}))}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");let n=iD(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,aD(r.shape,e,"TensorList shape mismatch: "),ql(r,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(aD(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Oo(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);let t=new uD([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let n=0;n<Math.min(this.tensors.length,e);++n)t.tensors[n]=this.tensors[n];return t}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[e])throw new Error(`element at index ${e} is null.`);aD(this.tensors[e].shape,t,"TensorList shape mismatch: ");let r=iD(this.elementShape,this.tensors,t);return ql(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);aD(this.elementShape,t.shape,"TensorList shape mismatch: "),Oo(t),null!=this.tensors[e]&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);aD(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());let r=iD(this.elementShape,this.tensors,n);return 0===e.length?li([],[0].concat(r)):Do((()=>{let t=e.map((e=>ql(this.tensors[e],r)));return hm(t,0)}))}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);aD(this.elementShape,t,"TensorList shape mismatch: ");let n=iD(this.elementShape,this.tensors,t);return 0===this.size()?li([],[0].concat(n)):Do((()=>{let e=this.tensors.map((e=>ql(e,n)));return Ql(e,0)}))}};function pD(e,t,n){let r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);let a=e.shape.slice(1);aD(a,t,"TensorList shape mismatch: ");let s=Wm(e);return new uD(s,t,r)}function cD(e,t,n,r){return new uD([],e,t,r)}function dD(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let a=Math.max(...t);if(null!=r&&-1!==r&&a>=r)throw new Error(`Max index must be < array size (${a}  vs. ${r})`);let s=new uD([],n,e.dtype,r),i=Wm(e,0);return t.forEach(((e,t)=>{s.setItem(e,i[t])})),s}function hD(e,t,n){let r=0,a=t.map((e=>(r+=e,r)));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${e.shape}`);let s=e.shape.slice(1),i=oD(s,n),o=0===r?0:e.size/r,l=Do((()=>{let n=[];e=ql(e,[1,r,o]);for(let r=0;r<t.length;++r){let s=[0,0===r?0:a[r-1],0],l=[1,t[r],o];n[r]=ql(su(e,s,l),i)}return e.dispose(),n})),u=new uD([],n,e.dtype,t.length);for(let p=0;p<l.length;p++)u.setItem(p,l[p]);return u}var fD=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{let r=jR("thenBranch",e,t,n),a=jR("elseBranch",e,t,n),s=jR("cond",e,t,n),i=jR("args",e,t,n);return(await s.data())[0]?n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[a].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{let r=jR("body",e,t,n),a=jR("cond",e,t,n),s=jR("args",e,t,n),i=await n.functionMap[a].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap),o=s.map((e=>e.id)),l=await i[0].data();i.forEach((e=>{!e.kept&&-1===o.indexOf(e.id)&&e.dispose()}));let u=s;for(;l[0];){let e=u;u=await n.functionMap[r].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);let t=u.map((e=>e.id));e.forEach((e=>{!e.kept&&-1===o.indexOf(e.id)&&-1===t.indexOf(e.id)&&e.dispose()}));let s=await n.functionMap[a].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);l=await s[0].data(),s.forEach((e=>{!e.kept&&-1===o.indexOf(e.id)&&-1===t.indexOf(e.id)&&e.dispose()}))}return u}case"LoopCond":{let r=jR("pred",e,t,n);return[QR(r)]}case"Switch":{let r=jR("pred",e,t,n),a=jR("data",e,t,n);return a.kept||(a=QR(a)),(await r.data())[0]?[void 0,a]:[a,void 0]}case"Merge":{let r=e.inputNames.find((e=>void 0!==qR(e,t,n)));if(r){let e=qR(r,t,n);return[QR(e)]}return}case"Enter":{let r=jR("frameName",e,t,n),a=jR("tensor",e,t,n);return n.enterFrame(r),[QR(a)]}case"Exit":{let r=jR("tensor",e,t,n);return n.exitFrame(),[QR(r)]}case"NextIteration":{let r=jR("tensor",e,t,n);return n.nextIteration(),[QR(r)]}case"TensorArrayV3":{let r=jR("size",e,t,n),a=jR("dtype",e,t,n),s=jR("elementShape",e,t,n),i=jR("dynamicSize",e,t,n),o=jR("clearAfterRead",e,t,n),l=jR("identicalElementShapes",e,t,n),u=jR("name",e,t,n),p=new lD(u,a,r,s,l,i,o);return n.addTensorArray(p),[p.idTensor,Zp(1)]}case"TensorArrayWriteV3":{let r=jR("tensorArrayId",e,t,n),a=jR("index",e,t,n),s=jR("tensor",e,t,n),i=n.getTensorArray(r.id);return i.write(a,s),[i.idTensor]}case"TensorArrayReadV3":{let r=jR("tensorArrayId",e,t,n),a=jR("index",e,t,n);return[n.getTensorArray(r.id).read(a)]}case"TensorArrayGatherV3":{let r=jR("tensorArrayId",e,t,n),a=jR("indices",e,t,n),s=jR("dtype",e,t,n);return[n.getTensorArray(r.id).gather(a,s)]}case"TensorArrayScatterV3":{let r=jR("tensorArrayId",e,t,n),a=jR("indices",e,t,n),s=jR("tensor",e,t,n),i=n.getTensorArray(r.id);return i.scatter(a,s),[i.idTensor]}case"TensorArrayConcatV3":{let r=jR("tensorArrayId",e,t,n),a=n.getTensorArray(r.id),s=jR("dtype",e,t,n);return[a.concat(s)]}case"TensorArraySplitV3":{let r=jR("tensorArrayId",e,t,n),a=jR("tensor",e,t,n),s=jR("lengths",e,t,n),i=n.getTensorArray(r.id);return i.split(s,a),[i.idTensor]}case"TensorArraySizeV3":{let r=jR("tensorArrayId",e,t,n),a=n.getTensorArray(r.id);return[Zp(a.size(),"int32")]}case"TensorArrayCloseV3":{let r=jR("tensorArrayId",e,t,n),a=n.getTensorArray(r.id);return a.clearAndClose(),[a.idTensor]}case"TensorListSetItem":{let r=jR("tensorListId",e,t,n),a=jR("index",e,t,n),s=jR("tensor",e,t,n),i=n.getTensorList(r.id);return i.setItem(a,s),[i.idTensor]}case"TensorListGetItem":{let r=jR("tensorListId",e,t,n),a=jR("index",e,t,n),s=jR("elementShape",e,t,n),i=jR("elementDType",e,t,n);return[n.getTensorList(r.id).getItem(a,s,i)]}case"TensorListScatterV2":case"TensorListScatter":{let r=jR("indices",e,t,n),a=jR("tensor",e,t,n),s=jR("elementShape",e,t,n),i=jR("numElements",e,t,n),o=dD(a,r,s,i);return n.addTensorList(o),[o.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let r,a=jR("elementShape",e,t,n),s=jR("elementDType",e,t,n);r="TensorListReserve"===e.op?"numElements":"maxNumElements";let i=jR(r,e,t,n),o="TensorListReserve"===e.op?-1:i,l=cD(a,s,i,o);return n.addTensorList(l),[l.idTensor]}case"TensorListGather":{let r=jR("tensorListId",e,t,n),a=jR("indices",e,t,n),s=jR("elementShape",e,t,n),i=jR("elementDType",e,t,n);return[n.getTensorList(r.id).gather(a,i,s)]}case"TensorListStack":{let r=jR("tensorListId",e,t,n),a=jR("elementShape",e,t,n),s=jR("elementDType",e,t,n),i=jR("numElements",e,t,n);return[n.getTensorList(r.id).stack(a,s,i)]}case"TensorListFromTensor":{let r=jR("tensor",e,t,n),a=jR("elementShape",e,t,n),s=jR("elementDType",e,t,n),i=pD(r,a,s);return n.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let r=jR("tensorListId",e,t,n),a=n.getTensorList(r.id),s=jR("dtype",e,t,n),i=jR("elementShape",e,t,n);return[a.concat(s,i)]}case"TensorListPushBack":{let r=jR("tensorListId",e,t,n),a=jR("tensor",e,t,n),s=n.getTensorList(r.id);return s.pushBack(a),[s.idTensor]}case"TensorListPopBack":{let r=jR("tensorListId",e,t,n),a=jR("elementShape",e,t,n),s=jR("elementDType",e,t,n);return[n.getTensorList(r.id).popBack(a,s)]}case"TensorListSplit":{let r=jR("tensor",e,t,n),a=jR("elementShape",e,t,n),s=jR("lengths",e,t,n),i=hD(r,s,a);return n.addTensorList(i),[i.idTensor]}case"TensorListLength":{let r=jR("tensorListId",e,t,n),a=n.getTensorList(r.id);return[Zp(a.size(),"int32")]}case"TensorListResize":{let r=jR("tensorListId",e,t,n),a=jR("size",e,t,n),s=n.getTensorList(r.id).resize(a);return n.addTensorList(s),[s.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function mD(e,t,n){let[r,a]=jR("fusedOps",e,t,n),s="biasadd"===r,i=!s,o="prelu"===a,l="fusedbatchnorm"===r,u=jR("numArgs",e,t,n);if(s){if(o&&2!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&s&&1!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let p=jR("strides",e,t,n),c=ZR(e,t,n),d=jR("dataFormat",e,t,n).toUpperCase(),h=jR("dilations",e,t,n),[f,m]=jR("args",e,t,n);i&&(m=f,f=void 0);let g=jR("leakyreluAlpha",e,t,n);return{stride:p,pad:c,dataFormat:d,dilations:h,biasArg:f,preluArg:m,activationFunc:a,leakyreluAlpha:g}}var gD=(e,t,n,r=tD)=>{switch(e.op){case"Conv1D":{let a=jR("stride",e,t,n),s=jR("pad",e,t,n),i=jR("dataFormat",e,t,n).toUpperCase(),o=jR("dilation",e,t,n);return[r.conv1d(jR("x",e,t,n),jR("filter",e,t,n),a,s,i,o)]}case"Conv2D":{let a=jR("strides",e,t,n),s=ZR(e,t,n),i=jR("dataFormat",e,t,n).toUpperCase(),o=jR("dilations",e,t,n);return[r.conv2d(jR("x",e,t,n),jR("filter",e,t,n),[a[1],a[2]],s,i,[o[1],o[2]])]}case"_FusedConv2D":{let{stride:a,pad:s,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:p,leakyreluAlpha:c}=mD(e,t,n);return[r.fused.conv2d({x:jR("x",e,t,n),filter:jR("filter",e,t,n),strides:[a[1],a[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:p,preluActivationWeights:u,leakyreluAlpha:c})]}case"FusedDepthwiseConv2dNative":{let{stride:a,pad:s,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:p,leakyreluAlpha:c}=mD(e,t,n);return[r.fused.depthwiseConv2d({x:jR("x",e,t,n),filter:jR("filter",e,t,n),strides:[a[1],a[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:p,preluActivationWeights:u,leakyreluAlpha:c})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let a=jR("outputShape",e,t,n),s=jR("strides",e,t,n),i=ZR(e,t,n);return[r.conv2dTranspose(jR("x",e,t,n),jR("filter",e,t,n),a,[s[1],s[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let a=jR("strides",e,t,n),s=ZR(e,t,n),i=jR("dilations",e,t,n),o=jR("dataFormat",e,t,n).toUpperCase();return[r.depthwiseConv2d(jR("input",e,t,n),jR("filter",e,t,n),[a[1],a[2]],s,o,[i[1],i[2]])]}case"Conv3D":{let a=jR("strides",e,t,n),s=jR("pad",e,t,n),i=jR("dataFormat",e,t,n).toUpperCase(),o=jR("dilations",e,t,n);return[r.conv3d(jR("x",e,t,n),jR("filter",e,t,n),[a[1],a[2],a[3]],s,i,[o[1],o[2],o[3]])]}case"AvgPool":{let a=jR("strides",e,t,n),s=jR("pad",e,t,n),i=jR("kernelSize",e,t,n);return[r.avgPool(jR("x",e,t,n),[i[1],i[2]],[a[1],a[2]],s)]}case"MaxPool":{let a=jR("strides",e,t,n),s=jR("pad",e,t,n),i=jR("kernelSize",e,t,n);return[r.maxPool(jR("x",e,t,n),[i[1],i[2]],[a[1],a[2]],s)]}case"MaxPoolWithArgmax":{let a=jR("strides",e,t,n),s=jR("pad",e,t,n),i=jR("kernelSize",e,t,n),o=jR("includeBatchInIndex",e,t,n),{result:l,indexes:u}=r.maxPoolWithArgmax(jR("x",e,t,n),[i[1],i[2]],[a[1],a[2]],s,o);return[l,u]}case"AvgPool3D":{let a=jR("strides",e,t,n),s=jR("pad",e,t,n),i=jR("kernelSize",e,t,n);return[r.avgPool3d(jR("x",e,t,n),[i[1],i[2],i[3]],[a[1],a[2],a[3]],s)]}case"MaxPool3D":{let a=jR("strides",e,t,n),s=jR("pad",e,t,n),i=jR("kernelSize",e,t,n);return[r.maxPool3d(jR("x",e,t,n),[i[1],i[2],i[3]],[a[1],a[2],a[3]],s)]}case"Dilation2D":{let a=jR("strides",e,t,n),s=jR("pad",e,t,n),i=jR("dilations",e,t,n),o=a[1],l=a[2],u=i[1],p=i[2];return[r.dilation2d(jR("x",e,t,n),jR("filter",e,t,n),[o,l],s,[u,p],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},yD=(e,t,n,r=tD)=>{switch(e.op){case"Fill":{let a=jR("shape",e,t,n),s=jR("dtype",e,t,n),i=jR("value",e,t,n);return[r.fill(a,i,s)]}case"LinSpace":{let a=jR("start",e,t,n),s=jR("stop",e,t,n),i=jR("num",e,t,n);return[r.linspace(a,s,i)]}case"Multinomial":{let a=jR("logits",e,t,n),s=jR("numSamples",e,t,n),i=jR("seed",e,t,n);return[r.multinomial(a,s,i)]}case"OneHot":{let a=jR("indices",e,t,n),s=jR("depth",e,t,n),i=jR("onValue",e,t,n),o=jR("offValue",e,t,n),l=jR("dtype",e,t,n);return[r.oneHot(a,s,i,o,l)]}case"Ones":return[r.ones(jR("shape",e,t,n),jR("dtype",e,t,n))];case"OnesLike":return[r.onesLike(jR("x",e,t,n))];case"RandomStandardNormal":return[r.randomStandardNormal(jR("shape",e,t,n),jR("dtype",e,t,n),jR("seed",e,t,n))];case"RandomUniform":return[r.randomUniform(jR("shape",e,t,n),jR("minval",e,t,n),jR("maxval",e,t,n),jR("dtype",e,t,n))];case"Range":{let a=jR("start",e,t,n),s=jR("stop",e,t,n),i=jR("step",e,t,n);return[r.range(a,s,i,jR("dtype",e,t,n))]}case"TruncatedNormal":{let a=jR("shape",e,t,n),s=jR("mean",e,t,n),i=jR("stdDev",e,t,n),o=jR("seed",e,t,n);return[r.truncatedNormal(a,s,i,jR("dtype",e,t,n),o)]}case"Zeros":return[r.zeros(jR("shape",e,t,n),jR("dtype",e,t,n))];case"ZerosLike":return[r.zerosLike(jR("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function bD(e,t,n){let r=jR("boxes",e,t,n),a=jR("scores",e,t,n),s=jR("maxOutputSize",e,t,n),i=jR("iouThreshold",e,t,n),o=jR("scoreThreshold",e,t,n),l=jR("softNmsSigma",e,t,n);return{boxes:r,scores:a,maxOutputSize:s,iouThreshold:i,scoreThreshold:o,softNmsSigma:l}}var xD=async(e,t,n,r,a=tD)=>{switch(e.op){case"NonMaxSuppressionV5":{let{boxes:r,scores:s,maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=bD(e,t,n),p=await a.image.nonMaxSuppressionWithScoreAsync(r,s,i,o,l,u);return[p.selectedIndices,p.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:r,scores:s,maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=bD(e,t,n),u=jR("padToMaxOutputSize",e,t,n),p=await a.image.nonMaxSuppressionPaddedAsync(r,s,i,o,l,u);return[p.selectedIndices,p.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:r,scores:s,maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=bD(e,t,n);return[await a.image.nonMaxSuppressionAsync(r,s,i,o,l)]}case"Where":{let r=a.cast(jR("condition",e,t,n),"bool"),s=[await a.whereAsync(r)];return r.dispose(),s}case"ListDiff":return a.setdiff1dAsync(jR("x",e,t,n),jR("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}},vD=(e,t,n,r=tD)=>{switch(e.op){case"LowerBound":{let a=jR("sortedSequence",e,t,n),s=jR("values",e,t,n);return[r.lowerBound(a,s)]}case"TopKV2":{let a=jR("x",e,t,n),s=jR("k",e,t,n),i=jR("sorted",e,t,n),o=r.topk(a,s,i);return[o.values,o.indices]}case"UpperBound":{let a=jR("sortedSequence",e,t,n),s=jR("values",e,t,n);return[r.upperBound(a,s)]}case"Unique":{let a=jR("x",e,t,n),s=r.unique(a);return[s.values,s.indices]}case"UniqueV2":{let a=jR("x",e,t,n),s=jR("axis",e,t,n),i=r.unique(a,s);return[i.values,i.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},wD=(e,t,n,r=tD)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":let a=jR("default",e,t,n);return[qR(e.name,t,n)||a];case"Placeholder":return[qR(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let r=jR("x",e,t,n);return[QR(r)]}case"IdentityN":return jR("x",e,t,n).map((e=>QR(e)));case"Snapshot":let s=jR("x",e,t,n);return[QR(s)];case"Shape":return[r.tensor1d(jR("x",e,t,n).shape,"int32")];case"ShapeN":return jR("x",e,t,n).map((e=>r.tensor1d(e.shape)));case"Size":return[r.scalar(jR("x",e,t,n).size,"int32")];case"Rank":return[r.scalar(jR("x",e,t,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":let i=jR("x",e,t,n),o=jR("data",e,t,n),l=jR("message",e,t,n),u=jR("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let e=0;e<o.length;e++)console.log(Array.prototype.slice.call(o[e].dataSync()).slice(0,u));return[i];default:throw TypeError(`Node type ${e.op} is not implemented`)}},kD=class{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=Zp(0),this.tensorMap=new Map,Oo(this.handle)}clearAndClose(){this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Zp(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),Do((()=>{let e=Wm(t),r=n.length,a=e.length;Sa.assert(r===a,(()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${a} elements.`));for(let t=0;t<r;t++){let r=n[t],a=e[t];Oo(a),this.tensorMap.set(r,a)}return this.handle}))}async find(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return Do((()=>{let e=[];for(let r=0;r<n.length;r++){let a=n[r],s=this.findWithDefault(a,t);e.push(s)}return hm(e)}))}findWithDefault(e,t){let n=this.tensorMap.get(e);return null!=n?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}},ID=async(e,t,n,r)=>{switch(e.op){case"HashTable":case"HashTableV2":{let a=r.getHashTableHandleByName(e.name);if(null!=a)return[a];{let a=jR("keyDType",e,t,n),s=jR("valueDType",e,t,n),i=new kD(a,s);return r.addHashTable(e.name,i),[i.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{let a=jR("tableHandle",e,t,n,r),s=jR("keys",e,t,n),i=jR("values",e,t,n);return[await r.getHashTableById(a.id).import(s,i)]}case"LookupTableFind":case"LookupTableFindV2":{let a=jR("tableHandle",e,t,n,r),s=jR("keys",e,t,n),i=jR("defaultValue",e,t,n);return[await r.getHashTableById(a.id).find(s,i)]}case"LookupTableSize":case"LookupTableSizeV2":{let a=jR("tableHandle",e,t,n,r);return[r.getHashTableById(a.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},SD=(e,t,n,r=tD)=>{switch(e.op){case"ResizeBilinear":{let a=jR("images",e,t,n),s=jR("size",e,t,n),i=jR("alignCorners",e,t,n),o=jR("halfPixelCenters",e,t,n);return[r.image.resizeBilinear(a,[s[0],s[1]],i,o)]}case"ResizeNearestNeighbor":{let a=jR("images",e,t,n),s=jR("size",e,t,n),i=jR("alignCorners",e,t,n),o=jR("halfPixelCenters",e,t,n);return[r.image.resizeNearestNeighbor(a,[s[0],s[1]],i,o)]}case"CropAndResize":{let a=jR("image",e,t,n),s=jR("boxes",e,t,n),i=jR("boxInd",e,t,n),o=jR("cropSize",e,t,n),l=jR("method",e,t,n),u=jR("extrapolationValue",e,t,n);return[r.image.cropAndResize(a,s,i,o,l,u)]}case"ImageProjectiveTransformV3":{let a=jR("images",e,t,n),s=jR("transforms",e,t,n),i=jR("outputShape",e,t,n),o=jR("fillValue",e,t,n),l=jR("interpolation",e,t,n),u=jR("fillMode",e,t,n);return[r.image.transform(a,s,l.toLowerCase(),u.toLowerCase(),o,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},ND=(e,t,n,r=tD)=>{switch(e.op){case"Equal":return[r.equal(jR("a",e,t,n),jR("b",e,t,n))];case"NotEqual":return[r.notEqual(jR("a",e,t,n),jR("b",e,t,n))];case"Greater":return[r.greater(jR("a",e,t,n),jR("b",e,t,n))];case"GreaterEqual":return[r.greaterEqual(jR("a",e,t,n),jR("b",e,t,n))];case"Less":return[r.less(jR("a",e,t,n),jR("b",e,t,n))];case"LessEqual":return[r.lessEqual(jR("a",e,t,n),jR("b",e,t,n))];case"LogicalAnd":return[r.logicalAnd(jR("a",e,t,n),jR("b",e,t,n))];case"LogicalNot":return[r.logicalNot(jR("a",e,t,n))];case"LogicalOr":return[r.logicalOr(jR("a",e,t,n),jR("b",e,t,n))];case"Select":case"SelectV2":return[r.where(jR("condition",e,t,n),jR("a",e,t,n),jR("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},TD=(e,t,n,r=tD)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(jR("a",e,t,n),jR("b",e,t,n),jR("transposeA",e,t,n),jR("transposeB",e,t,n))];case"Einsum":return[r.einsum(jR("equation",e,t,n),...jR("tensors",e,t,n))];case"Transpose":return[r.transpose(jR("x",e,t,n),jR("perm",e,t,n))];case"_FusedMatMul":let[a,s]=jR("fusedOps",e,t,n),i="biasadd"===a,o="prelu"===s,l=jR("numArgs",e,t,n),u=jR("leakyreluAlpha",e,t,n);if(i){if(o&&2!==l)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&1!==l)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[p,c]=jR("args",e,t,n);return[r.fused.matMul({a:jR("a",e,t,n),b:jR("b",e,t,n),transposeA:jR("transposeA",e,t,n),transposeB:jR("transposeB",e,t,n),bias:p,activation:s,preluActivationWeights:c,leakyreluAlpha:u})];case"MatrixBandPart":return[r.linalg.bandPart(jR("a",e,t,n),jR("numLower",e,t,n),jR("numUpper",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},_D=(e,t,n,r=tD)=>{switch(e.op){case"EuclideanNorm":return[r.euclideanNorm(jR("x",e,t,n),jR("axis",e,t,n),jR("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":return[r.batchNorm(jR("x",e,t,n),jR("mean",e,t,n),jR("variance",e,t,n),jR("offset",e,t,n),jR("scale",e,t,n),jR("epsilon",e,t,n))];case"FusedBatchNormV3":return[r.batchNorm(jR("x",e,t,n),jR("mean",e,t,n),jR("variance",e,t,n),jR("offset",e,t,n),jR("scale",e,t,n),jR("epsilon",e,t,n))];case"LRN":return[r.localResponseNormalization(jR("x",e,t,n),jR("radius",e,t,n),jR("bias",e,t,n),jR("alpha",e,t,n),jR("beta",e,t,n))];case"Softmax":return[r.softmax(jR("x",e,t,n))];case"LogSoftmax":return[r.logSoftmax(jR("x",e,t,n))];case"SparseToDense":return[r.sparseToDense(jR("sparseIndices",e,t,n),jR("outputShape",e,t,n),jR("sparseValues",e,t,n),jR("defaultValue",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},CD=(e,t,n,r=tD)=>{switch(e.op){case"RaggedGather":{let{outputNestedSplits:a,outputDenseValues:s}=r.raggedGather(jR("paramsNestedSplits",e,t,n),jR("paramsDenseValues",e,t,n),jR("indices",e,t,n),jR("outputRaggedRank",e,t,n));return a.concat(s)}case"RaggedRange":{let{rtNestedSplits:a,rtDenseValues:s}=r.raggedRange(jR("starts",e,t,n),jR("limits",e,t,n),jR("splits",e,t,n));return[a,s]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(jR("shape",e,t,n),jR("values",e,t,n),jR("defaultValue",e,t,n),jR("rowPartitionTensors",e,t,n),jR("rowPartitionTypes",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},ED=(e,t,n,r=tD)=>{switch(e.op){case"Max":{let a=jR("axis",e,t,n),s=jR("keepDims",e,t,n);return[r.max(jR("x",e,t,n),a,s)]}case"Mean":{let a=jR("axis",e,t,n),s=jR("keepDims",e,t,n);return[r.mean(jR("x",e,t,n),a,s)]}case"Min":{let a=jR("axis",e,t,n),s=jR("keepDims",e,t,n);return[r.min(jR("x",e,t,n),a,s)]}case"Sum":{let a=jR("axis",e,t,n),s=jR("keepDims",e,t,n);return[r.sum(jR("x",e,t,n),a,s)]}case"All":{let a=jR("axis",e,t,n),s=jR("keepDims",e,t,n);return[r.all(jR("x",e,t,n),a,s)]}case"Any":{let a=jR("axis",e,t,n),s=jR("keepDims",e,t,n);return[r.any(jR("x",e,t,n),a,s)]}case"ArgMax":{let a=jR("axis",e,t,n);return[r.argMax(jR("x",e,t,n),a)]}case"ArgMin":{let a=jR("axis",e,t,n);return[r.argMin(jR("x",e,t,n),a)]}case"Prod":{let a=jR("axis",e,t,n),s=jR("keepDims",e,t,n);return[r.prod(jR("x",e,t,n),a,s)]}case"Cumprod":{let a=jR("axis",e,t,n),s=jR("exclusive",e,t,n),i=jR("reverse",e,t,n);return[r.cumprod(jR("x",e,t,n),a,s,i)]}case"Cumsum":{let a=jR("axis",e,t,n),s=jR("exclusive",e,t,n),i=jR("reverse",e,t,n);return[r.cumsum(jR("x",e,t,n),a,s,i)]}case"Bincount":let a=jR("x",e,t,n),s=jR("weights",e,t,n),i=jR("size",e,t,n);return[r.bincount(a,s,i)];case"DenseBincount":{let a=jR("x",e,t,n),s=jR("weights",e,t,n),i=jR("size",e,t,n),o=jR("binaryOutput",e,t,n);return[r.denseBincount(a,s,i,o)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},AD=(e,t,n,r=tD)=>{switch(e.op){case"ConcatV2":case"Concat":{let a=jR("n",e,t,n),s=jR("axis",e,t,n),i=jR("tensors",e,t,n);return i=i.slice(0,a),[r.concat(i,s)]}case"Gather":{let a=jR("x",e,t,n),s=jR("indices",e,t,n);return[r.gather(a,r.cast(s,"int32"),0)]}case"GatherV2":{let a=jR("axis",e,t,n),s=jR("batchDims",e,t,n),i=jR("x",e,t,n),o=jR("indices",e,t,n);return[r.gather(i,r.cast(o,"int32"),a,s)]}case"Reverse":{let a=jR("dims",e,t,n),s=[];for(let e=0;e<a.length;e++)a[e]&&s.push(e);let i=jR("x",e,t,n);return[r.reverse(i,s)]}case"ReverseV2":{let a=jR("axis",e,t,n),s=jR("x",e,t,n);return[r.reverse(s,a)]}case"Slice":{let a=jR("begin",e,t,n),s=jR("size",e,t,n);return[r.slice(jR("x",e,t,n),a,s)]}case"StridedSlice":{let a=jR("begin",e,t,n),s=jR("end",e,t,n),i=jR("strides",e,t,n),o=jR("beginMask",e,t,n),l=jR("endMask",e,t,n),u=jR("ellipsisMask",e,t,n),p=jR("newAxisMask",e,t,n),c=jR("shrinkAxisMask",e,t,n),d=jR("x",e,t,n);return[r.stridedSlice(d,a,s,i,o,l,u,p,c)]}case"Pack":return Do((()=>{let a=jR("axis",e,t,n),s=jR("tensors",e,t,n),i=s[0].shape,o=r.squeeze(s[0]).shape,l=s.map((e=>{let t=Sa.arraysEqual(e.shape,i);if(!t&&!Sa.arraysEqual(r.squeeze(e).shape,o))throw new Error("the input tensors shape does not match");return t?e:r.reshape(e,i)}));return[r.stack(l,a)]}));case"Unpack":{let a=jR("axis",e,t,n),s=jR("tensor",e,t,n);return r.unstack(s,a)}case"Tile":{let a=jR("reps",e,t,n);return[r.tile(jR("x",e,t,n),a)]}case"Split":case"SplitV":{let a=jR("axis",e,t,n),s=jR("numOrSizeSplits",e,t,n),i=jR("x",e,t,n);return r.split(i,s,a)}case"ScatterNd":{let a=jR("indices",e,t,n),s=jR("values",e,t,n),i=jR("shape",e,t,n);return[r.scatterND(a,s,i)]}case"GatherNd":{let a=jR("x",e,t,n),s=jR("indices",e,t,n);return[r.gatherND(a,s)]}case"SparseToDense":{let a=jR("sparseIndices",e,t,n),s=jR("outputShape",e,t,n),i=jR("sparseValues",e,t,n),o=jR("defaultValue",e,t,n);return[r.sparseToDense(a,i,s,i.dtype===o.dtype?o:r.cast(o,i.dtype))]}case"TensorScatterUpdate":{let a=jR("indices",e,t,n),s=jR("values",e,t,n),i=jR("tensor",e,t,n);return[r.tensorScatterUpdate(i,a,s)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},$D=(e,t,n,r=tD)=>{switch(e.op){case"SparseFillEmptyRows":{let{outputIndices:a,outputValues:s,emptyRowIndicator:i,reverseIndexMap:o}=r.sparse.sparseFillEmptyRows(jR("indices",e,t,n),jR("values",e,t,n),jR("denseShape",e,t,n),jR("defaultValue",e,t,n));return[a,s,i,o]}case"SparseReshape":{let{outputIndices:a,outputShape:s}=r.sparse.sparseReshape(jR("inputIndices",e,t,n),jR("inputShape",e,t,n),jR("newShape",e,t,n));return[a,s]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(jR("data",e,t,n),jR("indices",e,t,n),jR("segmentIds",e,t,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(jR("data",e,t,n),jR("indices",e,t,n),jR("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},RD=(e,t,n,r=tD)=>{switch(e.op){case"FFT":return[r.fft(jR("x",e,t,n))];case"IFFT":return[r.ifft(jR("x",e,t,n))];case"RFFT":return[r.rfft(jR("x",e,t,n))];case"IRFFT":return[r.irfft(jR("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},FD=(e,t,n,r=tD)=>{switch(e.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(jR("input",e,t,n),jR("pattern",e,t,n),jR("rewrite",e,t,n),jR("replaceGlobal",e,t,n))];case"StringNGrams":{let{nGrams:a,nGramsSplits:s}=r.string.stringNGrams(jR("data",e,t,n),jR("dataSplits",e,t,n),jR("separator",e,t,n),jR("nGramWidths",e,t,n),jR("leftPad",e,t,n),jR("rightPad",e,t,n),jR("padWidth",e,t,n),jR("preserveShortSequences",e,t,n));return[a,s]}case"StringSplit":{let{indices:a,values:s,shape:i}=r.string.stringSplit(jR("input",e,t,n),jR("delimiter",e,t,n),jR("skipEmpty",e,t,n));return[a,s,i]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(jR("input",e,t,n),jR("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},DD=(e,t,n,r=tD)=>{switch(e.op){case"Cast":return[r.cast(jR("x",e,t,n),jR("dtype",e,t,n))];case"ExpandDims":{let a=jR("axis",e,t,n);return[r.expandDims(jR("x",e,t,n),a)]}case"Squeeze":{let a=jR("axis",e,t,n);return[r.squeeze(jR("x",e,t,n),a)]}case"Reshape":return[r.reshape(jR("x",e,t,n),jR("shape",e,t,n))];case"MirrorPad":return[r.mirrorPad(jR("x",e,t,n),jR("padding",e,t,n),jR("mode",e,t,n))];case"PadV2":case"Pad":return[r.pad(jR("x",e,t,n),jR("padding",e,t,n),jR("constantValue",e,t,n))];case"SpaceToBatchND":{let a=jR("blockShape",e,t,n),s=jR("paddings",e,t,n);return[r.spaceToBatchND(jR("x",e,t,n),a,s)]}case"BatchToSpaceND":{let a=jR("blockShape",e,t,n),s=jR("crops",e,t,n);return[r.batchToSpaceND(jR("x",e,t,n),a,s)]}case"DepthToSpace":{let a=jR("blockSize",e,t,n),s=jR("dataFormat",e,t,n).toUpperCase();return[r.depthToSpace(jR("x",e,t,n),a,s)]}case"BroadcastTo":return[r.broadcastTo(jR("x",e,t,n),jR("shape",e,t,n))];case"BroadcastArgs":return[r.broadcastArgs(jR("s0",e,t,n),jR("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function MD(e,t,n,r,a=Do){let s=((e,t,n)=>{switch(e.category){case"arithmetic":return a((()=>nD(e,t,n)));case"basic_math":return a((()=>rD(e,t,n)));case"control":return fD(e,t,n);case"convolution":return a((()=>gD(e,t,n)));case"creation":return a((()=>yD(e,t,n)));case"dynamic":return xD(e,t,n);case"evaluation":return a((()=>vD(e,t,n)));case"image":return a((()=>SD(e,t,n)));case"graph":return a((()=>wD(e,t,n)));case"logical":return a((()=>ND(e,t,n)));case"matrices":return a((()=>TD(e,t,n)));case"normalization":return a((()=>_D(e,t,n)));case"ragged":return a((()=>CD(e,t,n)));case"reduction":return a((()=>ED(e,t,n)));case"slice_join":return a((()=>AD(e,t,n)));case"sparse":return a((()=>$D(e,t,n)));case"spectral":return a((()=>RD(e,t,n)));case"string":return a((()=>FD(e,t,n)));case"transformation":return a((()=>DD(e,t,n)));case"hash_table":return ID(e,t,n,r);case"custom":let s=GR(e.op);if(s&&s.customExecutor)return s.customExecutor(new eD(e,t,n));throw TypeError(`Custom op ${e.op} is not registered.`);default:throw TypeError(`Unknown op '${e.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return Sa.isPromise(s)?s.then((e=>[].concat(e))):[].concat(s)}var OD=class{constructor(e={},t={},n={},r={},a){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.parseNodeNameCache=a,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let e=[];for(let t=0;t<this.contexts.length-1;t++){let n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map((e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`)).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;let e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}};function PD(e,t,n,r){let a=new Set,s=[],i=null,o=null,l=new Set,u=new Set(Object.keys(e).map((e=>YR(e)[0])));r=r||[];let p=new Set(r.map((e=>YR(e.name)[0]))),c=[...t];for(;c.length>0;){let e=c.pop();if((jD(e)||qD(e)||KD(e))&&null==i&&(i=e,o=i.children.map((e=>e.name)).filter((e=>a.has(e)))),a.add(e.name),null==n[e.name]&&!u.has(e.name)&&!p.has(e.name)){if(0===e.inputs.length){s.push(e.name);continue}e.inputs.forEach((e=>{l.has(e.name)||(l.add(e.name),c.push(e))}))}}return{inputs:e,outputs:t,usedNodes:a,missingInputs:s,dynamicNode:i,syncInputs:o}}function LD(e,t){let{usedNodes:n,inputs:r}=t,a=Object.keys(r).map((e=>YR(e)[0])).map((t=>e.nodes[t])),s=e.initNodes||[],i=e=>n.has("string"==typeof e?e:e.name);function o(e){return[...new Map(e.map((e=>[e.name,e]))).values()]}let l=o([...a,...e.weights,...s]).filter(i),u=o([...l,...Object.values(e.nodes)]).filter(i),p=new Map(u.map((e=>[e.name,e]))),c={};for(let g of u){c[g.name]=c[g.name]||0;for(let e of g.children)i(e)||(c[e.name]=Number.POSITIVE_INFINITY),c[e.name]=(c[e.name]||0)+1}let d=Object.entries(c).filter((([,e])=>0===e)).map((([e])=>e)),h=[...d];for(;d.length>0;){let e=d.pop(),t=p.get(e);for(let n of t.children.filter(i))0===--c[n.name]&&(h.push(n.name),d.push(n.name))}let f=h.map((e=>p.get(e))),m=zD(f,l);return WD(m,l),m}function zD(e,t){let n=new Map(e.map((e=>[e.name,e]))),r=t.map((e=>e.name)),a=new Set(r);for(;r.length>0;){let e=r.pop(),t=n.get(e);for(let s of t.children)!n.has(s.name)||a.has(s.name)||(a.add(s.name),r.push(s.name))}return e.filter((e=>a.has(e.name)))}var BD=class extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}};function WD(e,t){let n=new Map(e.map(((e,t)=>[e.name,t]))),r=new Set(t.map((e=>e.name))),a=e=>r.has("string"==typeof e?e:e.name),s=new Set(e.map((e=>e.name))),i=e=>s.has("string"==typeof e?e:e.name);for(let o of e){for(let e of o.children.filter(i)){if(!n.has(e.name))throw new BD(`Child ${e.name} of node ${o.name} is unreachable.`);if(n.get(o.name)>n.get(e.name))throw new BD(`Node ${o.name} is scheduled to run after its child ${e.name}.`)}if(!a(o))for(let e of o.inputs){if(!n.has(e.name))throw new BD(`Input ${e.name} of node ${o.name} is unreachable.`);if(n.get(e.name)>n.get(o.name))throw new BD(`Node ${o.name} is scheduled to run before its input ${e.name}.`)}}}function UD(e){let t=new Map(e.map(((e,t)=>[e.name,t]))),n=Number.MAX_SAFE_INTEGER,r=e.map(((e,t)=>jD(e)?n:t)),a=e=>{let n=r[t.get(e.name)];return null==n?-1:n},s=e.map(((e,t)=>e.children.map(a).reduce(((e,t)=>Math.max(e,t)),r[t]))),i=new Map;for(let o=0;o<e.length;++o){let t=s[o];if(t===n)continue;let r=e[o],a=e[t];i.has(a.name)||i.set(a.name,[]),i.get(a.name).push(r.name)}return i}var VD=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),GD=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),HD=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function jD(e){return VD.has(e.op)}function qD(e){return GD.has(e.op)}function KD(e){return HD.has(e.op)}var XD=class{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){let t=Object.keys(e).map((t=>e[t].map((e=>e.id))));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get outputs(){return this._outputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get inputNodes(){return this._inputs.map((e=>e.signatureKey||e.name))}get outputNodes(){return this._outputs.map((e=>{let t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t}))}get functions(){return Object.keys(this._functions).reduce(((e,t)=>(e[t]=this._functions[t].signature,e)),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach((t=>{this._functionExecutorMap[t]=new XD(e.functions[t],this)}))}getCompilationKey(e,t){let n=e.map((e=>e.name)).sort(),r=t.map((e=>e.name)).sort();return n.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(e,t){let n=PD(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:a,syncInputs:s}=n;if(null!=a)throw new Error(`This execution contains the node '${a.name}', which has the dynamic op '${a.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${s}]`);if(r.length>0){let n=t.map((e=>e.name)),a=Object.keys(e);throw new Error(`Cannot compute the outputs [${n}] from the provided inputs [${a}]. Missing the following inputs: [${r}]`)}let i=LD(this.graph,n),o=UD(i);return{orderedNodes:i,nodeLiveUntilMap:o}}cloneAndKeepTensor(e){if(null==e)return null;let t=e.clone();return Oo(t),t}cloneTensorList(e){return e?e.map((e=>this.cloneAndKeepTensor(e))):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map((([e,t])=>[e,this.cloneTensorList(t)])))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);let n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);let r=n.map((e=>this.graph.nodes[YR(e)[0]])),a=t.map((e=>YR(e)[0])),s=new Set(a),i=a.map((e=>this.graph.nodes[e]));0===i.length&&(i=this._outputs);let o=this.getCompilationKey(r,i),l=this.compiledMap.get(o);null==l&&(l=this.compile(e,i),this.compiledMap.set(o,l));try{this.keepIntermediateTensors=We().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(c){this.keepIntermediateTensors=!1,console.warn(c.message)}let u={},p={};return Do((()=>{let n=new OD(this.weightMap,u,p,this.functionExecutorMap,this.parseNodeNameCache),r=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach((t=>{let[a,s]=YR(t,n),i=[];i[s]=e[t],r[a]=i,this.keepIntermediateTensors&&(this.clonedTensorsMap[a]=this.cloneTensorList(i))}));let a=this.getFrozenTensorIds(r),{orderedNodes:i,nodeLiveUntilMap:o}=l;for(let e of i){if(r[e.name])continue;let t=MD(e,r,n,this._resourceManager);if(Sa.isPromise(t))throw new Error(`The execution of the op '${e.op}' returned a promise. Please use model.executeAsync() instead.`);r[e.name]=t,this.keepIntermediateTensors&&(this.clonedTensorsMap[e.name]=this.cloneTensorList(t)),this.checkTensorForDisposalWithNodeLiveUntilInfo(e,r,n,a,s,o.get(e.name))}return null==this.parent&&n.dispose(a),t.map((e=>qR(e,r,n)))}))}getFrozenTensorIds(e){let t=[].concat.apply([],Object.keys(e).map((t=>e[t])).map((e=>e.map((e=>e.id)))));return new Set(t)}checkTensorForDisposal(e,t,n,r,a,s,i){if(!jD(t)&&!s.has(e)){for(let r of n[e])null!=r&&(i[r.id]=(i[r.id]||0)+t.children.length);for(let e of t.inputs){if(jD(e))continue;let t=KR(e.name,n,r);if(null!=t)for(let e of t){if(!e||e.kept||a.has(e.id))continue;let t=i[e.id];1===t?(e.dispose(),delete i[e.id]):null!=t&&i[e.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,n,r,a,s){if(!jD(e)&&!a.has(e.name)&&null!=s)for(let i of s){let e=KR(i,t,n);for(let t of e)!t||t.kept||r.has(t.id)||t.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach((e=>{for(let t of e)t&&!t.isDisposed&&t.dispose()})),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,n=!1,r={},a={}){this.disposeIntermediateTensors(),n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=We().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(c){this.keepIntermediateTensors=!1,console.warn(c.message)}let s=new OD(this.weightMap,r,a,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));let i=await this.executeWithControlFlow(e,s,t,n),o=t.map((e=>qR(e,i,s))),l=o.map((e=>e.id)),u=Object.keys(e).map((t=>e[t].id)),p=new Set([...l,...u,...this.weightIds]);return Object.values(i).forEach((e=>{e.forEach((e=>{e&&!e.isDisposed&&!p.has(e.id)&&e.dispose()}))})),null==this.parent&&s.dispose(p),o}async executeFunctionAsync(e,t,n){let r=e.reduce(((e,t,n)=>(e[this.inputs[n].name]=t,e)),{});return this._executeAsync(r,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,r){let a=Object.keys(e),s=a.map((e=>this.graph.nodes[YR(e)[0]])),i=n.map((e=>YR(e)[0])),o=new Set(i),l=i.map((e=>this.graph.nodes[e]));0===l.length&&(l=this._outputs);let{usedNodes:u,missingInputs:p,dynamicNode:c,syncInputs:d}=PD(e,l,this.weightMap,this._initNodes),h=[...s,...this.graph.weights,...this._initNodes||[]].map((e=>({node:e,contexts:t.currentContext}))),f=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{let[n,r]=YR(t),a=[];a[r]=e[t],f[n]=a}));let m={},g=this.getFrozenTensorIds(f),y={};for(;h.length>0;){let e=this.processStack(s,h,t,f,y,g,o,m,u);await Promise.all(e)}null==c&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let b=l.filter((e=>!jD(e)&&!qR(e.name,f,t))).map((e=>e.name));if(b.length>0){let e="";throw null!=c&&(e=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),new Error(`Cannot compute the outputs [${b}] from the provided inputs [${a}]. Consider providing the following inputs: [${p}]. ${e}`)}return f}processStack(e,t,n,r,a,s,i,o,l){let u=[];for(;t.length>0;){let e=t.pop();n.currentContext=e.contexts;let p="";if("Enter"===e.node.op&&jR("isConstant",e.node,r,n)&&([p]=XR(e.node.name,n)),null==r[e.node.name]){let c=MD(e.node,r,n,this._resourceManager);p||([p]=XR(e.node.name,n));let d=n.currentContext;Sa.isPromise(c)?u.push(c.then((u=>(r[p]=u,this.keepIntermediateTensors&&(this.clonedTensorsMap[p]=this.cloneTensorList(u)),n.currentContext=d,this.checkTensorForDisposal(p,e.node,r,n,s,i,o),this.processChildNodes(e.node,t,n,r,a,l),u)))):(r[p]=c,this.keepIntermediateTensors&&(this.clonedTensorsMap[p]=this.cloneTensorList(c)),this.checkTensorForDisposal(p,e.node,r,n,s,i,o),this.processChildNodes(e.node,t,n,r,a,l))}else this.processChildNodes(e.node,t,n,r,a,l)}return u}processChildNodes(e,t,n,r,a,s){e.children.forEach((e=>{let[i]=XR(e.name,n);a[i]||!s.has(e.name)||("Merge"===e.op?e.inputNames.some((e=>!!qR(e,r,n)))&&(a[i]=!0,t.push({contexts:n.currentContext,node:e})):e.inputNames.every((e=>!!qR(e,r,n)))&&(a[i]=!0,t.push({contexts:n.currentContext,node:e})))}))}dispose(){Object.keys(this.weightMap).forEach((e=>this.weightMap[e].forEach((e=>e.dispose()))))}checkInputShapeAndType(e){Object.keys(e).forEach((t=>{let n=e[t],[r]=YR(t),a=this.graph.nodes[r];if(a.attrParams.shape&&a.attrParams.shape.value){let e=a.attrParams.shape.value,t=e.length===n.shape.length&&n.shape.every(((t,n)=>-1===e[n]||e[n]===t));Sa.assert(t,(()=>`The shape of dict['${a.name}'] provided in model.execute(dict) must be [${e}], but was [${n.shape}]`))}a.attrParams.dtype&&a.attrParams.dtype.value&&Sa.assert(n.dtype===a.attrParams.dtype.value,(()=>`The dtype of dict['${a.name}'] provided in model.execute(dict) must be ${a.attrParams.dtype.value}, but was ${n.dtype}`))}))}mapInputs(e){var t,n;let r={};for(let a in e){let s=null===(n=null===(t=this._signature)||void 0===t?void 0:t.inputs)||void 0===n?void 0:n[a];null!=s?r[s.name]=e[a]:r[a]=e[a]}return r}checkInputs(e){let t=Object.keys(e).filter((e=>{let[t]=YR(e);return null==this.graph.nodes[t]}));if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map((e=>{var t,n;let r=null===(n=null===(t=this._signature)||void 0===t?void 0:t.outputs)||void 0===n?void 0:n[e];return null!=r?r.name:e}),{})}checkOutputs(e){e.forEach((e=>{let[t]=YR(e);if(!this.graph.nodes[t])throw new Error(`The output '${e}' is not found in the graph`)}))}},JD=class{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(let e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(let e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}},YD="?tfjs-format=file",ZD="model.json",QD=class{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},n=Ob){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=n,null==t&&(this.loadOptions={}),this.resourceManager=new JD}findIOHandler(){let e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{let t=this.io.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let e=this.handler.load();return Sa.isPromise(e)?e.then((e=>this.loadSync(e))):this.loadSync(e)}loadSync(e){this.artifacts=e;let t=this.artifacts.modelTopology,n=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){let e=this.artifacts.userDefinedMetadata;null!=e.signature&&(n=e.signature),null!=e.structuredOutputKeys&&(this.structuredOutputKeys=e.structuredOutputKeys)}this.signature=n,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;let r=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new XD(LF.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(r),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){let t=LF.Instance.transformGraph(e.modelInitializer);this.initializer=new XD(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if("string"==typeof e){let t=this.io.getSaveHandlers(e);if(0===t.length)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Error(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){let t=e instanceof bs?[e]:e,n={};return t.forEach(((e,t)=>n[this.structuredOutputKeys[t]]=e)),n}return e}predict(e,t){let n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){let n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof bs)&&!Array.isArray(e)){let n=null===(t=this.signature)||void 0===t?void 0:t.inputs;if(null!=n)for(let t in n){let r=n[t];null!=r.resourceId&&(e[t]=this.resourceIdToCapturedInput[r.resourceId])}return e}e=Array.isArray(e)?e:[e];let n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce(((t,n)=>{var a,s,i;let o=null===(i=null===(s=null===(a=this.signature)||void 0===a?void 0:a.inputs)||void 0===s?void 0:s[n])||void 0===i?void 0:i.resourceId;return t[n]=null!=o?this.resourceIdToCapturedInput[o]:e[r++],t}),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){let t=this.initializerSignature.outputs,n=Object.keys(t);for(let r=0;r<n.length;r++){let a=n[r],s=t[a];this.resourceIdToCapturedInput[s.resourceId]=e[r]}}}execute(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce(((t,n)=>(t[n]=[e[n]],t)),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Mo(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}};async function eM(e,t={},n=Ob){if(null==e)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&"string"==typeof e&&(e=nM(e));let r=new QD(e,t,n);return await r.load(),r}function tM(e){if(null==e)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let t;if(e instanceof Array){let[n,r]=e;if(!n)throw new Error("modelJSON must be the first element of the array");if(!r||!(r instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in n))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in n))throw new Error("Model JSON is missing 'weightsManifest'");let a=Ob.getWeightSpecs(n.weightsManifest),s=Ob.getModelArtifactsForJSONSync(n,a,r);t=Ob.fromMemorySync(s)}else if("load"in e)t=e;else{if(!("modelTopology"in e&&"weightSpecs"in e&&"weightData"in e))throw new Error("Unknown model format");t=Ob.fromMemorySync(e)}let n=new QD(t);return n.load(),n}function nM(e){return e.endsWith("/")||(e+="/"),`${e}${ZD}${YD}`}var rM="4.3.0",aM={};g(aM,{CSVDataset:()=>tO,Dataset:()=>UM,FileDataSource:()=>mO,TextLineDataset:()=>KM,URLDataSource:()=>gO,array:()=>GM,csv:()=>yO,func:()=>bO,generator:()=>xO,microphone:()=>wO,version_data:()=>kO,webcam:()=>vO,zip:()=>HM});var sM=b(A()),iM=b(A());function oM(e,t){return lM(e,t)}function lM(e,t,n=new Map,r=new Set){if(null==e)return null;if("function"==typeof Blob&&e instanceof Blob)return e.slice();if(r.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);let a=t(e);if(a.recurse&&null!==a.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(a.recurse){if(hM(e)){let a=Array.isArray(e)?[]:{};r.add(e);for(let s in e){let i=e[s],o=lM(i,t,n,r);a[s]=o}return r.delete(e),e.__proto__&&(a.__proto__=e.__proto__),a}throw new Error(`Can't recurse into non-iterable type: ${e}`)}return n.set(e,a.value),a.value}function uM(e,t=cM){return pM(e,t)}function pM(e,t,n=new Set){let r=e[0];if(n.has(r))throw new Error("Circular references are not supported.");let a=t(e);if(a.recurse&&null!==a.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(a.recurse){if(hM(r)){let a=Array.isArray(r)?[]:{};n.add(r);for(let s in r){let r=e.map((e=>e[s])),i=pM(r,t,n);a[s]=i}return n.delete(r),a}throw new Error(`Can't recurse into non-iterable type: ${r}`)}return a.value}function cM(e){return null===e?null:hM(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}async function dM(e,t){let n=new Map;lM(e,t,n);for(let r of Array.from(n.keys())){let e=n.get(r);if(Sa.isPromise(e)){let t=await e;n.set(r,t)}}return lM(e,t,n)}function hM(e){let t=!1;if(We().get("IS_BROWSER"))t=e instanceof TextDecoder;else{let{StringDecoder:n}=$();t=e instanceof n}return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"==typeof e&&!(e instanceof bs)&&!(e instanceof Promise)&&!t)}function fM(e){return null==e||mM(e)||Array.isArray(e)||"object"==typeof e&&e instanceof bs||Sa.isTypedArray(e)}function mM(e){return null===e||"object"!=typeof e&&"function"!=typeof e}function gM(e){return oM(e,yM)}function yM(e){return e instanceof bs?{value:e.clone(),recurse:!1}:hM(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}var bM=class{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(let t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}},xM=class extends bM{constructor(){super(xM.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){let e=2*this.capacity,t=new Array(e),n=this.length();for(let r=0;r<n;r++)t[r]=this.get(this.wrap(this.begin+r));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}};function vM(e){return new TM(e)}function wM(e){return new _M(e)}function kM(e,t){return new LM(e,t)}function IM(e,t=SM.FAIL){return new zM(e,t)}xM.INITIAL_CAPACITY=32;var SM,NM=class{async toArray(){let e=[],t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){let e=this.prefetch(100),t=[],n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new DM(this,e)}filter(e){return new RM(this,e)}map(e){return new FM(this,e)}mapAsync(e){return new MM(this,e)}serialMapAsync(e){return new MM(this,e).serial()}flatmap(e){return new PM(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile((e=>!0===e))}rowMajorBatch(e,t=!0){return new $M(this,e,t)}columnMajorBatch(e,t=!0,n=cM){return this.rowMajorBatch(e,t).map((e=>uM(e,n)))}concatenate(e,t){return new LM(vM([this,e]),t)}take(e){return e<0||null==e?this:new AM(this,e)}skip(e){return e<0||null==e?this:new EM(this,e)}prefetch(e){return new BM(this,e)}shuffle(e,t){return new WM(this,e,t)}serial(){return new CM(this)}},TM=class extends NM{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let e=this.items[this.trav];return this.trav++,{value:gM(e),done:!1}}},_M=class extends NM{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(ple){throw ple.message=`Error thrown while iterating through a dataset: ${ple.message}`,ple}}},CM=class extends NM{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}},EM=class extends NM{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let e=await this.upstream.next();if(e.done)return e;Mo(e.value)}return this.upstream.next()}},AM=class extends NM{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},$M=class extends NM{constructor(e,t,n=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){let e=[];for(;e.length<this.batchSize;){let t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}},RM=class extends NM{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;){let e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;Mo(e.value)}}},FM=class extends NM{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=Ts.getTensorsInContainer(e.value),n=this.transform(e.value),r=Ts.getTensorsInContainer(n);for(let a of t)Ts.isTensorInList(a,r)||a.dispose();return{value:n,done:!1}}},DM=class extends NM{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(ple){if(!this.handler(ple))return{value:null,done:!0}}}},MM=class extends NM{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=Ts.getTensorsInContainer(e.value),n=await this.transform(e.value),r=Ts.getTensorsInContainer(n);for(let a of t)Ts.isTensorInList(a,r)||a.dispose();return{value:n,done:!1}}},OM=class extends NM{constructor(){super(),this.outputQueue=new xM,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},PM=class extends OM{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let e=await this.upstream.next();if(e.done)return!1;let t=Ts.getTensorsInContainer(e.value),n=this.transform(e.value),r=Ts.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(let a of t)Ts.isTensorInList(a,r)||a.dispose();return!0}},LM=class extends NM{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,null==this.iterator){let e=await this.moreIterators.next();if(e.done)return{value:null,done:!0};this.iterator=e.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}};(function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"})(SM||(SM={}));var zM=class extends NM{constructor(e,t=SM.FAIL){super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,n=0;function r(e){return e instanceof NM?{value:e.next().then((e=>(t++,e.done&&n++,e.value))),recurse:!1}:{value:null,recurse:!0}}let a=await dM(this.iterators,r);if(t===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case SM.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case SM.SHORTEST:return{value:null,done:!0};case SM.LONGEST:default:}return this.count++,{value:a,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},BM=class extends NM{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new bM(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}},WM=class extends BM{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=iM.alea(n||Sa.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(!t.done)return this.refill(),t;this.upstreamExhausted=!0}return{value:null,done:!0}}},UM=class{constructor(){this.size=null}batch(e,t=!0){let n,r=this;return Sa.assert(e>0,(()=>`batchSize needs to be positive, but it is\n      ${e}`)),n=this.size===1/0||null==this.size?this.size:t?Math.ceil(this.size/e):Math.floor(this.size/e),VM((async()=>(await r.iterator()).columnMajorBatch(e,t,jM)),n)}concatenate(e){let t,n=this;return t=this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null,VM((async()=>(await n.iterator()).concatenate(await e.iterator())),t)}filter(e){let t,n=this;return t=this.size===1/0?1/0:null,VM((async()=>(await n.iterator()).filter((t=>Do((()=>e(t)))))),t)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){let t=this;return VM((async()=>(await t.iterator()).map((t=>Do((()=>e(t)))))),this.size)}mapAsync(e){let t=this;return VM((async()=>(await t.iterator()).mapAsync(e)),this.size)}prefetch(e){if(null==e)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let t=this;return VM((async()=>(await t.iterator()).prefetch(e)),this.size)}repeat(e){let t,n=this;return t=null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null,VM((async()=>{let t=wM((async()=>({value:await n.iterator(),done:!1})));return kM(t.take(e))}),t)}skip(e){let t,n=this;return t=null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null,VM((async()=>(await n.iterator()).skip(e)),t)}shuffle(e,t,n=!0){if(null==e||e<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let r=this,a=sM.alea(t||Sa.now().toString());return VM((async()=>{let t=a.int32();return n&&(t+=a.int32()),(await r.iterator()).shuffle(e,t.toString())}),this.size)}take(e){let t,n=this;return t=null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null,VM((async()=>(await n.iterator()).take(e)),t)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};function VM(e,t=null){return new class extends UM{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function GM(e){return VM((async()=>vM(e)),e.length)}function HM(e){if(!hM(e))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(e))for(let n=0;n<e.length;n++)t=null==t?e[n].size:Math.min(t,e[n].size);else if(e instanceof Object)for(let n in e)t=null==t?e[n].size:Math.min(t,e[n].size);return VM((async()=>{let t=await dM(e,(e=>{if(e instanceof UM)return{value:e.iterator(),recurse:!1};if(hM(e))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")}));return IM(t,SM.SHORTEST)}),t)}function jM(e){if(null===e)return null;let t=e[0];return fM(t)?{value:qM(e),recurse:!1}:{value:null,recurse:!0}}function qM(e){if(0===e.length)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof bs?hm(e):li(e)}UM.MAX_BUFFER_SIZE=1e4;var KM=class extends UM{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split("\n").map((e=>(e.endsWith("\r")&&(e=e.slice(0,-1)),e)))}},XM='"',JM=Symbol("out"),YM=Symbol("field"),ZM=Symbol("quote"),QM=Symbol("quoteafterquote"),eO=Symbol("quoteinquote"),tO=class extends UM{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&Sa.assert(e.length===this.fullColumnNames.length,(()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+").")),this.fullColumnNames||(this.fullColumnNames=e);let t=this.fullColumnNames.reduce(((e,t)=>(e[t]=e[t]+1||1,e)),{}),n=Object.keys(t).filter((e=>t[e]>1));if(Sa.assert(0===n.length,(()=>"Duplicate column names found: "+n.toString())),this.columnConfigs)for(let r of Object.keys(this.columnConfigs))if(-1===this.fullColumnNames.indexOf(r))throw new Error('The key "'+r+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").");this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let e=await(await this.base.iterator()).next();if(e.done)throw new Error("No data was found for CSV parsing.");let t=e.value;return this.parseRow(t,!1)}return null}constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new KM(e),t||(t={}),this.hasHeader=!1!==t.hasHeader,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(Sa.assert(null==t.delimiter,(()=>"Delimiter should not be provided when delimWhitespace is true.")),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map((e=>this.makeDataElement(e)))}makeDataElement(e){let t=this.parseRow(e),n={},r={};for(let a=0;a<this.fullColumnNames.length;a++){let s=this.fullColumnNames[a],i=this.columnConfigs?this.columnConfigs[s]:null;if(!this.configuredColumnsOnly||i){let o=t[a],l=null;if(""===o)if(i&&void 0!==i.default)l=i.default;else{if(i&&(i.required||i.isLabel))throw new Error(`Required column ${s} is empty in this line: ${e}`);l=void 0}else{let e=Number(o);if(isNaN(e))l=i&&"bool"===i.dtype?this.getBoolean(o):o;else if(i&&i.dtype)switch(i.dtype){case"float32":l=e;break;case"int32":l=Math.floor(e);break;case"bool":l=this.getBoolean(o);break;default:l=e}else l=e}i&&i.isLabel?r[s]=l:n[s]=l}}return 0===Object.keys(r).length?n:{xs:n,ys:r}}getBoolean(e){return"1"===e||"true"===e.toLowerCase()?1:0}parseRow(e,t=!0){let n=[],r=0,a=e.length,s=JM;for(let i=0;i<a;i++)switch(s){case JM:switch(e.charAt(i)){case XM:r=i+1,s=ZM;break;case this.delimiter:if(r=i+1," "===this.delimiter&&this.delimWhitespace)break;n.push(""),s=JM;break;default:s=YM,r=i;break}break;case YM:switch(e.charAt(i)){case this.delimiter:n.push(e.substring(r,i)),s=JM,r=i+1;break;default:}break;case ZM:switch(e.charAt(i)){case XM:s=QM;break;default:}break;case QM:switch(e.charAt(i)){case this.delimiter:n.push(e.substring(r,i-1)),s=JM,r=i+1;break;case XM:s=ZM;break;default:s=eO;break}break;case eO:switch(e.charAt(i)){case XM:s=ZM;break;default:}break;default:}if(s===QM?n.push(e.substring(r,a-1)):n.push(e.substring(r)),t&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}},nO=class extends NM{constructor(e){super(),this.microphoneConfig=e,this.isClosed=!1,this.fftSize=e.fftSize||1024;let t=Math.log2(this.fftSize);if(this.fftSize<0||t<4||t>14||!Number.isInteger(t))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=!1!==e.includeSpectrogram,this.includeWaveform=!0===e.includeWaveform,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(e={}){if(!We().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");let t=new nO(e);return await t.start(),t}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:null==this.audioTrackConstraints||this.audioTrackConstraints,video:!1})}catch(n){throw new Error(`Error thrown while initializing video stream: ${n.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");let e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e,this.sampleRateHz){if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`)}else this.sampleRateHz=this.audioContext.sampleRate;let t=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=2*this.fftSize,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,t.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let e,t,n=await this.getAudioData();if(this.includeSpectrogram){let t=this.flattenQueue(n.freqDataQueue);e=this.getTensorFromAudioDataArray(t,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let e=this.flattenQueue(n.timeDataQueue);t=this.getTensorFromAudioDataArray(e,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:t},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let e=[],t=[],n=0;return new Promise((r=>{let a=setInterval((()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&r({freqDataQueue:e,timeDataQueue:t}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),t.push(this.timeData.slice())),++n===this.numFrames&&(clearInterval(a),r({freqDataQueue:e,timeDataQueue:t}))}),this.fftSize/this.sampleRateHz*1e3)}))}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),null!=this.stream&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(e){let t=e[0].length,n=new Float32Array(e.length*t);return e.forEach(((e,r)=>n.set(e,r*t))),n}getTensorFromAudioDataArray(e,t){let n=new Float32Array(Sa.sizeFromShape(t));return n.set(e,n.length-e.length),li(n,t)}},rO=class extends NM{constructor(e,t){if(super(),this.webcamVideoElement=e,this.webcamConfig=t,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=vm([0],"int32"),this.webcamConfig.centerCrop){let e=1*this.webcamConfig.resizeWidth/this.webcamVideoElement.width,t=1*this.webcamConfig.resizeHeight/this.webcamVideoElement.height,n=(1-e)/2,r=(1-t)/2,a=n+e,s=t+r;this.cropBox=wm([r,n,s,a],[1,4])}else this.cropBox=wm([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(e,t={}){if(!We().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!e){if(e=document.createElement("video"),!t.resizeWidth||!t.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");e.width=t.resizeWidth,e.height=t.resizeHeight}let n=new rO(e,t);return await n.start(),n}async start(){this.webcamConfig.facingMode&&Sa.assert("user"===this.webcamConfig.facingMode||"environment"===this.webcamConfig.facingMode,(()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`));try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(ple){throw ple.message=`Error thrown while initializing video stream: ${ple.message}`,ple}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(ple){console.log(ple),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise((e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}}))}async next(){if(this.isClosed)return{value:null,done:!0};let e;try{e=mx.fromPixels(this.webcamVideoElement)}catch(t){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(t)}`)}if(!this.resize)return{value:e,done:!1};try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(t){throw new Error(`Error thrown cropping the video: ${t.message}`)}finally{e.dispose()}}needToResize(){return!(!this.webcamConfig.resizeWidth||!this.webcamConfig.resizeHeight||this.webcamVideoElement.width===this.webcamConfig.resizeWidth&&this.webcamVideoElement.height===this.webcamConfig.resizeHeight)}cropAndResizeFrame(e){return Do((()=>{let t,n=hc(wo(e,"float32"),0);t=yb.cropAndResize(n,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");let r=t.shape;return ql(t,r.slice(1))}))}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach((e=>e.stop()));try{this.webcamVideoElement.srcObject=null}catch(ple){console.log(ple),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}},aO=class{},sO=class extends NM{split(e){return new iO(this,e)}},iO=class extends sO{constructor(e,t){super(),this.upstream=e,this.impl=new oO(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},oO=class extends OM{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let e=await this.upstream.next();if(e.done)return""!==this.carryover&&(this.outputQueue.push(this.carryover),this.carryover="",!0);let t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(let n of t.slice(0,-1))this.outputQueue.push(n);return this.carryover=t[t.length-1],!0}},lO=class extends NM{decodeUTF8(){return new uO(this)}},uO=class extends sO{constructor(e){super(),this.upstream=e,this.impl=new pO(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},pO=class extends OM{constructor(e){if(super(),this.upstream=e,We().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder:e}=$();this.decoder=new e("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let e,t,n=await this.upstream.next();return!n.done&&(e=n.value,t=We().get("IS_BROWSER")?this.decoder.decode(e,{stream:!0}):this.decoder.write(Buffer.from(e.buffer)),this.outputQueue.push(t),!0)}},cO=class extends lO{constructor(e,t={}){super(),this.file=e,this.options=t,Sa.assert(e instanceof Uint8Array||!!We().get("IS_BROWSER")&&(e instanceof File||e instanceof Blob),(()=>"FileChunkIterator only supports File, Blob and Uint8Array right now.")),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1048576}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise(((e,t)=>{let n=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,n)));else{let r=new FileReader;r.onload=n=>{let a=r.result;if(a instanceof ArrayBuffer&&(a=new Uint8Array(a)),!(a instanceof Uint8Array))return t(new TypeError("FileReader returned unknown type."));e(a)},r.onabort=e=>t(new Error("Aborted")),r.onerror=e=>t(new Error(e.type));let a=this.file.slice(this.offset,n);r.readAsArrayBuffer(a)}this.offset=n})),done:!1}}};async function dO(e,t={},n){let r,a;"string"==typeof e?r=e:(r=e.url,a=hO(e));let s=await(n||Sa.fetch)(r,a);if(s.ok){let e=new Uint8Array(await s.arrayBuffer());return new cO(e,t)}throw new Error(s.statusText)}var hO=e=>({method:e.method,headers:e.headers,body:e.body,mode:e.mode,credentials:e.credentials,cache:e.cache,redirect:e.redirect,referrer:e.referrer,integrity:e.integrity});function fO(e){return"string"==typeof e&&"file://"===e.slice(0,7)}var mO=class extends aO{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){if(fO(this.input)&&We().get("IS_NODE")){let e=R();this.input=e.readFileSync(this.input.slice(7))}return new cO(this.input,this.options)}},gO=class extends aO{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}async iterator(){return fO(this.url)?new mO(this.url,this.fileOptions).iterator():dO(this.url,this.fileOptions)}};function yO(e,t={}){return new tO(new gO(e),t)}function bO(e){let t=wM(e);return VM((async()=>t))}function xO(e){return VM((async()=>{let t=await e();return wM((()=>t.next()))}))}async function vO(e,t){return rO.create(e,t)}async function wO(e){return nO.create(e)}var kO="4.3.0";function IO(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&Sa.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the CPU backend.`))}))}var SO=sw.whereImpl,NO=class extends W{nextDataId(){return NO.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new B(this,$o())}write(e,t,n){this.firstUse&&(this.firstUse=!1,We().get("IS_NODE")&&Qx.warn("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));let r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:n,refCount:1}),r}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&Sa.isString(n[0])){let a=n.map((e=>Sa.encodeString(e)));r=this.write(a,e,t)}else r=this.write(n,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){let t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){let t=this.data.get(e);t.refCount--}}move(e,t,n,r,a){this.data.set(e,{values:t,dtype:r,refCount:a})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){let{dtype:t,complexTensorInfos:n}=this.data.get(e);if("complex64"===t){let e=this.readSync(n.real.dataId),t=this.readSync(n.imag.dataId);return Qx.mergeRealAndImagArrays(e,t)}return Sa.convertBackendValuesAndArrayBuffer(this.data.get(e).values,t)}bufferSync(e){let t=this.readSync(e.dataId);if("string"===e.dtype)try{let n=t.map((e=>Sa.decodeString(e)));return xo(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return xo(e.shape,e.dtype,t)}makeOutput(e,t,n){return $o().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;let{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){let t=Sa.now();return e(),{kernelMs:Sa.now()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){IO([e],"where");let t=this.readSync(e.dataId);return SO(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}};NO.nextDataId=0;var TO={};function _O(e){let t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}g(TO,{addImpl:()=>VO,bincountImpl:()=>qO,bincountReduceImpl:()=>KO,castImpl:()=>LO,ceilImpl:()=>ZO,concatImpl:()=>tP,equalImpl:()=>nP,expImpl:()=>sP,expm1Impl:()=>lP,floorDivImpl:()=>fP,floorImpl:()=>cP,gatherNdImpl:()=>yP,gatherV2Impl:()=>bP,greaterEqualImpl:()=>kP,greaterImpl:()=>xP,lessEqualImpl:()=>CP,lessImpl:()=>NP,linSpaceImpl:()=>$P,logImpl:()=>RP,maxImpl:()=>MP,maximumImpl:()=>OP,minimumImpl:()=>zP,multiplyImpl:()=>UP,negImpl:()=>jP,notEqualImpl:()=>XP,prodImpl:()=>tL,raggedGatherImpl:()=>cL,raggedRangeImpl:()=>hL,raggedTensorToTensorImpl:()=>bL,rangeImpl:()=>xL,rsqrtImpl:()=>vL,scatterImpl:()=>IL,sigmoidImpl:()=>SL,simpleAbsImpl:()=>_O,sliceImpl:()=>_L,sparseFillEmptyRowsImpl:()=>AL,sparseReshapeImpl:()=>$L,sparseSegmentReductionImpl:()=>RL,sqrtImpl:()=>FL,squaredDifferenceImpl:()=>OL,staticRegexReplaceImpl:()=>zL,stridedSliceImpl:()=>UL,stringNGramsImpl:()=>GL,stringSplitImpl:()=>jL,stringToHashBucketFastImpl:()=>qL,subImpl:()=>KL,tileImpl:()=>ZL,topKImpl:()=>tz,transposeImpl:()=>ZP,uniqueImpl:()=>nz});var CO=e=>{let{x:t}=e.inputs,n=e.backend;IO(t,"abs");let r=new Float32Array(Sa.sizeFromShape(t.shape)),a=n.data.get(t.dataId).values;return r=_O(a),n.makeOutput(r,t.shape,t.dtype)},EO={kernelName:Ke,backendName:"cpu",kernelFunc:CO};function AO(e){return(t,n,r,a,s)=>{let i=Qx.assertAndGetBroadcastShape(t,n),o=i.length,l=Sa.computeStrides(i),u=Sa.sizeFromShape(i),p=Sa.getTypedArrayFromDType(s,u),c=t.length,d=n.length,h=Sa.computeStrides(t),f=Sa.computeStrides(n),m=Qx.getBroadcastDims(t,i),g=Qx.getBroadcastDims(n,i);if(m.length+g.length===0)for(let y=0;y<p.length;++y)p[y]=e(r[y%r.length],a[y%a.length]);else for(let y=0;y<p.length;++y){let t=Sa.indexToLoc(y,o,l),n=t.slice(-c);m.forEach((e=>n[e]=0));let s=Sa.locToIndex(n,c,h),i=t.slice(-d);g.forEach((e=>i[e]=0));let u=Sa.locToIndex(i,d,f);p[y]=e(r[s],a[u])}return[p,i]}}function $O(e){let{inputs:t,backend:n}=e,{real:r,imag:a}=t,s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,o=n.makeTensorInfo(r.shape,"complex64"),l=n.data.get(o.dataId);return l.complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",s),imag:n.makeTensorInfo(a.shape,"float32",i)},o}var RO={kernelName:vt,backendName:"cpu",kernelFunc:$O};function FO(e,t,n="float32"){if("complex64"===n){let n=FO(e,t,"float32"),r=FO(e,t,"float32");return $O({inputs:{real:n,imag:r},backend:e})}let r=Sa.makeZerosTypedArray(Sa.sizeFromShape(t),n);return e.makeTensorInfo(t,n,r)}function DO(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var MO={kernelName:un,backendName:"cpu",kernelFunc:DO};function OO(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.real,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}var PO={kernelName:or,backendName:"cpu",kernelFunc:OO};function LO(e,t,n,r){if("int32"===r){let n=Int32Array.from(e);return[t,"int32",n]}if("bool"===r){let r=Sa.toTypedArray([0],n),[a,s]=AO(((e,t)=>e!==t?1:0))(t,[],e,r,"bool");return[s,"bool",a]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function zO(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dtype:s}=r;if("complex64"===s){if("complex64"===a.dtype)return DO({inputs:{x:a},backend:n});let e=FO(n,a.shape,a.dtype),t=zO({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),r=$O({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),r}if("complex64"===a.dtype){let e=OO({inputs:{input:a},backend:n}),t=zO({inputs:{x:e},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(e),t}if(!Sa.hasEncodingLoss(a.dtype,s)){let e=DO({inputs:{x:a},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:s}}let i=n.data.get(a.dataId).values,[o,l,u]=LO(i,a.shape,a.dtype,s);return n.makeTensorInfo(o,l,u)}var BO={kernelName:yt,backendName:"cpu",kernelFunc:zO};function WO(e,t,n,r){return null==n?({inputs:n,backend:a})=>{let{a:s,b:i}=n,o=a;IO([s,i],e);let l=o.data.get(s.dataId).values,u=o.data.get(i.dataId).values,p="string"===s.dtype?Qx.fromUint8ToStringArray(l):l,c="string"===s.dtype?Qx.fromUint8ToStringArray(u):u,d=r||s.dtype,[h,f]=t(s.shape,i.shape,p,c,d);return o.makeTensorInfo(f,d,h)}:({inputs:e,backend:a})=>{let{a:s,b:i}=e,o=a;if("complex64"===s.dtype||"complex64"===i.dtype){let e=zO({inputs:{x:s},backend:o,attrs:{dtype:"complex64"}}),t=o.data.get(e.dataId),r=t.complexTensorInfos.real,a=t.complexTensorInfos.imag,l=o.data.get(r.dataId).values,u=o.data.get(a.dataId).values,p=zO({inputs:{x:i},backend:o,attrs:{dtype:"complex64"}}),c=o.data.get(p.dataId),d=c.complexTensorInfos.real,h=c.complexTensorInfos.imag,f=o.data.get(d.dataId).values,m=o.data.get(h.dataId).values,[g,y,b]=n(s.shape,i.shape,l,u,f,m),x=o.makeTensorInfo(b,"float32",g),v=o.makeTensorInfo(b,"float32",y),w=$O({inputs:{real:x,imag:v},backend:o});return o.disposeIntermediateTensorInfo(e),o.disposeIntermediateTensorInfo(p),o.disposeIntermediateTensorInfo(x),o.disposeIntermediateTensorInfo(v),w}{let e=o.data.get(s.dataId).values,n=o.data.get(i.dataId).values,a=r||s.dtype,[l,u]=t(s.shape,i.shape,e,n,a);return o.makeTensorInfo(u,a,l)}}}function UO(e){return(t,n,r,a,s,i)=>{let o=Qx.assertAndGetBroadcastShape(t,n),l=Sa.sizeFromShape(o),u=o.length,p=Sa.computeStrides(o),c=Sa.getTypedArrayFromDType("float32",l),d=Sa.getTypedArrayFromDType("float32",l),h=Qx.getBroadcastDims(t,o),f=Qx.getBroadcastDims(n,o),m=Qx.mergeRealAndImagArrays(r,a),g=Qx.mergeRealAndImagArrays(s,i),y=t.length,b=Sa.computeStrides(t),x=n.length,v=Sa.computeStrides(n);if(h.length+f.length===0)for(let w=0;w<c.length;w++){let t=w%m.length,n=w%g.length,r=e(m[2*t],m[2*t+1],g[2*n],g[2*n+1]);c[w]=r.real,d[w]=r.imag}else for(let w=0;w<c.length;w++){let t=Sa.indexToLoc(w,u,p),n=t.slice(-y);h.forEach((e=>n[e]=0));let r=Sa.locToIndex(n,y,b),a=t.slice(-x);f.forEach((e=>a[e]=0));let s=Sa.locToIndex(a,x,v),i=e(m[2*r],m[2*r+1],g[2*s],g[2*s+1]);c[w]=i.real,d[w]=i.imag}return[c,d,o]}}var VO=AO(((e,t)=>e+t)),GO=UO(((e,t,n,r)=>({real:e+n,imag:t+r}))),HO=WO(Ye,VO,GO),jO={kernelName:Ye,backendName:"cpu",kernelFunc:HO};function qO(e,t,n,r,a){let s=Sa.sizeFromShape(r),i=Sa.makeZerosTypedArray(a,n);for(let o=0;o<e.length;o++){let n=e[o];if(n<0)throw new Error("Input x must be non-negative!");n>=a||(i[n]+=s>0?t[o]:1)}return i}function KO(e,t,n,r=!1){let a=e.shape[0],s=e.shape[1],i=xo([a,n],t.dtype);for(let o=0;o<a;o++)for(let a=0;a<s;a++){let s=e.get(o,a);if(s<0)throw new Error("Input x must be non-negative!");s>=n||(r?i.set(1,o,s):t.size>0?i.set(i.get(o,s)+t.get(o,a),o,s):i.set(i.get(o,s)+1,o,s))}return i}function XO(e){return(t,n,r)=>{let a=Sa.getArrayFromDType(n,t.length);for(let s=0;s<t.length;++s)a[s]=e(t[s],r);return a}}function JO(e,t,n){let r=XO(t);return YO(e,r,n)}function YO(e,t,n){return({inputs:r,attrs:a,backend:s})=>{let{x:i}=r;IO(i,e);let o,l=s,u=l.data.get(i.dataId).values;if("string"===i.dtype){if(!Array.isArray(u))throw new Error("String tensor's value was not an instance of Array");o=Qx.fromUint8ToStringArray(u)}else o=u;let p=n||i.dtype,c=t(o,p,a);return l.makeTensorInfo(i.shape,p,c)}}var ZO=XO((e=>Math.ceil(e))),QO=YO(bt,ZO),eP={kernelName:bt,backendName:"cpu",kernelFunc:QO};function tP(e,t,n,r){let a=Sa.getArrayFromDType(n,Sa.sizeFromShape(t));if(r&&"string"!==n){let t=0;e.forEach((e=>{let n=Sa.sizeFromShape(e.shape);a.set(e.vals,t),t+=n}))}else{let r=0;e.forEach((e=>{let s="string"===n?Qx.fromUint8ToStringArray(e.vals):e.vals,i=0;for(let n=0;n<e.shape[0];++n){let o=n*t[1]+r;for(let t=0;t<e.shape[1];++t)a[o+t]=s[i++]}r+=e.shape[1]}))}return a}var nP=AO(((e,t)=>e===t?1:0)),rP=WO(Kt,nP,null,"bool"),aP={kernelName:Kt,backendName:"cpu",kernelFunc:rP},sP=XO((e=>Math.exp(e))),iP=YO(Xt,sP,"float32"),oP={kernelName:Xt,backendName:"cpu",kernelFunc:iP},lP=XO((e=>Math.expm1(e))),uP=YO(Yt,lP),pP={kernelName:Yt,backendName:"cpu",kernelFunc:uP},cP=XO((e=>Math.floor(e))),dP=YO(tn,cP),hP={kernelName:tn,backendName:"cpu",kernelFunc:dP},fP=AO(((e,t)=>Math.floor(e/t))),mP=WO(nn,fP,null,"int32"),gP={kernelName:nn,backendName:"cpu",kernelFunc:mP};function yP(e,t,n,r,a,s,i,o,l){let u=xo([r,s],n);for(let p=0;p<r;p++){let n=[],r=0;for(let t=0;t<a;t++){let s=e[p*a+t];r+=s*i[t],n.push(s)}if(r<0||r>=l/s)throw new Error(`Invalid indices: ${n} does not index into ${o}`);for(let e=0;e<s;e++)u.values[p*s+e]=t.get(...t.indexToLoc(r*s+e))}return u}function bP(e,t,n){let r=xo(n,e.dtype);for(let a=0;a<r.size;++a){let n=r.indexToLoc(a).slice(),s=n[0],i=n[2],o=t.locToIndex([s,i]);n[2]=t.values[o];let l=e.locToIndex(n);0<=l&&l<e.values.length&&(r.values[a]=e.values[l])}return r}var xP=AO(((e,t)=>e>t?1:0)),vP=WO(on,xP,null,"bool"),wP={kernelName:on,backendName:"cpu",kernelFunc:vP},kP=AO(((e,t)=>e>=t?1:0)),IP=WO(ln,kP,null,"bool"),SP={kernelName:ln,backendName:"cpu",kernelFunc:IP},NP=AO(((e,t)=>e<t?1:0)),TP=WO(gn,NP,null,"bool"),_P={kernelName:gn,backendName:"cpu",kernelFunc:TP},CP=AO(((e,t)=>e<=t?1:0)),EP=WO(yn,CP,null,"bool"),AP={kernelName:yn,backendName:"cpu",kernelFunc:EP};function $P(e,t,n){let r=(t-e)/(n-1),a=Sa.makeZerosTypedArray(n,"float32");a[0]=e;for(let s=1;s<a.length;s++)a[s]=a[s-1]+r;return a}var RP=XO((e=>Math.log(e))),FP=YO(xn,RP),DP={kernelName:xn,backendName:"cpu",kernelFunc:FP};function MP(e,t,n,r){let a=Sa.getTypedArrayFromDType(r,Sa.sizeFromShape(n));for(let s=0;s<a.length;++s){let n=s*t,r=e[n];for(let a=0;a<t;++a){let t=e[n+a];(Number.isNaN(t)||t>r)&&(r=t)}a[s]=r}return a}var OP=AO(((e,t)=>Math.max(e,t))),PP=WO($n,OP),LP={kernelName:$n,backendName:"cpu",kernelFunc:PP},zP=AO(((e,t)=>Math.min(e,t))),BP=WO(zn,zP),WP={kernelName:zn,backendName:"cpu",kernelFunc:BP},UP=AO(((e,t)=>e*t)),VP=UO(((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n}))),GP=WO(Vn,UP,VP),HP={kernelName:Vn,backendName:"cpu",kernelFunc:GP};function jP(e,t,n){let r=Sa.createScalarValue(-1,n);return UP([],t,r,e,n)}function qP(e){let{inputs:t,backend:n}=e,{x:r}=t;IO(r,"neg");let a=n.data.get(r.dataId).values,[s,i]=jP(a,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,s)}var KP={kernelName:Gn,backendName:"cpu",kernelFunc:qP},XP=AO(((e,t)=>e!==t?1:0)),JP=WO(Hn,XP,null,"bool"),YP={kernelName:Hn,backendName:"cpu",kernelFunc:JP};function ZP(e,t,n,r,a){let s=t.length,i=Sa.sizeFromShape(t),o=Sa.computeStrides(t),l=Sa.computeStrides(a),u=Sa.getTypedArrayFromDType(n,Sa.sizeFromShape(a));for(let p=0;p<i;++p){let t=Sa.indexToLoc(p,s,o),n=new Array(t.length);for(let e=0;e<n.length;e++)n[e]=t[r[e]];let a=Sa.locToIndex(n,s,l);u[a]=e[p]}return u}function QP(e){let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{perm:s}=n;IO(a,"transpose");let i=a.shape.length,o=new Array(i);for(let p=0;p<o.length;p++)o[p]=a.shape[s[p]];let l=r.data.get(a.dataId).values,u=ZP(l,a.shape,a.dtype,s,o);return{dataId:r.write(u,o,a.dtype),shape:o,dtype:a.dtype}}var eL={kernelName:Qr,backendName:"cpu",kernelFunc:QP};function tL(e,t,n,r){let[a,s]=Qx.computeOutAndReduceShapes(e,r),i=Cs(t,"int32"),o=Sa.makeZerosTypedArray(Sa.sizeFromShape(a),i),l=Sa.sizeFromShape(s);for(let u=0;u<o.length;++u){let e=u*l,t=1;for(let r=0;r<l;++r)t*=n[e+r];o[u]=t}return{outVals:o,outShape:a,outDtype:i}}function nL(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;IO(a,"prod");let o=a.shape.length,l=Sa.parseAxisParam(s,a.shape),u=Qx.getAxesPermutation(l,o),p=l,c=a,d=[];null!=u&&(c=QP({inputs:{x:a},backend:n,attrs:{perm:u}}),d.push(c),p=Qx.getInnerMostAxes(p.length,o));let h=n.data.get(c.dataId).values,{outVals:f,outShape:m,outDtype:g}=tL(c.shape,c.dtype,h,p),y=m;return i&&(y=Qx.expandShapeToKeepDim(m,l)),d.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(y,g,f)}var rL={kernelName:nr,backendName:"cpu",kernelFunc:nL};function aL(e,t,n){e.forEach(((e,r)=>{if(e<0||e>=n){let a=Sa.indexToLoc(r,t.length,Sa.computeStrides(t)).join(",");throw new Error(`indices[${a}] = ${e} is not in [0, ${n})`)}}))}function sL(e,t){for(let n=0;n<e.length;++n){let r=e[n],a=n===e.length-1?t:e[n+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>a)throw new Error("Ragged splits must not point past values");for(let e=1;e<r.length;++e)if(r[e-1]>r[e])throw new Error("Ragged splits must be sorted in ascending order")}}function iL(e,t,n,r){let a=[],s=0,i=t.length-1+n.length,o=new Array(i).fill(null).map((()=>[0]));sL(n,r);let l=1;for(let u=0;u<t.length-1;++u){l*=t[u];let e=t[u+1];for(let t=1;t<l+1;++t)o[u].push(t*e)}for(let u=0;u<e.length;++u){let r=e[u],i=e[u]+1;for(let e=0;e<n.length;++e){let a=n[e],s=e+t.length-1;if(s>=0){let e=o[s],t=e[e.length-1]-a[r];for(let n=r;n<i;++n)o[s].push(a[n+1]+t)}r=a[r],i=a[i]}i!==r&&(a.push([r,i]),s+=i-r)}return{outSplits:o,valueSlices:a,numValues:s}}function oL(e){let t=[];for(let n=0;n<e.length;++n){let r=e[n].length,a=Sa.getArrayFromDType("int32",r);t.push(a),e[n].forEach(((e,t)=>a[t]=e))}return t}function lL(e,t){let n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function uL(e,t,n,r,a,s){let i=lL(t,2)[1],o=lL(s,2)[1],l=0;for(let u of n)for(let t=u[0];t<u[1];++t){for(let n=0;n<r;++n)a[l*o+n]=e[t*i+n];++l}}function pL(e,t,n,r,a){let s=t.slice();s[0]=a;let i=Sa.getArrayFromDType(n,Sa.sizeFromShape(s)),o=e.length,l=0===o?0:o/t[0];return uL(e,t,r,l,i,s),[i,s]}function cL(e,t,n,r,a,s,i,o){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");let l=t[0][0]-1;if(aL(s,i,l),0===r.length)throw new Error("params.rank must be nonzero");let u=r[0],{outSplits:p,valueSlices:c,numValues:d}=iL(s,i,e,u),h=oL(p),f=pL(n,r,a,c,d);return[h,f[0],f[1]]}var dL=2147483647;function hL(e,t,n,r,a,s,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(a.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");let o=0===t.length,l=0===a.length,u=0===i.length,p=[];o||p.push(t[0]),l||p.push(a[0]),u||p.push(i[0]);for(let g=1;g<p.length;++g)if(p[g]!==p[g-1])throw new Error("starts, limits, and deltas must have the same shape");let c=0===p.length?1:p[0],d=Sa.getArrayFromDType("int32",c+1);d[0]=0;for(let g=0;g<c;++g){let t,n=o?e[0]:e[g],a=l?r[0]:r[g],i=u?s[0]:s[g];if(0===i)throw new Error("Requires delta != 0");if(i>0&&a<n||i<0&&a>n)t=0;else if(t=Math.ceil(Math.abs((a-n)/i)),t>dL)throw new Error(`Requires ((limit - start) / delta) <= ${dL}`);d[g+1]=d[g]+t}let h=d[c],f=Sa.getArrayFromDType(n,h),m=0;for(let g=0;g<c;++g){let t=d[g+1]-d[g],n=o?e[0]:e[g],r=u?s[0]:s[g];for(let e=0;e<t;++e)f[m++]=n,n+=r}return[d,f]}var fL=Qx.RowPartitionType,mL=class{constructor(e,t,n,r,a,s,i,o,l,u){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=r,this.valuesDType=a,this.defaultValue=s,this.defaultValueShape=i,this.rowPartitionValues=o,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=Qx.getRowPartitionTypesHelper(u),this.raggedRank=Qx.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===fL.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===fL.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){let t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case fL.VALUE_ROWIDS:return mL.getMaxWidthValueRowID(t);case fL.ROW_SPLITS:return mL.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${fL[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){let t=e.length;if(0===t||1===t)return 0;let n=0;for(let r=0;r<t-1;++r){let t=e[r+1]-e[r];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){let t=e.length;if(0===t)return 0;let n=0,r=e[0],a=0;for(let s=1;s<t;++s){let t=e[s];t!==r&&(r=t,a=Math.max(s-n,a),n=s)}return Math.max(t-n,a)}tensorShapeFromTensor(e,t,n=!0){if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return yL(e,n)}calculateOutputSize(e){let t=this.valuesShape,n=this.defaultValueShape;Qx.validateDefaultValueShape(n,t);let r=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=Qx.combineRaggedTensorToTensorShapes(this.raggedRank,r,t);a[0]<0&&(a[0]=e);for(let s=1;s<=this.raggedRank;++s)a[s]<0&&(a[s]=this.getMaxWidth(s));return a}calculateFirstParentOutputIndex(e,t,n){let r=Math.min(e,n),a=[],s=0;for(let i=0;i<r;++i,s+=t)a.push(s);for(let i=r;i<e;++i)a.push(-1);return Sa.assert(a.length===e,(()=>"Final length of result must be equal to firstDimension.")),a}calculateOutputIndexRowSplit(e,t,n,r){let a=e.length,s=[];for(let i=0;i<a-1;++i){let a=e[i+1]-e[i],o=Math.min(r,a),l=t[i];-1===l&&(o=0);for(let e=0;e<o;++e)s.push(l),l+=n;for(let e=0;e<a-o;++e)s.push(-1)}if(a>0&&s.length!==e[a-1])throw new Error("Invalid row split size.");return s}calculateOutputIndexValueRowID(e,t,n,r){let a=e.length,s=[];if(0===a)return[];let i=0,o=e[0];if(o>=t.length)throw new Error(`Got currentValueRowId=${o}, which is not less than ${t.length}`);let l=t[o];s.push(l);for(let u=1;u<a;++u){let a=e[u];if(a===o)l>=0&&(++i,i<r?l+=n:l=-1);else{if(i=0,o=a,a>=t.length)throw new Error(`Got nextValueRowId=${a} which is not less than ${t.length}`);l=t[a]}s.push(l)}if(s.length!==e.length)throw new Error("Invalid row ids.");return s}calculateOutputIndex(e,t,n,r){let a=this.getRowPartitionTensor(e),s=this.getRowPartitionTypeByDimension(e);switch(s){case fL.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(a,t,n,r);case fL.ROW_SPLITS:if(a.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${a.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(a,t,n,r);default:throw new Error(`Unsupported partition type: ${fL[s]}`)}}getFirstDimensionSize(){let e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");let t=this.rowPartitionTypes[0];switch(t){case fL.FIRST_DIM_SIZE:return e[0];case fL.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case fL.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${fL[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");let e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let s=n.length-2;s>=0;--s)n[s]=n[s+1]*t[s+1];let r=yL(t,!1),a=Sa.getArrayFromDType(this.valuesDType,Sa.sizeFromShape(r));if(n[0]*t[0]>0){let s=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e)s=this.calculateOutputIndex(e-1,s,n[e],t[e]);this.setOutput(this.raggedRank,s,a,r)}return[r,a]}setOutput(e,t,n,r){if(0===n.length)return;let a=this.values,s=n,i=r.slice();i=i.slice(e+1);let o=Sa.sizeFromShape(i),l=t.length,u=this.defaultValue;if(u.length!==o&&1!==u.length){let e=this.defaultValueShape;Do((()=>{let t=ql(u,e);u=Tu(t,i).dataSync()}))}let p=0,c=0,d=0;for(let h=0;h<=l;++h){let e=h<l?t[h]:-1;if(e!==d){if(c<d){let e=a.subarray(p*o),t=s.subarray(c*o),n=(d-c)*o;gL(t,e,n)}if(h>=l){let t=n.length;e=Math.floor(t/o)}if(e>d)if(1===this.defaultValue.length)s.subarray(d*o,e*o).fill(this.defaultValue[0]),d=e;else for(;e>d;){let e=s.slice(d*o);gL(e,u,o),++d}e<0?(p=h+1,c=d):(p=h,c=d,d=c+1)}else++d}}};function gL(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function yL(e,t){let n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function bL(e,t,n,r,a,s,i,o,l,u){return new mL(e,t,n,r,a,s,i,o,l,u).compute()}function xL(e,t,n,r){let a=e===t,s=e<t&&n<0,i=t<e&&n>1;if(a||s||i)return Sa.makeZerosTypedArray(0,r);let o=Math.abs(Math.ceil((t-e)/n)),l=Sa.makeZerosTypedArray(o,r);t<e&&1===n&&(n=-1),l[0]=e;for(let u=1;u<l.length;u++)l[u]=l[u-1]+n;return l}var vL=XO((e=>1/Math.sqrt(e))),wL=YO(br,vL),kL={kernelName:br,backendName:"cpu",kernelFunc:wL};function IL(e,t,n,r,a,s,i,o,l,u){let p=[r/a,a],c=e.values,d=t.values;if(0===r)return xo(n,t.dtype);let h=l instanceof ds?l:xo(p,t.dtype);"string"==typeof l||"number"==typeof l?h.values.fill(l):"boolean"==typeof l&&h.values.fill(+l);for(let f=0;f<s;f++){let e=[],s=0;for(let t=0;t<i;t++){let n=c[f*i+t];e.push(n),s+=n*o[t]}if(s<0||s>=r/a)throw new Error(`Invalid indices: ${e} does not index into ${n}`);for(let n=0;n<a;n++)u?h.values[s*a+n]+=d[f*a+n]:h.values[s*a+n]=0===t.rank?d[0]:d[f*a+n]}return h}var SL=XO((e=>1/(1+Math.exp(-e)))),NL=JO(Cr,(e=>1/(1+Math.exp(-e)))),TL={kernelName:Cr,backendName:"cpu",kernelFunc:NL};function _L(e,t,n,r,a){let s=Tx.isSliceContinous(r,t,n),i=Sa.sizeFromShape(n),o=Sa.computeStrides(r);if(s){let n=Tx.computeFlatOffset(t,o);return"string"===a?e.slice(n,n+i):e.subarray(n,n+i)}let l="string"===a?Qx.fromUint8ToStringArray(e):e,u=xo(r,a,l),p=xo(n,a);for(let c=0;c<p.size;++c){let e=p.indexToLoc(c),n=e.map(((e,n)=>e+t[n]));p.set(u.get(...n),...e)}return"string"===a?Qx.fromStringArrayToUint8(p.values):p.values}function CL(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,size:i}=r;IO(a,"slice");let[o,l]=Tx.parseSliceParams(a,s,i);Tx.assertParamsValid(a,o,l);let u=n.data.get(a.dataId).values,p=_L(u,o,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,p)}var EL={kernelName:Sr,backendName:"cpu",kernelFunc:CL};function AL(e,t,n,r,a,s,i){let o=t[0],l=s[0],u=new Array(l),p=new Array(o),c=t[1];if(0===l){if(0!==o)throw new Error(Qx.getSparseFillEmptyRowsIndicesDenseShapeMismatch(o));let e=Sa.getArrayFromDType(n,0),t=Sa.getArrayFromDType(a,0);return[e,[0,c],t,u,p]}let d=!0,h=0,f=new Array(l).fill(0);for(let g=0;g<o;++g){let t=e[g*c];if(t<0)throw new Error(Qx.getSparseFillEmptyRowsNegativeIndexErrorMessage(g,t));if(t>=l)throw new Error(Qx.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(g,t,l));++f[t],d=d&&t>=h,h=t}let m=!0;for(let g=0;g<l;++g){let e=0===f[g];u[g]=e,m=m&&!e,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&d){let t=e,n=r;for(let e=0;e<o;++e)p[e]=e;return[t,[o,c],n,u,p]}{let t=f[l-1],s=Sa.getArrayFromDType(n,t*c),d=Sa.getArrayFromDType(a,t),h=new Array(l).fill(0);for(let n=0;n<o;++n){let t=e[n*c],a=h[t],i=(0===t?0:f[t-1])+a;h[t]++;for(let r=0;r<c;++r)s[i*c+r]=e[n*c+r];d[i]=r[n],p[n]=i}for(let e=0;e<l;++e)if(0===h[e]){let t=0===e?0:f[e-1];s[t*c+0]=e;for(let e=1;e<c;++e)s[t*c+e]=0;d[t]=i}return[s,[t,c],d,u,p]}}function $L(e,t,n,r,a){let s=Sa.sizeFromShape(r),i=t[0],o=a.length,l=[],u=1,p=-1;for(let m=0;m<o;++m){let e=a[m];if(-1===e){if(-1!==p)throw new Error(Qx.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(p,m));p=m,l.push(1)}else{if(e<0)throw new Error(Qx.getSparseReshapeNegativeOutputDimErrorMessage(m,e));u*=e,l.push(e)}}if(-1!==p){if(u<=0)throw new Error(Qx.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let e=Math.trunc(s/u);if(u*e!==s)throw new Error(Qx.getSparseReshapeInputOutputMultipleErrorMessage(r,l));l[p]=e}if(Sa.sizeFromShape(l)!==s)throw new Error(Qx.getSparseReshapeInputOutputMismatchErrorMessage(r,l));let c=r.length,d=[];if(c>0){d[c-1]=1;for(let e=c-2;e>=0;--e)d[e]=d[e+1]*r[e+1]}let h=[];if(o>0){h[o-1]=1;for(let e=o-2;e>=0;--e)h[e]=h[e+1]*l[e+1]}let f=Sa.getArrayFromDType(n,i*o);for(let m=0;m<i;++m){let t=0;for(let n=0;n<c;++n)t+=e[m*c+n]*d[n];for(let e=0;e<o;++e)f[m*o+e]=Math.trunc(t/h[e]),t%=h[e]}return[f,[i,o],l]}function RL(e,t,n,r,a,s=!1,i=0){let o=r.length,l=[t[0],e.length/t[0]],u=l[1],p=o>0?a[o-1]+1:0;if(p<0)throw new Error(Qx.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let c=t.slice();c[0]=p;let d=c.reduce(((e,t)=>e*t),1),h=Sa.getArrayFromDType(n,d);if(0===o)return p>0&&h.fill(i),[h,c];if(p<=0)throw new Error(Qx.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let f=0,m=1,g=0,y=a[f];for(;;){let t=0;if(m<o){if(t=a[m],y===t){++m;continue}if(y>=t)throw new Error(Qx.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(y<0||y>=p)throw new Error(Qx.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(y,p));y>g&&h.fill(i,g*u,y*u);for(let n=f;n<m;++n){let t=r[n];if(t<0||t>=l[0])throw new Error(Qx.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(n,r[n],l[0]));for(let n=0;n<u;n++)h[y*u+n]+=e[t*u+n]}if(s)for(let e=0;e<u;e++)h[y*u+e]/=m-f;if(f=m,++m,g=y+1,y=t,m>o)break}return g<p&&h.fill(i,g*u,p*u),[h,c]}var FL=XO((e=>Math.sqrt(e))),DL=JO(Ar,(e=>Math.sqrt(e))),ML={kernelName:Ar,backendName:"cpu",kernelFunc:DL},OL=AO(((e,t)=>{let n=e-t;return n*n})),PL=WO(Br,OL),LL={kernelName:Br,backendName:"cpu",kernelFunc:PL},zL=XO(((e,t)=>{let{pattern:n,replaceGlobal:r,rewrite:a}=t;return e.replace(new RegExp(n,r?"g":""),a)})),BL=YO(Ur,zL),WL={kernelName:Ur,backendName:"cpu",kernelFunc:BL};function UL(e,t,n,r){let a=xo(e,t.dtype);for(let s=0;s<a.size;s++){let e=a.indexToLoc(s),i=new Array(e.length);for(let t=0;t<i.length;t++)i[t]=e[t]*n[t]+r[t];a.set(t.get(...i),...e)}return a}var VL=class{constructor(e,t,n,r,a,s){this.separator=Sa.encodeString(e),this.nGramWidths=t,this.leftPad=Sa.encodeString(n),this.rightPad=Sa.encodeString(r),this.padWidth=a,this.preserveShort=s}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){let n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,a,s){for(let i=0;i<a;++i){let o=this.getPadWidth(s),l=Math.max(0,o-i),u=Math.max(0,o-(a-(i+1))),p=s-(l+u),c=t+(l>0?0:i-o),d=0;d+=l*this.leftPad.length;for(let t=0;t<p;++t)d+=e[c+t].length;d+=u*this.rightPad.length;let h=l+u+p-1;d+=h*this.separator.length,n[r+i]=new Uint8Array(d);let f=n[r+i],m=0,g=e=>e.forEach((e=>f[m++]=e));for(let e=0;e<l;++e)g(this.leftPad),g(this.separator);for(let t=0;t<p-1;++t)g(e[c+t]),g(this.separator);if(p>0){g(e[c+p-1]);for(let e=0;e<u;++e)g(this.separator),g(this.rightPad)}else{for(let e=0;e<u-1;++e)g(this.rightPad),g(this.separator);g(this.rightPad)}}}compute(e,t){let n=e.length,r=t.length;if(r>0){let e=t[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let a=1;a<r;++a){let r=t[a]>=e;if(r=r&&t[a]<=n,!r)throw new Error(`Invalid split value ${t[a]}, must be in [${e}, ${n}]`);e=t[a]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}let a=r-1,s=Sa.getArrayFromDType("int32",r);if(0===n||0===r){let e=new Array(n);for(let t=0;t<=a;++t)s[t]=0;return[e,s]}s[0]=0;for(let o=1;o<=a;++o){let e=t[o]-t[o-1],n=0;this.nGramWidths.forEach((t=>{n+=this.getNumNGrams(e,t)})),this.preserveShort&&e>0&&0===n&&(n=1),s[o]=s[o-1]+n}let i=new Array(s[a]);for(let o=0;o<a;++o){let n=t[o],r=s[o];if(this.nGramWidths.forEach((a=>{let s=t[o+1]-t[o],l=this.getNumNGrams(s,a);this.createNGrams(e,n,i,r,l,a),r+=l})),this.preserveShort&&r===s[o]){let a=t[o+1]-t[o];if(0===a)continue;let s=a+2*this.padWidth,l=1;this.createNGrams(e,n,i,r,l,s)}}return[i,s]}};function GL(e,t,n,r,a,s,i,o){return new VL(n,r,a,s,i,o).compute(e,t)}function HL(e,t,n,r){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)r.push(e.subarray(t,t+1));return}if(1===t.length){let a=t[0],s=e.indexOf(a);for(;-1!==s;){let t=e.subarray(0,s);(!n||0!==t.length)&&r.push(t),e=e.subarray(s+1),s=e.indexOf(a)}return void((!n||0!==e.length)&&r.push(e))}let a=0;for(let s=0;s<e.length+1;s++)if(s===e.length||-1!==t.indexOf(e[s])){let t=e.subarray(a,s);(!n||0!==t.length)&&r.push(t),a=s+1}}function jL(e,t,n){let r=e.length,a=[],s=0,i=0,o=new Array(r);for(let d=0;d<r;++d){let r=a.length;HL(e[d],t,n,a);let l=a.length-r;o[d]=l,s+=l,i=Math.max(i,l)}let l=Sa.getArrayFromDType("int32",2*s),u=new Array(s),p=[r,i],c=0;for(let d=0;d<r;++d)for(let e=0;e<o[d];++e)l[2*c]=d,l[2*c+1]=e,u[c]=a[c],++c;return[l,u,p]}function qL(e,t){let n=Sa.getArrayFromDType("int32",e.length);for(let r=0;r<e.length;++r)n[r]=Sa.fingerPrint64(e[r]).modulo(t).getLowBitsUnsigned();return n}var KL=AO(((e,t)=>e-t)),XL=UO(((e,t,n,r)=>({real:e-n,imag:t-r}))),JL=WO(qr,KL,XL),YL={kernelName:qr,backendName:"cpu",kernelFunc:JL};function ZL(e,t){let n=new Array(e.rank);for(let a=0;a<n.length;a++)n[a]=e.shape[a]*t[a];let r=xo(n,e.dtype);for(let a=0;a<r.values.length;++a){let t=r.indexToLoc(a),n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=t[r]%e.shape[r];let s=e.locToIndex(n);r.values[a]=e.values[s]}return r}var QL=(e,t)=>{let n=t.value-e.value;return 0===n?e.index-t.index:n};function ez(e,t,n=0,r=e.length-1){for(;r>n;){if(r-n>600){let a=r-n+1,s=t-n+1,i=Math.log(a),o=.5*Math.exp(2*i/3),l=.5*Math.sqrt(i*o*(a-o)/a)*Math.sign(s-a/2),u=Math.max(n,Math.floor(t-s*o/a+l)),p=Math.min(r,Math.floor(t+(a-s)*o/a+l));ez(e,t,u,p)}let a=e[t],s=n,i=r;for(Sa.swap(e,n,t),QL(e[r],a)>0&&Sa.swap(e,n,r);s<i;){for(Sa.swap(e,s,i),s++,i--;QL(e[s],a)<0;)s+=1;for(;QL(e[i],a)>0;)i-=1}0===QL(e[n],a)?Sa.swap(e,n,i):(i+=1,Sa.swap(e,i,r)),i<=t&&(n=i+1),t<=i&&(r=i-1)}}function tz(e,t,n,r,a){let s=t[t.length-1],[i,o]=[e.length/s,s],l=Sa.getTypedArrayFromDType(n,i*r),u=Sa.getTypedArrayFromDType("int32",i*r);for(let c=0;c<i;c++){let t=c*o,n=e.subarray(t,t+o),s=new Array(n.length);n.forEach(((e,t)=>s[t]={value:e,index:t})),r<s.length&&(ez(s,r),s=s.slice(0,r)),a&&s.sort(QL);let i=c*r,p=l.subarray(i,i+r),d=u.subarray(i,i+r);for(let e=0;e<r;e++)p[e]=s[e].value,d[e]=s[e].index}let p=t.slice();return p[p.length-1]=r,[xo(p,n,l),xo(p,"int32",u)]}function nz(e,t,n,r){let a=Sa.parseAxisParam(t,n)[0],s=[1,n[0],1];for(let f=0;f<a;f++)s[0]*=n[f];s[1]=n[a];for(let f=a+1;f<n.length;f++)s[2]*=n[f];let i=new Map,o=new Int32Array(n[a]),l=new ds(s,r,e),u=[],p=1===s[0]&&1===s[2];for(let f=0;f<n[a];f++){let t;if(p)t=e[f].toString();else{let e=[];for(let t=0;t<s[0];t++)for(let n=0;n<s[2];n++)e.push(l.get(t,f,n));t=e.join(",")}let n=i.get(t);if(null!=n)o[f]=n;else{let e=i.size;i.set(t,e),o[f]=e,u.push(f)}}let c=s.slice();c[1]=i.size;let d=new ds(c,r);u.forEach(((e,t)=>{for(let n=0;n<s[0];n++)for(let r=0;r<s[2];r++)d.set(l.get(n,e,r),n,t,r)}));let h=n.slice();return h[a]=c[1],{outputValues:d.values,outputShape:h,indices:o}}var rz="4.3.0";Go("cpu",(()=>new NO),1);var az=JO(Ht,(e=>e>=0?e:Math.exp(e)-1)),sz={kernelName:Ht,backendName:"cpu",kernelFunc:az};function iz(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:s}=r;IO([a],"leakyRelu");let i=Sa.sizeFromShape(a.shape),o=n.data.get(a.dataId).values,l=Sa.getTypedArrayFromDType("float32",i);for(let u=0;u<o.length;u++)l[u]=o[u]<0?s*o[u]:o[u];return n.makeTensorInfo(a.shape,"float32",l)}var oz={kernelName:mn,backendName:"cpu",kernelFunc:iz},lz=AO(((e,t)=>e<0?t*e:e));function uz(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t;IO([r,a],"prelu");let s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,[o,l]=lz(r.shape,a.shape,s,i,"float32");return n.makeTensorInfo(l,"float32",o)}var pz={kernelName:tr,backendName:"cpu",kernelFunc:uz},cz=JO(ur,(e=>Math.max(0,e))),dz={kernelName:ur,backendName:"cpu",kernelFunc:cz},hz=JO(mr,(e=>Math.min(Math.max(0,e),6))),fz={kernelName:mr,backendName:"cpu",kernelFunc:hz};function mz(e,t,n,r,a){if("linear"===n)return DO({inputs:{x:t},backend:e});if("relu"===n)return cz({inputs:{x:t},backend:e});if("elu"===n)return az({inputs:{x:t},backend:e});if("relu6"===n)return hz({inputs:{x:t},backend:e});if("prelu"===n)return uz({inputs:{x:t,alpha:r},backend:e});if("leakyrelu"===n)return iz({inputs:{x:t},backend:e,attrs:{alpha:a}});if("sigmoid"===n)return NL({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function gz(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:s}=r,i=Sa.sizeFromShape(a.shape),o=Sa.inferFromImplicitShape(s,i),l=Sa.sizeFromShape(o);Sa.assert(i===l,(()=>`The new shape (${o}) has ${l} elements and the old shape (${a.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`)),n.incRef(a.dataId);let u=n.data.get(a.dataId);if(null!=u.complexTensorInfos){let e=u.complexTensorInfos.real,t=u.complexTensorInfos.imag;e.shape=o,t.shape=o}return{dataId:a.dataId,shape:o,dtype:a.dtype}}var yz={kernelName:pr,backendName:"cpu",kernelFunc:gz};function bz(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:s}=t,{transposeA:i,transposeB:o}=r;IO([a,s],"matMul");let l=a.shape.length,u=s.shape.length,p=i?a.shape[l-2]:a.shape[l-1],c=o?s.shape[u-1]:s.shape[u-2],d=i?a.shape[l-1]:a.shape[l-2],h=o?s.shape[u-2]:s.shape[u-1],f=a.shape.slice(0,-2),m=s.shape.slice(0,-2),g=Sa.sizeFromShape(f),y=Sa.sizeFromShape(m),b=bp.assertAndGetBroadcastShape(a.shape.slice(0,-2),s.shape.slice(0,-2)).concat([d,h]);Sa.assert(p===c,(()=>`Error in matMul: inner shapes (${p}) and (${c}) of Tensors with shapes ${a.shape} and ${s.shape} and transposeA=${i} and transposeB=${o} must match.`));let x=i?[g,p,d]:[g,d,p],v=o?[y,h,c]:[y,c,h],w=gz({inputs:{x:a},backend:n,attrs:{shape:x}}),k=gz({inputs:{x:s},backend:n,attrs:{shape:v}}),I=i?w.shape[1]:w.shape[2],S=i?w.shape[2]:w.shape[1],N=o?k.shape[1]:k.shape[2],T=Math.max(g,y),_=n.data.get(w.dataId).values,C=n.data.get(k.dataId).values,E=Sa.computeStrides(w.shape),A=Sa.computeStrides(k.shape),[$,R,F]=i?[E[0],1,E[1]]:[E[0],E[1],1],[D,M,O]=o?[1,A[1],A[0]]:[A[1],1,A[0]],P=S*N,L=xo([T,S,N],w.dtype),z=L.values,B=n.blockSize;for(let W=0;W<T;W++){let e=W%g,t=W%y;for(let n=0;n<S;n+=B){let r=Math.min(n+B,S);for(let a=0;a<N;a+=B){let s=Math.min(a+B,N);for(let i=0;i<I;i+=B){let o=Math.min(i+B,I);for(let l=n;l<r;l++)for(let n=a;n<s;n++){let r=0;for(let a=i;a<o;a++){let s=_[e*$+l*R+a*F],i=C[a*D+n*M+t*O];r+=s*i}z[W*P+(l*N+n)]+=r}}}}}return n.disposeIntermediateTensorInfo(w),n.disposeIntermediateTensorInfo(k),n.makeTensorInfo(b,L.dtype,L.values)}var xz={kernelName:dt,backendName:"cpu",kernelFunc:bz};function vz(e){let t,n,r,{inputs:a,backend:s,attrs:i}=e,{a:o,b:l,bias:u,preluActivationWeights:p}=a,{transposeA:c,transposeB:d,activation:h,leakyreluAlpha:f}=i,m=[];t=bz({inputs:{a:o,b:l},attrs:{transposeA:c,transposeB:d},backend:s}),u&&(n=HO({inputs:{a:t,b:u},backend:s}),m.push(t),t=n),h&&(r=mz(s,t,h,p,f),m.push(t),t=r);for(let g of m)s.disposeIntermediateTensorInfo(g);return t}var wz={kernelName:la,backendName:"cpu",kernelFunc:vz},kz=JO(Xe,(e=>Math.acos(e))),Iz={kernelName:Xe,backendName:"cpu",kernelFunc:kz},Sz=JO(Je,(e=>Math.acosh(e))),Nz={kernelName:Je,backendName:"cpu",kernelFunc:Sz};function Tz(e){let{inputs:t,backend:n}=e,r=t;IO(t,"addN");let a=r.map((e=>n.data.get(e.dataId).values)),s=xo(r[0].shape,r[0].dtype),i=s.values;for(let o=0;o<r.length;o++){let e=a[o];for(let t=0;t<i.length;t++)i[t]+=e[t]}return n.makeTensorInfo(s.shape,s.dtype,s.values)}var _z={kernelName:Ze,backendName:"cpu",kernelFunc:Tz};function Cz(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;IO(a,"all");let o=Sa.parseAxisParam(s,a.shape),l=o,u=Qx.getAxesPermutation(l,a.shape.length),p=a;null!=u&&(p=QP({inputs:{x:a},backend:n,attrs:{perm:u}}),l=Qx.getInnerMostAxes(l.length,a.shape.length)),Qx.assertAxesAreInnerMostDims("all",l,p.shape.length);let[c,d]=Qx.computeOutAndReduceShapes(p.shape,l),h=Sa.sizeFromShape(d),f=Sa.makeZerosTypedArray(Sa.sizeFromShape(c),p.dtype),m=n.data.get(p.dataId).values;for(let y=0;y<f.length;++y){let e=y*h,t=m[e];for(let n=0;n<h;++n){let r=m[e+n];t=t&&r}f[y]=t}null!=u&&n.disposeIntermediateTensorInfo(p);let g=n.makeTensorInfo(c,p.dtype,f);if(i){let e=Qx.expandShapeToKeepDim(c,o),t=gz({inputs:{x:g},backend:n,attrs:{shape:e}});return n.disposeIntermediateTensorInfo(g),t}return g}var Ez={kernelName:Qe,backendName:"cpu",kernelFunc:Cz};function Az(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;IO(a,"any");let o=Sa.parseAxisParam(s,a.shape),l=o,u=Qx.getAxesPermutation(l,a.shape.length),p=a;null!=u&&(p=QP({inputs:{x:a},backend:n,attrs:{perm:u}}),l=Qx.getInnerMostAxes(l.length,a.shape.length)),Qx.assertAxesAreInnerMostDims("any",l,p.shape.length);let[c,d]=Qx.computeOutAndReduceShapes(p.shape,l),h=Sa.sizeFromShape(d),f=Sa.makeZerosTypedArray(Sa.sizeFromShape(c),p.dtype),m=n.data.get(p.dataId).values;for(let y=0;y<f.length;++y){let e=y*h,t=m[e];for(let n=0;n<h;++n){let r=m[e+n];t=t||r}f[y]=t}null!=u&&n.disposeIntermediateTensorInfo(p);let g=n.makeTensorInfo(c,p.dtype,f);if(i){let e=Qx.expandShapeToKeepDim(c,o),t=gz({inputs:{x:g},backend:n,attrs:{shape:e}});return n.disposeIntermediateTensorInfo(g),t}return g}var $z={kernelName:et,backendName:"cpu",kernelFunc:Az};function Rz(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;IO(a,"argMax");let i=Sa.parseAxisParam(s,a.shape),o=Qx.getAxesPermutation(i,a.shape.length),l=a,u=[];null!=o&&(l=QP({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=Qx.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],Qx.assertAxesAreInnerMostDims("argMax",i,l.shape.length);let[p,c]=Qx.computeOutAndReduceShapes(l.shape,i),d=Sa.sizeFromShape(p),h=Sa.makeZerosTypedArray(d,"int32"),f=Sa.sizeFromShape(c),m=n.data.get(l.dataId).values;for(let g=0;g<h.length;++g){let e=g*f,t=m[e],n=0;for(let r=0;r<f;++r){let a=m[e+r];a>t&&(t=a,n=r)}h[g]=n}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(p,"int32",h)}var Fz={kernelName:tt,backendName:"cpu",kernelFunc:Rz};function Dz(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;IO(a,"argMin");let i=Sa.parseAxisParam(s,a.shape),o=Qx.getAxesPermutation(i,a.shape.length),l=a,u=[];null!=o&&(l=QP({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=Qx.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],Qx.assertAxesAreInnerMostDims("argMin",i,l.shape.length);let[p,c]=Qx.computeOutAndReduceShapes(l.shape,i),d=Sa.sizeFromShape(p),h=Sa.makeZerosTypedArray(d,"int32"),f=Sa.sizeFromShape(c),m=n.data.get(l.dataId).values;for(let g=0;g<h.length;++g){let e=g*f,t=m[e],n=0;for(let r=0;r<f;++r){let a=m[e+r];a<t&&(t=a,n=r)}h[g]=n}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(p,"int32",h)}var Mz={kernelName:nt,backendName:"cpu",kernelFunc:Dz},Oz=JO(rt,(e=>Math.asin(e))),Pz={kernelName:rt,backendName:"cpu",kernelFunc:Oz},Lz=JO(at,(e=>Math.asinh(e))),zz={kernelName:at,backendName:"cpu",kernelFunc:Lz},Bz=JO(st,(e=>Math.atan(e))),Wz={kernelName:st,backendName:"cpu",kernelFunc:Bz},Uz=AO(((e,t)=>Math.atan2(e,t))),Vz=WO(ot,Uz),Gz={kernelName:ot,backendName:"cpu",kernelFunc:Vz},Hz=JO(it,(e=>Math.atanh(e))),jz={kernelName:it,backendName:"cpu",kernelFunc:Hz};function qz(e,t,n,r,a,s){let i=a.strideHeight,o=a.strideWidth,l=a.dilationHeight,u=a.dilationWidth,p=a.effectiveFilterHeight,c=a.effectiveFilterWidth,d=a.padInfo.top,h=a.padInfo.left,f="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=xo(a.outShape,n),g=m.values,y=a.outShape[1]*a.outShape[2]*a.outShape[3],b=a.outShape[2]*a.outShape[3],x=a.outShape[3];for(let v=0;v<a.batchSize;++v){let t=v*y,n=v*r[0];for(let m=0;m<a.inChannels;++m)for(let y=0;y<a.outHeight;++y){let v=y*i-d,w=Math.max(0,v),k=Math.min(a.inHeight,p+v),I=t+y*b;for(let t=0;t<a.outWidth;++t){let i=t*o-h,p=Math.max(0,i),d=Math.min(a.inWidth,c+i),y=f,b=0,v=0;for(let t=w;t<k;t+=l){let a=n+t*r[1];for(let t=p;t<d;t+=u){let n=a+t*r[2],i=e[n+m];"max"===s&&i>y?y=i:"avg"===s&&(b+=i,v++)}if(isNaN(y))break}let S=I+t*x+m;g[S]="avg"===s?b/v:y}}}return m}function Kz(e,t,n,r,a=!1,s=!1){let i=xo(r.outShape,"int32"),o=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,p=r.dilationWidth,c=r.effectiveFilterHeight,d=r.effectiveFilterWidth,h=r.padInfo.top,f=r.padInfo.left,m=xo(t,n,e);for(let g=0;g<r.batchSize;++g)for(let e=0;e<r.inChannels;++e)for(let t=0;t<r.outHeight;++t){let n=t*o-h,y=n;for(;y<0;)y+=u;let b=Math.min(r.inHeight,c+n);for(let o=0;o<r.outWidth;++o){let c=o*l-f,h=c;for(;h<0;)h+=p;let x=Math.min(r.inWidth,d+c),v=Number.NEGATIVE_INFINITY,w=-1;for(let t=y;t<b;t+=u){let i=t-n;for(let n=h;n<x;n+=p){let o=n-c,l=m.get(g,t,n,e);l>v&&(v=l,w=a?s?((g*r.inHeight+t)*r.inWidth+n)*r.inChannels+e:(t*r.inWidth+n)*r.inChannels+e:i*d+o)}}i.set(w,g,t,o,e)}}return i}function Xz(e,t,n,r,a,s){let i=a.strideDepth,o=a.strideHeight,l=a.strideWidth,u=a.dilationDepth,p=a.dilationHeight,c=a.dilationWidth,d=a.effectiveFilterDepth,h=a.effectiveFilterHeight,f=a.effectiveFilterWidth,m=a.padInfo.front,g=a.padInfo.top,y=a.padInfo.left,b="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=xo(a.outShape,n),v=x.values,w=a.outShape[1]*a.outShape[2]*a.outShape[3]*a.outShape[4],k=a.outShape[2]*a.outShape[3]*a.outShape[4],I=a.outShape[3]*a.outShape[4],S=a.outShape[4];for(let N=0;N<a.batchSize;++N){let t=N*w,n=N*r[0];for(let x=0;x<a.inChannels;++x)for(let w=0;w<a.outDepth;++w){let N=w*i-m,T=N;for(;T<0;)T+=u;let _=Math.min(a.inDepth,d+N),C=t+w*k;for(let t=0;t<a.outHeight;++t){let i=t*o-g,d=i;for(;d<0;)d+=p;let m=Math.min(a.inHeight,h+i),w=C+t*I;for(let t=0;t<a.outWidth;++t){let i=t*l-y,o=i;for(;o<0;)o+=c;let h=Math.min(a.inWidth,f+i),g=w+t*S,k=b,I=0,N=0;for(let t=T;t<_;t+=u){let a=n+t*r[1];for(let t=d;t<m;t+=p){let n=a+t*r[2];for(let t=o;t<h;t+=c){let a=n+t*r[3],i=e[a+x];if("max"===s&&i>k?k=i:"avg"===s&&(I+=i,N++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}let C=g+x;v[C]="avg"===s?I/Math.max(N,1):k}}}}return x}function Jz(e,t){let n=xo(t.outShape,"int32"),r=t.strideDepth,a=t.strideHeight,s=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,p=t.effectiveFilterHeight,c=t.effectiveFilterWidth,d=t.padInfo.front,h=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){let b=y*r-d,x=b;for(;x<0;)x+=i;let v=Math.min(t.inDepth,u+b);for(let r=0;r<t.outHeight;++r){let u=r*a-h,d=u;for(;d<0;)d+=o;let w=Math.min(t.inHeight,p+u);for(let a=0;a<t.outWidth;++a){let h=a*s-f,k=h;for(;k<0;)k+=l;let I=Math.min(t.inWidth,c+h),S=Number.NEGATIVE_INFINITY,N=-1;for(let t=x;t<v;t+=i){let n=t-b;for(let r=d;r<w;r+=o){let a=r-u;for(let s=k;s<I;s+=l){let i=s-h,o=e.get(m,t,r,s,g);o>=S&&(S=o,N=n*p*c+a*p+i)}}}n.set(N,m,y,r,a,g)}}}return n}function Yz(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;IO(a,"avgPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r,u=1;Sa.assert(Qx.eitherStridesOrDilationsAreOne(i,u),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`));let p,c=Qx.computePool2DInfo(a.shape,s,i,u,o,l);if(1===c.filterWidth&&1===c.filterHeight&&Sa.arraysEqual(c.inShape,c.outShape))p=DO({inputs:{x:a},backend:n});else{let e=n.data.get(a.dataId).values,t=Sa.computeStrides(a.shape),r=qz(e,a.shape,a.dtype,t,c,"avg");p=n.makeTensorInfo(c.outShape,a.dtype,r.values)}return p}var Zz={kernelName:lt,backendName:"cpu",kernelFunc:Yz};function Qz(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;IO(a,"avgPool3d");let p=Qx.computePool3DInfo(a.shape,s,i,1,o,l,u),c=n.data.get(a.dataId).values,d=Xz(c,a.shape,a.dtype,Sa.computeStrides(a.shape),p,"avg");return n.makeTensorInfo(d.shape,"float32",d.values)}var eB={kernelName:pt,backendName:"cpu",kernelFunc:Qz};function tB(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;IO([a,s],"avgPool3DGrad");let p=Qx.computePool3DInfo(s.shape,i,o,1,l,u),c=p.strideDepth,d=p.strideHeight,h=p.strideWidth,f=p.filterDepth,m=p.filterHeight,g=p.filterWidth,y=p.dilationDepth,b=p.dilationHeight,x=p.dilationWidth,v=p.effectiveFilterDepth,w=p.effectiveFilterHeight,k=p.effectiveFilterWidth,I=v-1-p.padInfo.front,S=k-1-p.padInfo.left,N=w-1-p.padInfo.top,T=xo(s.shape,"float32"),_=1/(f*m*g),C=n.bufferSync(a);for(let E=0;E<p.batchSize;++E)for(let e=0;e<p.inChannels;++e)for(let t=0;t<p.inDepth;++t)for(let n=0;n<p.inHeight;++n)for(let r=0;r<p.inWidth;++r){let a=t-I,s=n-N,i=r-S,o=0;for(let t=0;t<v;t+=y){let n=(a+t)/c;if(!(n<0||n>=p.outDepth||Math.floor(n)!==n))for(let t=0;t<w;t+=b){let r=(s+t)/d;if(!(r<0||r>=p.outHeight||Math.floor(r)!==r))for(let t=0;t<k;t+=x){let a=(i+t)/h;if(a<0||a>=p.outWidth||Math.floor(a)!==a)continue;let s=C.get(E,n,r,a,e);o+=s}}}T.set(o*_,E,t,n,r,e)}return n.makeTensorInfo(T.shape,T.dtype,T.values)}var nB={kernelName:ct,backendName:"cpu",kernelFunc:tB};function rB(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s;IO([a,s],"avgPoolGrad");let{filterSize:o,strides:l,pad:u}=r,p=Qx.computePool2DInfo(i.shape,o,l,1,u),c=p.strideHeight,d=p.strideWidth,h=p.filterHeight,f=p.filterWidth,m=p.dilationHeight,g=p.dilationWidth,y=p.effectiveFilterHeight,b=p.effectiveFilterWidth,x=b-1-p.padInfo.left,v=y-1-p.padInfo.top,w=xo(i.shape,"float32"),k=1/(h*f),I=n.data.get(a.dataId).values,S=xo(a.shape,"float32",I);for(let N=0;N<p.batchSize;++N)for(let e=0;e<p.inChannels;++e)for(let t=0;t<p.inHeight;++t)for(let n=0;n<p.inWidth;++n){let r=t-v,a=n-x,s=0;for(let t=0;t<y;t+=m){let n=(r+t)/c;if(!(n<0||n>=p.outHeight||Math.floor(n)!==n))for(let t=0;t<b;t+=g){let r=(a+t)/d;if(r<0||r>=p.outWidth||Math.floor(r)!==r)continue;let i=S.get(N,n,r,e);s+=i}}w.set(s*k,N,t,n,e)}return n.makeTensorInfo(w.shape,w.dtype,w.values)}var aB={kernelName:ut,backendName:"cpu",kernelFunc:rB};function sB(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,scale:s,offset:i,mean:o,variance:l}=t;Sa.assert(o.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Sa.assert(null==i||o.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Sa.assert(null==s||o.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),IO([a,o,l,s,i],"batchNorm");let{varianceEpsilon:u}=r;null==u&&(u=.001);let p=n.data.get(a.dataId).values,c=n.data.get(o.dataId).values,d=n.data.get(l.dataId).values,h=s?n.data.get(s.dataId).values:new Float32Array([1]),f=i?n.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(p.length),g=f.length,y=h.length,b=d.length,x=c.length,v=0,w=0,k=0,I=0;for(let S=0;S<p.length;++S)m[S]=f[v++]+(p[S]-c[w++])*h[k++]/Math.sqrt(d[I++]+u),v>=g&&(v=0),w>=x&&(w=0),k>=y&&(k=0),I>=b&&(I=0);return n.makeTensorInfo(a.shape,a.dtype,m)}var iB={kernelName:rn,backendName:"cpu",kernelFunc:sB};function oB(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r;IO([a],"batchToSpaceND");let o=s.reduce(((e,t)=>e*t)),l=Qx.getReshaped(a.shape,s,o),u=Qx.getPermuted(l.length,s.length),p=Qx.getReshapedPermuted(a.shape,s,o),c=Qx.getSliceBeginCoords(i,s.length),d=Qx.getSliceSize(p,i,s.length),h=gz({inputs:{x:a},backend:n,attrs:{shape:l}}),f=QP({inputs:{x:h},backend:n,attrs:{perm:u}}),m=gz({inputs:{x:f},backend:n,attrs:{shape:p}}),g=CL({inputs:{x:m},backend:n,attrs:{begin:c,size:d}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}var lB={kernelName:ht,backendName:"cpu",kernelFunc:oB};function uB(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i}=r,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,u=qO(o,l,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,u)}var pB={kernelName:ft,backendName:"cpu",kernelFunc:uB};function cB(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,o=Qx.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}var dB={kernelName:gt,backendName:"cpu",kernelFunc:cB},hB=JO(xt,((e,t)=>{let n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e})),fB={kernelName:xt,backendName:"cpu",kernelFunc:hB},mB=e=>{let{x:t}=e.inputs,n=e.backend,r=new Float32Array(Sa.sizeFromShape(t.shape)),a=n.data.get(t.dataId),s=a.complexTensorInfos.real,i=a.complexTensorInfos.imag,o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values;for(let u=0;u<o.length;u++){let e=o[u],t=l[u];r[u]=Math.hypot(e,t)}return n.makeOutput(r,t.shape,"float32")},gB={kernelName:wt,backendName:"cpu",kernelFunc:mB};function yB(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.imag,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}var bB={kernelName:cn,backendName:"cpu",kernelFunc:yB};function xB(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,s=Sa.parseAxisParam(a,t[0].shape)[0],i=t.map((e=>e.shape));Qx.assertParamsConsistent(i,s);let o=Qx.computeOutShape(t.map((e=>e.shape)),s);if(0===Sa.sizeFromShape(o))return n.makeTensorInfo(o,t[0].dtype,[]);let l=t.filter((e=>Sa.sizeFromShape(e.shape)>0));if(1===l.length)return DO({inputs:{x:l[0]},backend:n});if("complex64"===l[0].dtype){let e=l.map((e=>OO({inputs:{input:e},backend:n}))),t=l.map((e=>yB({inputs:{input:e},backend:n}))),r=xB({inputs:e,backend:n,attrs:{axis:s}}),a=xB({inputs:t,backend:n,attrs:{axis:s}}),i=$O({inputs:{real:r,imag:a},backend:n});return e.forEach((e=>n.disposeIntermediateTensorInfo(e))),t.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a),i}let u=l.map((e=>{let t=[-1,Sa.sizeFromShape(e.shape.slice(s))];return gz({inputs:{x:e},backend:n,attrs:{shape:t}})})),p=u.map((e=>({vals:n.data.get(e.dataId).values,shape:e.shape})));o=Qx.computeOutShape(u.map((e=>e.shape)),1);let c=1===u[0].shape[0],d=tP(p,o,t[0].dtype,c),h=Qx.computeOutShape(l.map((e=>e.shape)),s),f=n.makeTensorInfo(h,t[0].dtype,d);return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}var vB={kernelName:kt,backendName:"cpu",kernelFunc:xB};function wB(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:p}=r;IO([a,s],"conv2d");let c=Qx.convertConv2DDataFormat(l),d=Qx.computeConv2DInfo(a.shape,s.shape,i,u,o,p,!1,c),h=d.filterHeight,f=d.filterWidth,m=d.dilationHeight,g=d.dilationWidth,y=d.padInfo.left,b=d.padInfo.top,x="channelsLast"===d.dataFormat,v=new ds(d.outShape,a.dtype),w=Sa.computeStrides(a.shape),k=Sa.computeStrides(s.shape),I=w[0],S=x?w[1]:w[2],N=x?w[2]:1,T=x?1:w[1],_=v.strides[0],C=x?v.strides[1]:v.strides[2],E=x?v.strides[2]:1,A=x?1:v.strides[1],$=n.data.get(a.dataId).values,R=n.data.get(s.dataId).values,F=v.values;for(let D=0;D<d.batchSize;++D){let e=D*I,t=D*_;for(let n=0;n<d.outHeight;++n){let r=t+n*C,a=n*d.strideHeight-b;for(let t=0;t<h;++t){let n=a+t*m;if(n<0||n>=d.inHeight)continue;let s=t*k[0],i=e+n*S;for(let e=0;e<d.outWidth;++e){let t=r+e*E,n=e*d.strideWidth-y;for(let e=0;e<f;++e){let r=n+e*g;if(r<0||r>=d.inWidth)continue;let a=s+e*k[1],o=i+r*N,l=a;for(let e=0;e<d.inChannels;++e){let n=$[o+e*T];for(let e=0;e<d.outChannels;++e)F[t+e*A]+=n*R[l+e];l+=d.outChannels}}}}}}return n.makeTensorInfo(v.shape,v.dtype,F)}var kB={kernelName:It,backendName:"cpu",kernelFunc:wB};function IB(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:p}=r;IO([a,s],"conv2dBackpropFilter");let c=Qx.convertConv2DDataFormat(l),d=Qx.computeConv2DInfo(a.shape,p,i,1,o,u,!1,c),{strideHeight:h,strideWidth:f,filterHeight:m,filterWidth:g}=d,y="channelsLast"===d.dataFormat,b=new ds(d.filterShape,"float32"),x=d.padInfo.left,v=d.padInfo.top,w=n.data.get(a.dataId).values,k=n.data.get(s.dataId).values,I=new ds(a.shape,a.dtype,w),S=new ds(s.shape,s.dtype,k);for(let N=0;N<m;++N){let e=Math.max(0,Math.ceil((v-N)/h)),t=Math.min(d.outHeight,(d.inHeight+v-N)/h);for(let n=0;n<g;++n){let r=Math.max(0,Math.ceil((x-n)/f)),a=Math.min(d.outWidth,(d.inWidth+x-n)/f);for(let s=0;s<d.inChannels;++s)for(let i=0;i<d.outChannels;++i){let o=0;for(let l=0;l<d.batchSize;++l)for(let u=e;u<t;++u){let e=N+u*h-v;for(let t=r;t<a;++t){let r=n+t*f-x;o+=y?I.get(l,e,r,s)*S.get(l,u,t,i):I.get(l,s,e,r)*S.get(l,i,u,t)}}b.set(o,N,n,s,i)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}var SB={kernelName:St,backendName:"cpu",kernelFunc:IB};function NB(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:p}=r;IO([a,s],"conv2dBackpropInput");let c=Sa.computeStrides(s.shape),d=Sa.computeStrides(a.shape),h=Qx.convertConv2DDataFormat(u),f=Qx.computeConv2DInfo(i,s.shape,o,1,l,p,!1,h),m=new ds(f.inShape,"float32"),g=m.values,y=n.data.get(a.dataId).values,b=n.data.get(s.dataId).values,[x,v,w]=c,{batchSize:k,filterHeight:I,filterWidth:S,inChannels:N,inHeight:T,inWidth:_,outChannels:C,outHeight:E,outWidth:A,strideHeight:$,strideWidth:R}=f;h=f.dataFormat;let F=I-1-f.padInfo.top,D=S-1-f.padInfo.left,M="channelsLast"===h,O=m.strides[0],P=M?m.strides[1]:m.strides[2],L=M?m.strides[2]:1,z=M?1:m.strides[1],B=d[0],W=M?d[1]:d[2],U=M?d[2]:1,V=M?1:d[1];for(let G=0;G<k;++G)for(let e=0;e<N;++e)for(let t=0;t<T;++t){let n=t-F,r=Math.max(0,Math.ceil(n/$)),a=Math.min(E,(I+n)/$);for(let s=0;s<_;++s){let i=s-D,o=Math.max(0,Math.ceil(i/R)),l=Math.min(A,(S+i)/R),u=0;for(let t=r;t<a;++t){let r=t*$-n;for(let n=o;n<l;++n){let a=n*R-i,s=B*G+W*t+U*n,o=x*(I-1-r)+v*(S-1-a)+w*e;for(let e=0;e<C;++e){let t=y[s+V*e],n=b[o+e];u+=t*n}}}let p=O*G+P*t+L*s+z*e;g[p]=u}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}var TB={kernelName:Nt,backendName:"cpu",kernelFunc:NB};function _B(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r;IO([a,s],"conv3d");let u=Qx.computeConv3DInfo(a.shape,s.shape,i,l,o),{filterDepth:p,filterHeight:c,filterWidth:d,dilationDepth:h,dilationHeight:f,dilationWidth:m,padInfo:g}=u,y=g.front,b=g.left,x=g.top,v=new ds(u.outShape,a.dtype),w=n.data.get(a.dataId).values,k=n.data.get(s.dataId).values,I=v.values,S=Sa.computeStrides(a.shape),N=Sa.computeStrides(s.shape);for(let T=0;T<u.batchSize;++T){let e=T*S[0],t=T*v.strides[0];for(let n=0;n<u.outDepth;++n){let r=t+n*v.strides[1],a=n*u.strideDepth-y;for(let t=0;t<p;++t){let n=a+t*h;if(n<0||n>=u.inDepth)continue;let s=t*N[0],i=e+n*S[1];for(let e=0;e<u.outHeight;++e){let t=r+e*v.strides[2],n=e*u.strideHeight-x;for(let e=0;e<c;++e){let r=n+e*f;if(r<0||r>=u.inHeight)continue;let a=s+e*N[1],o=i+r*S[2];for(let e=0;e<u.outWidth;++e){let n=t+e*u.outChannels,r=e*u.strideWidth-b;for(let e=0;e<d;++e){let t=r+e*m;if(t<0||t>=u.inWidth)continue;let s=a+e*N[2],i=o+t*u.inChannels,l=s;for(let e=0;e<u.inChannels;++e){let t=w[i+e];for(let e=0;e<u.outChannels;++e)I[n+e]+=t*k[l+e];l+=u.outChannels}}}}}}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}var CB={kernelName:Tt,backendName:"cpu",kernelFunc:_B};function EB(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=r;IO([a,s],"conv3dBackpropFilterV2");let u=Sa.computeStrides(a.shape),p=Sa.computeStrides(s.shape),c=Qx.computeConv3DInfo(a.shape,l,i,1,o),d=c.strideDepth,h=c.strideHeight,f=c.strideWidth,m=c.filterDepth,g=c.filterHeight,y=c.filterWidth,b=new ds(c.filterShape,"float32"),x=b.values,[v,w,k,I]=b.strides,S=n.data.get(s.dataId).values,[N,T,_,C]=p,E=n.data.get(a.dataId).values,[A,$,R,F]=u,D=c.padInfo.front,M=c.padInfo.left,O=c.padInfo.top;for(let P=0;P<m;++P){let e=Math.max(0,Math.ceil((D-P)/d)),t=Math.min(c.outDepth,(c.inDepth+D-P)/d),n=P*v;for(let r=0;r<g;++r){let a=Math.max(0,Math.ceil((O-r)/h)),s=Math.min(c.outHeight,(c.inHeight+O-r)/h),i=r*w+n;for(let n=0;n<y;++n){let o=Math.max(0,Math.ceil((M-n)/f)),l=Math.min(c.outWidth,(c.inWidth+M-n)/f),u=n*k+i;for(let i=0;i<c.inChannels;++i){let p=i*I+u;for(let u=0;u<c.outChannels;++u){let m=0;for(let p=0;p<c.batchSize;++p){let c=p*A,g=p*N;for(let p=e;p<t;++p){let e=(P+p*d-D)*$+c,t=p*T+g;for(let p=a;p<s;++p){let a=(r+p*h-O)*R+e,s=p*_+t;for(let e=o;e<l;++e){let t=(n+e*f-M)*F+a,r=e*C+s;m+=E[t+i]*S[r+u]}}}}x[p+u]=m}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}var AB={kernelName:_t,backendName:"cpu",kernelFunc:EB};function $B(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=r;IO([a],"conv3dBackpropInputV2");let u=Sa.computeStrides(a.shape),p=Sa.computeStrides(s.shape),c=Qx.computeConv3DInfo(l,s.shape,o,1,i),d=new ds(c.inShape,"float32"),h=d.values,[f,m,g,y]=d.strides,b=n.data.get(a.dataId).values,[x,v,w,k]=u,I=n.data.get(s.dataId).values,[S,N,T,_]=p,{batchSize:C,filterDepth:E,filterHeight:A,filterWidth:$,inChannels:R,inDepth:F,inHeight:D,inWidth:M,outChannels:O,outDepth:P,outHeight:L,outWidth:z,strideDepth:B,strideHeight:W,strideWidth:U}=c,V=E-1-c.padInfo.front,G=A-1-c.padInfo.top,H=$-1-c.padInfo.left;for(let j=0;j<C;++j)for(let e=0;e<R;++e)for(let t=0;t<F;++t){let n=t-V,r=Math.max(0,Math.ceil(n/B)),a=Math.min(P,(E+n)/B);for(let s=0;s<D;++s){let i=s-G,o=Math.max(0,Math.ceil(i/W)),l=Math.min(L,(A+i)/W);for(let u=0;u<M;++u){let p=u-H,c=Math.max(0,Math.ceil(p/U)),d=Math.min(z,($+p)/U),C=0;for(let t=r;t<a;++t){let r=t*B-n;for(let n=o;n<l;++n){let a=n*W-i;for(let s=c;s<d;++s){let i=s*U-p,o=x*j+v*t+w*n+k*s,l=S*(E-1-r)+N*(A-1-a)+T*($-1-i)+_*e;for(let e=0;e<O;++e){let t=b[o+e],n=I[l+e];C+=t*n}}}}h[f*j+m*t+g*s+y*u+e]=C}}}return n.makeTensorInfo(d.shape,d.dtype,d.values)}var RB={kernelName:Ct,backendName:"cpu",kernelFunc:$B},FB=JO(Et,(e=>Math.cos(e))),DB={kernelName:Et,backendName:"cpu",kernelFunc:FB},MB=JO(At,(e=>Math.cosh(e))),OB={kernelName:At,backendName:"cpu",kernelFunc:MB};function PB(e){let{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,[p,c,d,h]=a.shape,f=s.shape[0],[m,g]=o,y=xo([f,m,g,h],"float32"),b=n.data.get(s.dataId).values,x=n.data.get(i.dataId).values,v=n.data.get(a.dataId).values,w=Sa.computeStrides(a.shape),k=Sa.computeStrides(y.shape);for(let I=0;I<f;I++){let e=4*I,t=b[e],n=b[e+1],r=b[e+2],a=b[e+3],s=x[I];if(s>=p)continue;let i=m>1?(r-t)*(c-1)/(m-1):0,o=g>1?(a-n)*(d-1)/(g-1):0;for(let p=0;p<m;p++){let e=m>1?t*(c-1)+p*i:.5*(t+r)*(c-1);if(e<0||e>c-1)for(let t=0;t<g;t++)for(let e=0;e<h;e++){let n=e+t*k[2]+p*k[1]+I*k[0];y.values[n]=u}else if("bilinear"===l){let t=Math.floor(e),r=Math.ceil(e),i=e-t;for(let e=0;e<g;e++){let l=g>1?n*(d-1)+e*o:.5*(n+a)*(d-1);if(l<0||l>d-1){for(let t=0;t<h;t++){let n=t+e*k[2]+p*k[1]+I*k[0];y.values[n]=u}continue}let c=Math.floor(l),f=Math.ceil(l),m=l-c;for(let n=0;n<h;n++){let a=n+c*w[2]+t*w[1]+s*w[0],o=v[a];a=n+f*w[2]+t*w[1]+s*w[0];let l=v[a];a=n+c*w[2]+r*w[1]+s*w[0];let u=v[a];a=n+f*w[2]+r*w[1]+s*w[0];let d=v[a],h=o+(l-o)*m,g=u+(d-u)*m;a=n+e*k[2]+p*k[1]+I*k[0],y.values[a]=h+(g-h)*i}}}else for(let t=0;t<g;++t){let r=g>1?n*(d-1)+t*o:.5*(n+a)*(d-1);if(r<0||r>d-1){for(let e=0;e<h;e++){let n=e+t*k[2]+p*k[1]+I*k[0];y.values[n]=u}continue}let i=Math.round(r),l=Math.round(e);for(let e=0;e<h;e++){let n=e+i*w[2]+l*w[1]+s*w[0],r=e+t*k[2]+p*k[1]+I*k[0];y.values[r]=v[n]}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}var LB={kernelName:Ft,backendName:"cpu",kernelFunc:PB};function zB(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;IO(a,"cumprod");let l=Qx.getAxesPermutation([s],a.shape.length),u=a;null!=l&&(u=QP({inputs:{x:a},backend:n,attrs:{perm:l}}));let p=Qx.getInnerMostAxes(1,a.shape.length)[0];if(p!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${p}`);let c=Cs(u.dtype,"int32"),d=Sa.makeOnesTypedArray(Sa.sizeFromShape(u.shape),c),h=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let y=0;y<h.length;y+=f)for(let e=0;e<f;e++){let t=m(y,e);if(0===e)d[t]=i?1:h[t];else{let n=m(y,e-1);d[t]=i?h[n]*d[n]:h[t]*d[n]}}let g=n.makeTensorInfo(u.shape,c,d);if(null!=l){let e=Qx.getUndoAxesPermutation(l),t=QP({inputs:{x:g},backend:n,attrs:{perm:e}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),t}return g}var BB={kernelName:$t,backendName:"cpu",kernelFunc:zB};function WB(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;IO(a,"cumsum");let l=Qx.getAxesPermutation([s],a.shape.length),u=a;null!=l&&(u=QP({inputs:{x:a},backend:n,attrs:{perm:l}}));let p=Qx.getInnerMostAxes(1,a.shape.length)[0];if(p!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${p}`);let c=Cs(u.dtype,"int32"),d=Sa.makeZerosTypedArray(Sa.sizeFromShape(u.shape),c),h=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let y=0;y<h.length;y+=f)for(let e=0;e<f;e++){let t=m(y,e);if(0===e)d[t]=i?0:h[t];else{let n=m(y,e-1);d[t]=i?h[n]+d[n]:h[t]+d[n]}}let g=n.makeTensorInfo(u.shape,c,d);if(null!=l){let e=Qx.getUndoAxesPermutation(l),t=QP({inputs:{x:g},backend:n,attrs:{perm:e}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),t}return g}var UB={kernelName:Rt,backendName:"cpu",kernelFunc:WB};function VB(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i,binaryOutput:o}=r;if(1===a.shape.length){let e=n.data.get(a.dataId).values,t=n.data.get(s.dataId).values,r=qO(e,t,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,r)}if(2===a.shape.length){let e=n.bufferSync(a),t=n.bufferSync(s),r=KO(e,t,i,o);return n.makeTensorInfo(r.shape,s.dtype,r.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}var GB={kernelName:Dt,backendName:"cpu",kernelFunc:VB};function HB(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:s,dataFormat:i}=r;Sa.assert("NHWC"===i,(()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`));let o=a.shape[0],l=a.shape[1],u=a.shape[2],p=a.shape[3],c=l*s,d=u*s,h=p/(s*s),f=n.data.get(a.dataId).values,m=new Float32Array(o*c*d*h),g=0;for(let y=0;y<o;++y)for(let e=0;e<c;++e){let t=Math.floor(e/s),n=e%s;for(let e=0;e<d;++e){let r=Math.floor(e/s),a=e%s,i=(n*s+a)*h;for(let e=0;e<h;++e){let n=e+i+p*(r+u*(t+l*y));m[g++]=f[n]}}}return n.makeTensorInfo([o,c,d,h],a.dtype,m)}var jB={kernelName:Mt,backendName:"cpu",kernelFunc:HB};function qB(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r;IO([a,s],"depthwiseConv2DNative");let p=Sa.computeStrides(a.shape),c=Sa.computeStrides(s.shape),d=l;null==d&&(d=[1,1]),Sa.assert(Qx.eitherStridesOrDilationsAreOne(i,d),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`));let h=Qx.computeConv2DInfo(a.shape,s.shape,i,d,o,u,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=h,x=b.left,v=b.top,w=h.outChannels/h.inChannels,k=new ds(h.outShape,a.dtype),I=n.data.get(a.dataId).values,S=n.data.get(s.dataId).values,N=k.values;for(let T=0;T<h.batchSize;++T){let e=T*p[0],t=T*k.strides[0];for(let n=0;n<h.outHeight;++n){let r=t+n*k.strides[1],a=n*h.strideHeight-v;for(let t=0;t<f;++t){let n=a+t*g;if(n<0||n>=h.inHeight)continue;let s=t*c[0],i=e+n*p[1];for(let e=0;e<h.outWidth;++e){let t=r+e*k.strides[2],n=e*h.strideWidth-x;for(let e=0;e<m;++e){let r=n+e*y;if(r<0||r>=h.inWidth)continue;let a=s+e*c[1],o=i+r*h.inChannels,l=t,u=a;for(let e=0;e<h.inChannels;++e){let t=I[o+e];for(let e=0;e<w;++e)N[l+e]+=t*S[u+e];l+=w,u+=w}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}var KB={kernelName:Ot,backendName:"cpu",kernelFunc:qB};function XB(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:p}=r;IO([a,s],"depthwiseConv2dNativeBackpropFilter");let c=Qx.computeConv2DInfo(a.shape,p,i,o,l,u,!0),{strideHeight:d,strideWidth:h,filterHeight:f,filterWidth:m}=c,g=new ds(c.filterShape,"float32"),y=c.padInfo.left,b=c.padInfo.top,x=c.outChannels/c.inChannels,v=n.data.get(a.dataId).values,w=new ds(a.shape,a.dtype,v),k=n.data.get(s.dataId).values,I=new ds(s.shape,s.dtype,k);for(let S=0;S<f;++S){let e=Math.max(0,Math.ceil((b-S)/d)),t=Math.min(c.outHeight,(c.inHeight+b-S)/d);for(let n=0;n<m;++n){let r=Math.max(0,Math.ceil((y-n)/h)),a=Math.min(c.outWidth,(c.inWidth+y-n)/h);for(let s=0;s<c.outChannels;++s){let i=Math.trunc(s/x),o=s%x,l=0;for(let u=0;u<c.batchSize;++u)for(let o=e;o<t;++o){let e=S+o*d-b;for(let t=r;t<a;++t){let r=n+t*h-y;l+=w.get(u,e,r,i)*I.get(u,o,t,s)}}g.set(l,S,n,i,o)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}var JB={kernelName:Pt,backendName:"cpu",kernelFunc:XB};function YB(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:p}=r;IO([a,s],"depthwiseConv2DNativeBackpropInput");let c=Sa.computeStrides(a.shape),d=Sa.computeStrides(s.shape),h=Qx.computeConv2DInfo(p,s.shape,i,o,l,u,!0),f=new ds(h.inShape,"float32"),m=f.values,[g,y,b]=f.strides,x=n.data.get(a.dataId).values,[v,w,k]=c,I=n.data.get(s.dataId).values,[S,N,T]=d,{batchSize:_,filterHeight:C,filterWidth:E,inChannels:A,inHeight:$,inWidth:R,outChannels:F,outHeight:D,outWidth:M,strideHeight:O,strideWidth:P}=h,L=C-1-h.padInfo.top,z=E-1-h.padInfo.left,B=F/A;for(let W=0;W<_;++W)for(let e=0;e<A;++e)for(let t=0;t<$;++t){let n=t-L,r=Math.max(0,Math.ceil(n/O)),a=Math.min(D,(C+n)/O);for(let s=0;s<R;++s){let i=s-z,o=Math.max(0,Math.ceil(i/P)),l=Math.min(M,(E+i)/P),u=0;for(let t=r;t<a;++t){let r=t*O-n;for(let n=o;n<l;++n){let a=n*P-i,s=v*W+w*t+k*n,o=S*(C-1-r)+N*(E-1-a)+T*e;for(let t=0;t<B;++t){let n=e*B+t,r=x[s+n],a=I[o+t];u+=r*a}}}m[g*W+y*t+b*s+e]=u}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}var ZB={kernelName:Lt,backendName:"cpu",kernelFunc:YB};function QB(e){let{inputs:t,backend:n}=e,{x:r}=t,a=Sa.sizeFromShape(r.shape),s=n.data.get(r.dataId).values,i=xo([a,a],r.dtype),o=i.values;for(let u=0;u<s.length;u++)o[u*a+u]=s[u];let l=[...r.shape,...r.shape];return n.makeTensorInfo(l,i.dtype,i.values)}var eW={kernelName:zt,backendName:"cpu",kernelFunc:QB},tW={kernelName:Bt,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:a}=e,{strides:s,pad:i,dilations:o}=n,l=t,u=l.data.get(r.dataId).values,p=r.shape.length,c=l.data.get(a.dataId).values,d=a.shape.length,{batchSize:h,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:x,strideHeight:v,strideWidth:w,filterHeight:k,filterWidth:I,dilationHeight:S,dilationWidth:N,outShape:T}=Qx.computeDilation2DInfo(r.shape,a.shape,s,i,"NHWC",o),_=Sa.sizeFromShape(T),C=T.length,E=Sa.getArrayFromDType(r.dtype,_);for(let A=0;A<h;++A)for(let e=0;e<y;++e){let t=e*v-x.top;for(let n=0;n<b;++n){let s=n*w-x.left;for(let i=0;i<g;++i){let o=Number.MIN_SAFE_INTEGER;for(let e=0;e<k;++e){let n=t+e*S;if(n>=0&&n<f)for(let t=0;t<I;++t){let l=s+t*N;if(l>=0&&l<m){let s=Sa.locToIndex([A,n,l,i],p,Sa.computeStrides(r.shape)),h=Sa.locToIndex([e,t,i],d,Sa.computeStrides(a.shape)),f=u[s]+c[h];f>o&&(o=f)}}}let l=Sa.locToIndex([A,e,n,i],C,Sa.computeStrides(T));E[l]=o}}}return{dataId:l.write(Sa.toTypedArray(E,r.dtype),T,r.dtype),shape:T,dtype:r.dtype}}},nW={kernelName:Ut,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:a,dy:s}=e,{strides:i,pad:o,dilations:l}=n,u=t,p=Sa.toNestedArray(r.shape,u.data.get(r.dataId).values),c=Sa.toNestedArray(a.shape,u.data.get(a.dataId).values),{batchSize:d,inHeight:h,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:x,strideWidth:v,filterHeight:w,filterWidth:k,dilationHeight:I,dilationWidth:S,outShape:N}=Qx.computeDilation2DInfo(r.shape,a.shape,i,o,"NHWC",l);Sa.assert(s.rank===N.length,(()=>`Error in ${Ut}, dy must have the same rank as output ${N.length}, but got ${s.rank}`));let T=Sa.toNestedArray(N,u.data.get(s.dataId).values),_=Sa.makeZerosNestedTypedArray(a.shape,a.dtype);for(let C=0;C<d;++C)for(let e=0;e<g;++e){let t=e*x-b.top;for(let n=0;n<y;++n){let r=n*v-b.left;for(let a=0;a<m;++a){let s=Number.MIN_SAFE_INTEGER,i=0,o=0;for(let e=0;e<w;++e){let n=t+e*I;if(n>=0&&n<h)for(let t=0;t<k;++t){let l=r+t*S;if(l>=0&&l<f){let r=p[C][n][l][a]+c[e][t][a];r>s&&(s=r,i=e,o=t)}}}_[i][o][a]+=T[C][e][n][a]}}}return{dataId:u.write(Sa.toTypedArray(_,r.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},rW={kernelName:Wt,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:a,dy:s}=e,{strides:i,pad:o,dilations:l}=n,u=t,p=Sa.toNestedArray(r.shape,u.data.get(r.dataId).values),c=Sa.toNestedArray(a.shape,u.data.get(a.dataId).values),{batchSize:d,inHeight:h,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:x,strideWidth:v,filterHeight:w,filterWidth:k,dilationHeight:I,dilationWidth:S,outShape:N}=Qx.computeDilation2DInfo(r.shape,a.shape,i,o,"NHWC",l);Sa.assert(s.rank===N.length,(()=>`Error in ${Wt}, dy must have the same rank as output ${N.length}, but got ${s.rank}`));let T=Sa.toNestedArray(N,u.data.get(s.dataId).values),_=Sa.makeZerosNestedTypedArray(r.shape,r.dtype);for(let C=0;C<d;++C)for(let e=0;e<g;++e){let t=e*x-b.top;for(let n=0;n<y;++n){let r=n*v-b.left;for(let a=0;a<m;++a){let s=Number.MIN_SAFE_INTEGER,i=t<0?0:t,o=r<0?0:r;for(let e=0;e<w;++e){let n=t+e*I;if(n>=0&&n<h)for(let t=0;t<k;++t){let l=r+t*S;if(l>=0&&l<f){let r=p[C][n][l][a]+c[e][t][a];r>s&&(s=r,i=n,o=l)}}}_[C][i][o][a]+=T[C][e][n][a]}}}return{dataId:u.write(Sa.toTypedArray(_,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};function aW(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{axis:i,keepDims:o}=a;IO(s,"sum"),t="bool"===s.dtype?zO({inputs:{x:s},backend:r,attrs:{dtype:"int32"}}):DO({inputs:{x:s},backend:r});let l=t.shape.length,u=Sa.parseAxisParam(i,t.shape),p=Qx.getAxesPermutation(u,l),c=u,d=t;null!=p&&(d=QP({inputs:{x:t},backend:r,attrs:{perm:p}}),c=Qx.getInnerMostAxes(c.length,l)),Qx.assertAxesAreInnerMostDims("sum",c,d.shape.length);let[h,f]=Qx.computeOutAndReduceShapes(d.shape,c),m=Qx.upcastType(d.dtype,"int32"),g=FO(r,h,m),y=Sa.sizeFromShape(f),b=r.data.get(g.dataId).values,x=r.data.get(d.dataId).values;for(let v=0;v<b.length;++v){let e=v*y,t=0;for(let n=0;n<y;++n)t+=x[e+n];b[v]=t}if(o){let e=Qx.expandShapeToKeepDim(g.shape,u),t=g;g=gz({inputs:{x:g},backend:r,attrs:{shape:e}}),r.disposeIntermediateTensorInfo(t)}return r.disposeIntermediateTensorInfo(t),null!=p&&r.disposeIntermediateTensorInfo(d),g}var sW={kernelName:$r,backendName:"cpu",kernelFunc:aW};function iW(e){let{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,s=t,{allDims:i,summedDims:o,idDims:l}=Qx.decodeEinsumEquation(a,s.length);Qx.checkEinsumDimSizes(i.length,l,s);let{path:u,steps:p}=Qx.getEinsumComputePath(o,l),c=p.length,d=null,h=i.length,f=[];for(let m=0;m<c;++m){for(let e of p[m]){let t,{permutationIndices:r,expandDims:a}=Qx.getEinsumPermutation(h,l[e]);Qx.isIdentityPermutation(r)?t=s[e]:(t=QP({inputs:{x:s[e]},backend:n,attrs:{perm:r}}),f.push(t));let i=t.shape.slice();for(let e=0;e<a.length;++e)i.splice(a[e],0,1);Sa.arraysEqual(t.shape,i)||(t=gz({inputs:{x:t},backend:n,attrs:{shape:i}}),f.push(t)),null===d?d=t:(d=GP({inputs:{a:t,b:d},backend:n}),f.push(d))}m<c-1&&(u[m]>=0&&(d=aW({inputs:{x:d},backend:n,attrs:{axis:u[m]-(i.length-h),keepDims:!1}}),f.push(d)),h--)}for(let m of f)m!==d&&n.disposeIntermediateTensorInfo(m);return d}var oW={kernelName:Gt,backendName:"cpu",kernelFunc:iW};function lW(e){let{inputs:t,backend:n}=e,{dy:r,y:a}=t;IO([r,a],"eluGrad");let s=new Float32Array(Sa.sizeFromShape(a.shape)),i=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values;for(let l=0;l<i.length;++l){let e=i[l];s[l]=e>=0?o[l]:o[l]*(e+1)}return n.makeTensorInfo(a.shape,"float32",s)}var uW={kernelName:jt,backendName:"cpu",kernelFunc:lW},pW=Qx.ERF_P,cW=Qx.ERF_A1,dW=Qx.ERF_A2,hW=Qx.ERF_A3,fW=Qx.ERF_A4,mW=Qx.ERF_A5,gW=JO(qt,(e=>{let t=Math.sign(e),n=Math.abs(e),r=1/(1+pW*n);return t*(1-((((mW*r+fW)*r+hW)*r+dW)*r+cW)*r*Math.exp(-n*n))})),yW={kernelName:qt,backendName:"cpu",kernelFunc:gW};function bW(e){let{inputs:t,backend:n,attrs:r}=e,{input:a}=t,{dim:s}=r,i=a.shape.length,o=a.shape.slice(),l=s;return s<0&&(Sa.assert(-(i+1)<=s,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),l=i+s+1),o.splice(l,0,1),gz({inputs:{x:a},backend:n,attrs:{shape:o}})}var xW={kernelName:Jt,backendName:"cpu",kernelFunc:bW},vW=AO(((e,t)=>e/t)),wW=WO(Vt,vW),kW={kernelName:Vt,backendName:"cpu",kernelFunc:wW};function IW(e,t,n){let r=e.shape,a=r[0],s=r[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[a,s],p=Sa.sizeFromShape(u),c=Sa.getTypedArrayFromDType("float32",p),d=Sa.getTypedArrayFromDType("float32",p);for(let g=0;g<a;g++){let e=CL({inputs:{x:o},backend:n,attrs:{begin:[g,0],size:[1,s]}}),r=CL({inputs:{x:l},backend:n,attrs:{begin:[g,0],size:[1,s]}}),a=$O({inputs:{real:e,imag:r},backend:n}),{real:i,imag:u}=SW(a,t,n),p=Qx.mergeRealAndImagArrays(i,u);for(let t=0;t<s;t++){let e=Qx.getComplexWithIndex(p,t);c[g*s+t]=e.real,d[g*s+t]=e.imag}n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a)}let h=n.makeTensorInfo(u,"float32",c),f=n.makeTensorInfo(u,"float32",d),m=$O({inputs:{real:h,imag:f},backend:n});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),m}function SW(e,t,n){let r=Sa.sizeFromShape(e.shape),a=n.data.get(e.dataId),s=n.data.get(a.complexTensorInfos.real.dataId).values,i=n.data.get(a.complexTensorInfos.imag.dataId).values;if(NW(r)){let a=TW(s,i,r,t,n),o=[e.shape[0],e.shape[1]];if(t){let e=n.makeTensorInfo(o,"float32",a.real),t=n.makeTensorInfo(o,"float32",a.imag),s=n.makeTensorInfo([],"float32",Sa.createScalarValue(r,"float32")),i=DO({inputs:{x:s},backend:n}),l=kW.kernelFunc({inputs:{a:e,b:s},backend:n}),u=kW.kernelFunc({inputs:{a:t,b:i},backend:n}),p=n.data.get(l.dataId).values,c=n.data.get(u.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),{real:p,imag:c}}return a}{let e=Qx.mergeRealAndImagArrays(s,i),n=_W(e,r,t);return Qx.splitRealAndImagArrays(n)}}function NW(e){return 0===(e&e-1)}function TW(e,t,n,r,a){if(1===n)return{real:e,imag:t};let s=Qx.mergeRealAndImagArrays(e,t),i=n/2,o=Qx.complexWithEvenIndex(s),l=o.real,u=o.imag,p=[l.length],c=a.makeTensorInfo(p,"float32",l),d=a.makeTensorInfo(p,"float32",u),h=$O({inputs:{real:c,imag:d},backend:a}),f=Qx.complexWithOddIndex(s),m=f.real,g=f.imag,y=[m.length],b=a.makeTensorInfo(y,"float32",m),x=a.makeTensorInfo(y,"float32",g),v=$O({inputs:{real:b,imag:x},backend:a}),w=TW(l,u,i,r,a),k=w.real,I=w.imag,S=[k.length],N=a.makeTensorInfo(S,"float32",k),T=a.makeTensorInfo(S,"float32",I),_=$O({inputs:{real:N,imag:T},backend:a}),C=TW(m,g,i,r,a),E=C.real,A=C.imag,$=[E.length],R=a.makeTensorInfo($,"float32",E),F=a.makeTensorInfo($,"float32",A),D=$O({inputs:{real:R,imag:F},backend:a}),M=Qx.exponents(n,r),O=[M.real.length],P=a.makeTensorInfo(O,"float32",M.real),L=a.makeTensorInfo(O,"float32",M.imag),z=$O({inputs:{real:P,imag:L},backend:a}),B=GP({inputs:{a:z,b:D},backend:a}),W=HO({inputs:{a:_,b:B},backend:a}),U=JL({inputs:{a:_,b:B},backend:a}),V=OO({inputs:{input:W},backend:a}),G=OO({inputs:{input:U},backend:a}),H=yB({inputs:{input:W},backend:a}),j=yB({inputs:{input:U},backend:a}),q=xB({inputs:[V,G],backend:a,attrs:{axis:0}}),K=xB({inputs:[H,j],backend:a,attrs:{axis:0}}),X=a.data.get(q.dataId).values,J=a.data.get(K.dataId).values;return a.disposeIntermediateTensorInfo(c),a.disposeIntermediateTensorInfo(d),a.disposeIntermediateTensorInfo(h),a.disposeIntermediateTensorInfo(b),a.disposeIntermediateTensorInfo(x),a.disposeIntermediateTensorInfo(v),a.disposeIntermediateTensorInfo(N),a.disposeIntermediateTensorInfo(T),a.disposeIntermediateTensorInfo(_),a.disposeIntermediateTensorInfo(R),a.disposeIntermediateTensorInfo(F),a.disposeIntermediateTensorInfo(D),a.disposeIntermediateTensorInfo(P),a.disposeIntermediateTensorInfo(L),a.disposeIntermediateTensorInfo(z),a.disposeIntermediateTensorInfo(B),a.disposeIntermediateTensorInfo(W),a.disposeIntermediateTensorInfo(U),a.disposeIntermediateTensorInfo(V),a.disposeIntermediateTensorInfo(H),a.disposeIntermediateTensorInfo(G),a.disposeIntermediateTensorInfo(j),a.disposeIntermediateTensorInfo(q),a.disposeIntermediateTensorInfo(K),{real:X,imag:J}}function _W(e,t,n){let r=new Float32Array(2*t);for(let a=0;a<t;a++){let s=0,i=0;for(let r=0;r<t;r++){let o=Qx.exponent(a*r,t,n),l=Qx.getComplexWithIndex(e,r);s+=l.real*o.real-l.imag*o.imag,i+=l.real*o.imag+l.imag*o.real}n&&(s/=t,i/=t),Qx.assignToTypedArray(r,s,i,a)}return r}function CW(e){let{inputs:t,backend:n}=e,{input:r}=t,a=Sa.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=a/s,o=gz({inputs:{x:r},backend:n,attrs:{shape:[i,s]}}),l=IW(o,!1,n),u=gz({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}var EW={kernelName:Zt,backendName:"cpu",kernelFunc:CW};function AW(e){let{backend:t,attrs:n}=e,{shape:r,value:a,dtype:s}=n,i=s||Sa.inferDtype(a),o=Sa.getArrayFromDType(i,Sa.sizeFromShape(r));return RW(o,a,i),t.makeTensorInfo(r,i,o)}var $W={kernelName:Qt,backendName:"cpu",kernelFunc:AW};function RW(e,t,n){e.fill(t)}var FW={kernelName:en,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,a=n,s=Sa.getTypedArrayFromDType(r.dtype,Sa.sizeFromShape(r.shape)),[i,o,l,u]=r.shape,p=a.data.get(r.dataId).values;for(let c=0;c<i;c++){let e=c*l*o*u;for(let t=0;t<o;t++){let n=t*(l*u);for(let t=0;t<l;t++){let r=t*u;for(let a=0;a<u;a++){let i=Math.round(l-t-1),o=e+n+r+a,c=p[o];if(i>=0&&i<l){let t=i*u,r=e+n+t+a;c=p[r]}s[o]=c}}}}return{dataId:a.write(s,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};function DW(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:p,dilations:c,dimRoundingMode:d,activation:h,leakyreluAlpha:f}=r,m=wB({inputs:{x:a,filter:s},backend:n,attrs:{strides:l,pad:u,dataFormat:p,dilations:c,dimRoundingMode:d}});if(i){let e=m;if("NCHW"===p&&1===i.shape.length&&1!==i.shape[0]){let e=gz({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=HO({inputs:{a:m,b:e},backend:n}),n.disposeIntermediateTensorInfo(e)}else m=HO({inputs:{a:m,b:i},backend:n});n.disposeIntermediateTensorInfo(e)}if(h){let e=m;if("NCHW"===p&&"prelu"===h&&1===o.shape.length&&1!==o.shape[0]){let e=gz({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=mz(n,m,h,e,f),n.disposeIntermediateTensorInfo(e)}else m=mz(n,m,h,o,f);n.disposeIntermediateTensorInfo(e)}return m}var MW={kernelName:ua,backendName:"cpu",kernelFunc:DW};function OW(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:p,dilations:c,dimRoundingMode:d,activation:h,leakyreluAlpha:f}=r,m=qB({inputs:{x:a,filter:s},backend:n,attrs:{strides:l,pad:u,dataFormat:p,dilations:c,dimRoundingMode:d}});if(i){let e=m;m=HO({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(e)}if(h){let e=m;m=mz(n,m,h,o,f),n.disposeIntermediateTensorInfo(e)}return m}var PW={kernelName:pa,backendName:"cpu",kernelFunc:OW};function LW(e){let{inputs:t,backend:n}=e,{params:r,indices:a}=t,s=Sa.sizeFromShape(r.shape),i=a.shape,o=i[i.length-1],[l,u,p,c]=Qx.prepareAndValidate(r,a);if(0===u)return n.makeTensorInfo(l,r.dtype,[]);let d=n.data.get(a.dataId).values,h=n.bufferSync(r),f=yP(d,h,r.dtype,u,o,p,c,r.shape,s);return n.makeTensorInfo(l,r.dtype,f.values)}var zW={kernelName:sn,backendName:"cpu",kernelFunc:LW};function BW(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,indices:s}=t,{axis:i,batchDims:o}=r;IO([a,s],"gatherV2");let l=Sa.parseAxisParam(i,a.shape)[0],u=n.data.get(s.dataId).values,p=a.shape[l];for(let v=0;v<u.length;++v){let e=u[v];Sa.assert(e<=p-1&&e>=0,(()=>`GatherV2: the index value ${e} is not in [0, ${p-1}]`))}let c=o;null==o&&(c=0);let d=Sa.sizeFromShape(s.shape),h=Qx.segment_util.collectGatherOpShapeInfo(a,s,l,c),f=gz({inputs:{x:a},backend:n,attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]}}),m=gz({inputs:{x:s},backend:n,attrs:{shape:[h.batchSize,d/h.batchSize]}}),g=[h.batchSize,h.outerSize,d/h.batchSize,h.sliceSize],y=n.bufferSync(m),b=n.bufferSync(f),x=bP(b,y,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(h.outputShape,x.dtype,x.values)}var WW={kernelName:an,backendName:"cpu",kernelFunc:BW};function UW(e){let{inputs:t,backend:n}=e,{input:r}=t,a=Sa.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=a/s,o=gz({inputs:{x:r},backend:n,attrs:{shape:[i,s]}}),l=IW(o,!0,n),u=gz({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}var VW={kernelName:pn,backendName:"cpu",kernelFunc:UW},GW=JO(dn,(e=>Number.isFinite(e)?1:0),"bool"),HW={kernelName:dn,backendName:"cpu",kernelFunc:GW},jW=JO(hn,(e=>Math.abs(e)===1/0?1:0),"bool"),qW={kernelName:hn,backendName:"cpu",kernelFunc:jW},KW=JO(fn,(e=>Number.isNaN(e)?1:0),"bool"),XW={kernelName:fn,backendName:"cpu",kernelFunc:KW};function JW(e){let{backend:t,attrs:n}=e,{start:r,stop:a,num:s}=n,i=$P(r,a,s);return t.makeTensorInfo([i.length],"float32",i)}var YW={kernelName:bn,backendName:"cpu",kernelFunc:JW},ZW=JO(vn,(e=>Math.log1p(e))),QW={kernelName:vn,backendName:"cpu",kernelFunc:ZW},eU=AO(((e,t)=>e&&t)),tU=WO(wn,eU,null,"bool"),nU={kernelName:wn,backendName:"cpu",kernelFunc:tU},rU=JO(kn,(e=>e?0:1),"bool"),aU={kernelName:kn,backendName:"cpu",kernelFunc:rU},sU=AO(((e,t)=>e||t)),iU=WO(In,sU,null,"bool"),oU={kernelName:In,backendName:"cpu",kernelFunc:iU};function lU(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r;IO(a,"LRN");let u=a.shape[3],p=u-1,c=n.data.get(a.dataId).values,d=Sa.sizeFromShape(a.shape),h=new Float32Array(d);function f(e){let t=e%u,n=e-t+Math.max(0,t-s),r=e-t+Math.min(t+s,p),a=0;for(;n<=r;n++){let e=c[n];a+=e*e}return a}for(let m=0;m<d;m++){let e=f(m),t=c[m]*Math.pow(i+o*e,-l);h[m]=t}return n.makeTensorInfo(a.shape,a.dtype,h)}var uU={kernelName:_n,backendName:"cpu",kernelFunc:lU};function pU(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:p}=r;IO(i,"LRNGrad");let c=Sa.sizeFromShape(i.shape),d=i.shape[3],h=n.data.get(i.dataId).values,f=n.data.get(a.dataId).values,m=n.data.get(s.dataId).values,g=new Float32Array(c),y=c;for(let b=0;b<y;b++){let e=b%d,t=b-e+Math.max(0,e-o),n=b-e+Math.min(d,e+o+1),r=0;for(let a=t;a<n;a++)r+=Math.pow(f[a],2);r=u*r+l;for(let a=t;a<n;a++){let e=-2*u*p*f[a]*m[b]/r;b===a&&(e+=Math.pow(r,-p)),e*=h[b],g[a]+=e}}return n.makeTensorInfo(i.shape,a.dtype,g)}var cU={kernelName:Cn,backendName:"cpu",kernelFunc:pU};function dU(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:s,keepDims:i}=r,o=n,l=a.shape,u=l.length,p=Sa.parseAxisParam(s,l),c=p,d=Qx.getAxesPermutation(c,u),h=o.data.get(a.dataId).values;if(null!=d){let e=new Array(u);for(let t=0;t<e.length;t++)e[t]=l[d[t]];h=ZP(h,l,a.dtype,d,e),c=Qx.getInnerMostAxes(c.length,u),l=e}IO(a,"max"),Qx.assertAxesAreInnerMostDims("max",c,u);let[f,m]=Qx.computeOutAndReduceShapes(l,c),g=Sa.sizeFromShape(m),y=MP(h,g,f,a.dtype),b=o.write(y,f,a.dtype),x=f;return i&&(x=Qx.expandShapeToKeepDim(f,p)),{dataId:b,shape:x,dtype:a.dtype}}var hU={kernelName:An,backendName:"cpu",kernelFunc:dU};function fU(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;IO(a,"maxPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r,u=1;Sa.assert(Qx.eitherStridesOrDilationsAreOne(i,u),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`));let p,c=Qx.computePool2DInfo(a.shape,s,i,u,o,l);if(1===c.filterWidth&&1===c.filterHeight&&Sa.arraysEqual(c.inShape,c.outShape))p=DO({inputs:{x:a},backend:n});else{let e=n.data.get(a.dataId).values,t=Sa.computeStrides(a.shape),r=qz(e,a.shape,a.dtype,t,c,"max");p=n.makeTensorInfo(c.outShape,a.dtype,r.values)}return p}var mU={kernelName:Rn,backendName:"cpu",kernelFunc:fU};function gU(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;IO(a,"maxPool3d");let p=Qx.computePool3DInfo(a.shape,s,i,1,o,l,u),c=n.data.get(a.dataId).values,d=Xz(c,a.shape,a.dtype,Sa.computeStrides(a.shape),p,"max");return n.makeTensorInfo(d.shape,"float32",d.values)}var yU={kernelName:Dn,backendName:"cpu",kernelFunc:gU};function bU(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;IO([a,s],"maxPool3DGrad");let p=Qx.computePool3DInfo(s.shape,i,o,1,l,u),c=n.bufferSync(s),d=Jz(c,p),h=p.strideDepth,f=p.strideHeight,m=p.strideWidth,g=p.dilationDepth,y=p.dilationHeight,b=p.dilationWidth,x=p.effectiveFilterDepth,v=p.effectiveFilterHeight,w=p.effectiveFilterWidth,k=x-1-p.padInfo.front,I=w-1-p.padInfo.left,S=v-1-p.padInfo.top,N=xo(s.shape,"float32"),T=n.bufferSync(a);for(let _=0;_<p.batchSize;++_)for(let e=0;e<p.inChannels;++e)for(let t=0;t<p.inDepth;++t)for(let n=0;n<p.inHeight;++n)for(let r=0;r<p.inWidth;++r){let a=t-k,s=n-S,i=r-I,o=0;for(let t=0;t<x;t+=g){let n=(a+t)/h;if(!(n<0||n>=p.outDepth||Math.floor(n)!==n))for(let r=0;r<v;r+=y){let a=(s+r)/f;if(!(a<0||a>=p.outHeight||Math.floor(a)!==a))for(let s=0;s<w;s+=b){let l=(i+s)/m;if(l<0||l>=p.outWidth||Math.floor(l)!==l)continue;let u=x*v*w-1-d.get(_,n,a,l,e),c=t*v*w+r*w+s,h=u===c?1:0;if(0===h)continue;let f=T.get(_,n,a,l,e);o+=f*h}}}N.set(o,_,t,n,r,e)}return n.makeTensorInfo(N.shape,N.dtype,N.values)}var xU={kernelName:Mn,backendName:"cpu",kernelFunc:bU};function vU(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s,output:i}=t,o=s;IO([s,i],"maxPoolGrad");let{filterSize:l,strides:u,pad:p,dimRoundingMode:c}=r,d=Qx.computePool2DInfo(o.shape,l,u,1,p,c),h=n.data.get(o.dataId).values,f=xo(d.outShape,o.dtype,Kz(h,o.shape,o.dtype,d).values),m=d.strideHeight,g=d.strideWidth,y=d.dilationHeight,b=d.dilationWidth,x=d.effectiveFilterHeight,v=d.effectiveFilterWidth,w=v-1-d.padInfo.left,k=x-1-d.padInfo.top,I=xo(o.shape,"float32"),S=n.data.get(a.dataId).values,N=xo(a.shape,"float32",S);for(let T=0;T<d.batchSize;++T)for(let e=0;e<d.inChannels;++e)for(let t=0;t<d.inHeight;++t)for(let n=0;n<d.inWidth;++n){let r=t-k,a=n-w,s=0;for(let t=0;t<x;t+=y){let n=(r+t)/m;if(!(n<0||n>=d.outHeight||Math.floor(n)!==n))for(let r=0;r<v;r+=b){let i=(a+r)/g;if(i<0||i>=d.outWidth||Math.floor(i)!==i)continue;let o=x*v-1-f.get(T,n,i,e),l=t*v+r,u=o===l?1:0;if(0===u)continue;let p=N.get(T,n,i,e);s+=p*u}}I.set(s,T,t,n,e)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}var wU={kernelName:Fn,backendName:"cpu",kernelFunc:vU};function kU(e,t,n,r,a){let s=Sa.computeStrides(t),i=qz(e,t,n,s,a,"max"),o=Kz(e,t,n,a,!0,r);return[i.values,o.values]}var IU={kernelName:On,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{filterSize:a,strides:s,pad:i,includeBatchInIndex:o}=t,l=n;IO(r,"MaxPoolWithArgmax");let u=l.data.get(r.dataId).values,p=Qx.computePool2DInfo(r.shape,a,s,[1,1],i),[c,d]=kU(u,r.shape,r.dtype,o,p),h=l.write(c,p.outShape,r.dtype),f=l.write(d,p.outShape,r.dtype);return[{dataId:h,shape:p.outShape,dtype:r.dtype},{dataId:f,shape:p.outShape,dtype:"int32"}]}};function SU(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=Sa.parseAxisParam(s,a.shape),l=Qx.computeOutAndReduceShapes(a.shape,o)[1],u=Sa.sizeFromShape(l),p=[],c=n.makeTensorInfo([],"float32",new Float32Array([u]));p.push(c);let d=zO({inputs:{x:a},backend:n,attrs:{dtype:"float32"}});p.push(d);let h=wW({inputs:{a:d,b:c},backend:n});p.push(h);let f=aW({inputs:{x:h},backend:n,attrs:{axis:s,keepDims:i}});return p.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}var NU={kernelName:Pn,backendName:"cpu",kernelFunc:SU};function TU(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;IO(a,"min");let o=Sa.parseAxisParam(s,a.shape),l=o,u=Qx.getAxesPermutation(l,a.shape.length),p=a;null!=u&&(p=QP({inputs:{x:a},backend:n,attrs:{perm:u}}),l=Qx.getInnerMostAxes(l.length,a.shape.length)),Qx.assertAxesAreInnerMostDims("min",l,p.shape.length);let[c,d]=Qx.computeOutAndReduceShapes(p.shape,l),h=Sa.sizeFromShape(d),f=Sa.makeZerosTypedArray(Sa.sizeFromShape(c),p.dtype),m=n.data.get(p.dataId).values;for(let y=0;y<f.length;++y){let e=y*h,t=m[e];for(let n=0;n<h;++n){let r=m[e+n];(Number.isNaN(r)||r<t)&&(t=r)}f[y]=t}null!=u&&n.disposeIntermediateTensorInfo(p);let g=n.makeTensorInfo(c,p.dtype,f);if(i){let e=Qx.expandShapeToKeepDim(c,o),t=gz({inputs:{x:g},backend:n,attrs:{shape:e}});return n.disposeIntermediateTensorInfo(g),t}return g}var _U={kernelName:Ln,backendName:"cpu",kernelFunc:TU};function CU(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,mode:i}=r;IO(a,"mirrorPad");let o=s.map(((e,t)=>e[0]+a.shape[t]+e[1])),l=s.map((e=>e[0])),u=s.map(((e,t)=>e[0]+a.shape[t])),p="reflect"===i?0:1,c=n.data.get(a.dataId).values,d=a.shape.length,h=Sa.computeStrides(a.shape),f=Sa.sizeFromShape(o),m=o.length,g=Sa.computeStrides(o),y=Sa.getTypedArrayFromDType(a.dtype,f);for(let b=0;b<f;b++){let e=Sa.indexToLoc(b,m,g);for(let n=0;n<m;n++)e[n]<l[n]?e[n]=2*l[n]-e[n]-p:e[n]>=u[n]&&(e[n]=2*(u[n]-1)-e[n]+p);e=e.map(((e,t)=>e-l[t]));let t=Sa.locToIndex(e,d,h);y[b]=c[t]}return{dataId:n.write(y,o,a.dtype),shape:o,dtype:a.dtype}}var EU={kernelName:Bn,backendName:"cpu",kernelFunc:CU},AU=AO(((e,t)=>{let n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})),$U=WO(Wn,AU),RU={kernelName:Wn,backendName:"cpu",kernelFunc:$U},FU=b(A());function DU(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:s}=r,i=a.shape.length,o=s;if(-1===o&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);let l=Sa.parseAxisParam([o],a.shape),u=dU({inputs:{x:a},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),p=Qx.expandShapeToKeepDim(u.shape,l),c=gz({inputs:{x:u},backend:n,attrs:{shape:p}}),d=JL({inputs:{a:a,b:c},backend:n}),h=iP({inputs:{x:d},backend:n}),f=aW({inputs:{x:h},backend:n,attrs:{axis:l,keepDims:!1}}),m=gz({inputs:{x:f},backend:n,attrs:{shape:p}}),g=wW({inputs:{a:h,b:m},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}var MU={kernelName:Dr,backendName:"cpu",kernelFunc:DU};function OU(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=r;IO(a,"multinomial");let l=o?a:DU({inputs:{logits:a},backend:n,attrs:{dim:-1}}),u=l.shape[0],p=l.shape[1],c=n.data.get(l.dataId).values,d=[u,s],h=Sa.makeZerosTypedArray(Sa.sizeFromShape(d),"int32");for(let f=0;f<u;++f){let e=f*p,t=new Float32Array(p-1);t[0]=c[e];for(let a=1;a<t.length;++a)t[a]=t[a-1]+c[e+a];let n=FU.alea(i.toString()),r=f*s;for(let a=0;a<s;++a){let e=n();h[r+a]=t.length;for(let n=0;n<t.length;n++)if(e<t[n]){h[r+a]=n;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(d,"int32",h)}var PU={kernelName:Un,backendName:"cpu",kernelFunc:OU},LU=sw.nonMaxSuppressionV3Impl;function zU(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r;IO(a,"NonMaxSuppression");let u=n.data.get(a.dataId).values,p=n.data.get(s.dataId).values,{selectedIndices:c}=LU(u,p,i,o,l);return n.makeTensorInfo([c.length],"int32",new Int32Array(c))}var BU={kernelName:jn,backendName:"cpu",kernelFunc:zU},WU=sw.nonMaxSuppressionV4Impl;function UU(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r;IO(a,"NonMaxSuppressionPadded");let p=n.data.get(a.dataId).values,c=n.data.get(s.dataId).values,{selectedIndices:d,validOutputs:h}=WU(p,c,i,o,l,u);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([h]))]}var VU={kernelName:qn,backendName:"cpu",kernelFunc:UU},GU=sw.nonMaxSuppressionV5Impl;function HU(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r;IO(a,"NonMaxSuppressionWithScore");let p=n.data.get(a.dataId).values,c=n.data.get(s.dataId).values,d=i,h=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=GU(p,c,d,h,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}var jU={kernelName:Kn,backendName:"cpu",kernelFunc:HU};function qU(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:i,onValue:o,offValue:l}=r;IO(a,"oneHot");let u=Sa.sizeFromShape(a.shape),p=new Float32Array(u*i);p.fill(l);let c=n.data.get(a.dataId).values;for(let d=0;d<u;++d)c[d]>=0&&c[d]<i&&(p[d*i+c[d]]=o);return n.makeTensorInfo([...a.shape,i],s,p)}var KU={kernelName:Jn,backendName:"cpu",kernelFunc:qU};function XU(e){let{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){let e=OO({inputs:{input:r},backend:n}),t=XU({inputs:{x:e},backend:n}),a=yB({inputs:{input:r},backend:n}),s=XU({inputs:{x:a},backend:n}),i=$O({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),i}return AW({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}var JU={kernelName:aa,backendName:"cpu",kernelFunc:XU};function YU(e){let{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){let e=OO({inputs:{input:r},backend:n}),t=YU({inputs:{x:e},backend:n}),a=yB({inputs:{input:r},backend:n}),s=XU({inputs:{x:a},backend:n}),i=$O({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),i}return AW({backend:n,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}var ZU={kernelName:Xn,backendName:"cpu",kernelFunc:YU};function QU(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return bW({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let s=t[0].shape,i=t[0].dtype;t.forEach((e=>{Sa.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),Sa.assert(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));let o=[],l=t.map((e=>{let t=bW({inputs:{input:e},backend:n,attrs:{dim:a}});return o.push(t),t})),u=xB({inputs:l,backend:n,attrs:{axis:a}});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}var eV={kernelName:Yn,backendName:"cpu",kernelFunc:QU};function tV(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,constantValue:i}=r;IO(a,"pad");let o=s.map(((e,t)=>e[0]+a.shape[t]+e[1])),l=s.map((e=>e[0])),u=n.data.get(a.dataId).values,p=Sa.sizeFromShape(a.shape),c=a.shape.length,d=Sa.computeStrides(a.shape),h=Sa.sizeFromShape(o),f=o.length,m=Sa.computeStrides(o),g=Sa.getTypedArrayFromDType(a.dtype,h);0!==i&&g.fill(i);for(let y=0;y<p;y++){let e=Sa.indexToLoc(y,c,d).map(((e,t)=>e+l[t])),t=Sa.locToIndex(e,f,m);g[t]=u[y]}return{dataId:n.write(g,o,a.dtype),shape:o,dtype:a.dtype}}var nV={kernelName:Zn,backendName:"cpu",kernelFunc:tV},rV=AO(((e,t)=>Math.pow(e,t))),aV=WO(er,rV),sV={kernelName:er,backendName:"cpu",kernelFunc:aV};function iV(e){let{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:a,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=r,l=a.map((e=>n.data.get(e.dataId).values)),u=a.map((e=>e.shape)),p=n.data.get(s.dataId).values,c=n.data.get(i.dataId).values,[d,h,f]=cL(l,u,p,s.shape,s.dtype,c,i.shape,o),m=d.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,s.dtype,h);return m.concat([g])}var oV={kernelName:rr,backendName:"cpu",kernelFunc:iV};function lV(e){let{inputs:t,backend:n}=e,{starts:r,limits:a,deltas:s}=t,i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[u,p]=hL(i,r.shape,r.dtype,o,a.shape,l,s.shape),c=n.makeTensorInfo([u.length],"int32",u),d=n.makeTensorInfo([p.length],r.dtype,p);return[c,d]}var uV={kernelName:ar,backendName:"cpu",kernelFunc:lV};function pV(e){let{inputs:t,backend:n,attrs:r}=e,{shape:a,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.data.get(a.dataId).values,p=n.data.get(s.dataId).values,c=n.data.get(i.dataId).values,d=o.map((e=>n.data.get(e.dataId).values)),h=o.map((e=>e.shape)),[f,m]=bL(u,a.shape,p,s.shape,s.dtype,c,i.shape,d,h,l);return n.makeTensorInfo(f,s.dtype,m)}var cV={kernelName:sr,backendName:"cpu",kernelFunc:pV};function dV(e){let{backend:t,attrs:n}=e,{start:r,stop:a,dtype:s,step:i}=n,o=xL(r,a,i,s);return t.makeTensorInfo([o.length],s,o)}var hV={kernelName:ir,backendName:"cpu",kernelFunc:dV},fV=JO(lr,(e=>1/e)),mV={kernelName:lr,backendName:"cpu",kernelFunc:fV};function gV(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r;IO(a,"resizeBilinear");let l=Sa.computeStrides(a.shape),[u,p]=o,[c,d,h,f]=a.shape,m=n.data.get(a.dataId).values,g=new Float32Array(Sa.sizeFromShape([c,u,p,f])),y=[s&&u>1?d-1:d,s&&p>1?h-1:h],b=[s&&u>1?u-1:u,s&&p>1?p-1:p],x=0,v=y[0]/b[0],w=y[1]/b[1];for(let k=0;k<c;k++)for(let e=0;e<u;e++){let t;t=i?v*(e+.5)-.5:v*e;let n=Math.max(0,Math.floor(t)),r=t-n,a=Math.min(d-1,Math.ceil(t)),s=k*l[0]+n*l[1],o=k*l[0]+a*l[1];for(let e=0;e<p;e++){let t;t=i?w*(e+.5)-.5:w*e;let n=Math.max(0,Math.floor(t)),a=t-n,u=Math.min(h-1,Math.ceil(t)),p=s+n*l[2],c=o+n*l[2],d=s+u*l[2],y=o+u*l[2];for(let e=0;e<f;e++){let t=m[p+e],n=m[c+e],s=m[d+e],i=m[y+e],o=t+(s-t)*a,l=n+(i-n)*a,u=o+(l-o)*r;g[x++]=u}}}return n.makeTensorInfo([c,u,p,f],"float32",g)}var yV={kernelName:hr,backendName:"cpu",kernelFunc:gV};function bV(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r;IO([s,a],"resizeBilinearGrad");let o=Sa.computeStrides(a.shape),[l,u,p,c]=a.shape,[,d,h]=s.shape,f=new Float32Array(l*u*p*c),m=[i&&d>1?u-1:u,i&&h>1?p-1:p],g=[i&&d>1?d-1:d,i&&h>1?h-1:h],y=m[0]/g[0],b=m[1]/g[1],x=n.data.get(s.dataId).values,v=0;for(let w=0;w<l;w++){let e=w*o[0];for(let t=0;t<d;t++){let n=t*y,r=Math.floor(n),a=Math.min(Math.ceil(n),u-1),s=e+r*o[1],i=e+a*o[1],l=n-r,d=1-l;for(let e=0;e<h;e++){let t=e*b,n=Math.floor(t),r=Math.min(Math.ceil(t),p-1),a=t-n,u=1-a,h=s+n*o[2],m=s+r*o[2],g=i+n*o[2],y=i+r*o[2],w=d*u,k=d*a,I=l*u,S=l*a;for(let e=0;e<c;e++){let t=x[v++];f[h+e]+=t*w,f[m+e]+=t*k,f[g+e]+=t*I,f[y+e]+=t*S}}}}return n.makeTensorInfo([l,p,u,c],"float32",f)}var xV={kernelName:fr,backendName:"cpu",kernelFunc:bV};function vV(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r;IO(a,"resizeNearestNeighbor");let l=Sa.computeStrides(a.shape),[u,p]=o,[c,d,h,f]=a.shape,m=n.data.get(a.dataId).values,g=new Float32Array(c*u*p*f),y=[s&&u>1?d-1:d,s&&p>1?h-1:h],b=[s&&u>1?u-1:u,s&&p>1?p-1:p],x=y[0]/b[0],v=y[1]/b[1],w=0;for(let k=0;k<c;k++){let e=k*l[0];for(let t=0;t<u;t++){let n=i?x*(t+.5):x*t,r=Math.min(d-1,s?Math.round(n):Math.floor(n));i&&(r=Math.max(0,r));let a=e+r*l[1];for(let e=0;e<p;e++){let t=i?v*(e+.5):v*e,n=Math.min(h-1,s?Math.round(t):Math.floor(t));i&&(n=Math.max(0,n));let r=a+n*l[2];for(let e=0;e<f;e++){let t=m[r+e];g[w++]=t}}}}return n.makeTensorInfo([c,u,p,f],a.dtype,g)}var wV={kernelName:cr,backendName:"cpu",kernelFunc:vV};function kV(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r;IO([s,a],"resizeNearestNeighborGrad");let o=Sa.computeStrides(a.shape),l=Sa.computeStrides(s.shape),[u,p,c,d]=a.shape,[,h,f]=s.shape,m=new Float32Array(u*p*c*d),g=n.data.get(s.dataId).values,y=[i&&h>1?p-1:p,i&&f>1?c-1:c],b=[i&&h>1?h-1:h,i&&f>1?f-1:f],x=y[0]/b[0],v=y[1]/b[1],w=1/x,k=1/v,I=2*Math.ceil(w)+2,S=2*Math.ceil(k)+2;for(let N=0;N<u;N++){let e=N*o[0];for(let t=0;t<p;t++){let n=e+t*o[1],r=Math.floor(t*w),a=Math.floor(r-I/2);for(let s=0;s<c;s++){let r=n+s*o[2],u=Math.floor(s*k),y=Math.floor(u-S/2);for(let n=0;n<d;n++){let o=0;for(let r=0;r<I;r++){let u=r+a;if(u<0||u>=h)continue;let d=e+u*l[1],m=u*x,b=Math.min(p-1,i?Math.round(m):Math.floor(m));if(t===b)for(let e=0;e<S;e++){let t=e+y;if(t<0||t>=f)continue;let r=d+t*l[2],a=t*v,u=Math.min(c-1,i?Math.round(a):Math.floor(a));s===u&&(o+=g[r+n])}}m[r+n]=o}}}}return n.makeTensorInfo(a.shape,a.dtype,m)}var IV={kernelName:dr,backendName:"cpu",kernelFunc:kV};function SV(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r;IO(a,"reverse");let i=a.shape.length,o=Sa.parseAxisParam(s,a.shape);if(0===i)return DO({inputs:{x:a},backend:n});let l=new ds(a.shape,a.dtype),u=n.bufferSync(a);for(let p=0;p<l.size;p++){let e=l.indexToLoc(p),t=e.slice();o.forEach((e=>t[e]=a.shape[e]-1-t[e])),l.set(u.get(...t),...e)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}var NV={kernelName:gr,backendName:"cpu",kernelFunc:SV},TV={kernelName:oa,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,{radians:a,fillValue:s,center:i}=t,o=n,l=Sa.getTypedArrayFromDType(r.dtype,Sa.sizeFromShape(r.shape)),[u,p,c,d]=r.shape,[h,f]=Qx.getImageCenter(i,p,c),m=255,g=Math.sin(a),y=Math.cos(a),b=o.data.get(r.dataId).values;for(let x=0;x<u;x++){let e=x*c*p*d;for(let t=0;t<p;t++){let n=t*(c*d);for(let r=0;r<c;r++){let a=r*d;for(let i=0;i<d;i++){let o=[u,t,r,i],x=o[2],v=o[1],w=(x-h)*y-(v-f)*g,k=(x-h)*g+(v-f)*y;w=Math.round(w+h),k=Math.round(k+f);let I=s;if("number"!=typeof s&&(I=3===i?m:s[i]),w>=0&&w<c&&k>=0&&k<p){let t=k*(c*d),n=w*d,r=e+t+n+i;I=b[r]}let S=e+n+a+i;l[S]=I}}}}return{dataId:o.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},_V=JO(yr,(e=>{let t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1})),CV={kernelName:yr,backendName:"cpu",kernelFunc:_V};function EV(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:s}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:p,outputSize:c}=Qx.calculateShapes(s,a,i),d=!0,h=n.bufferSync(a),f=n.bufferSync(s),m=IL(h,f,i,c,u,l,o,p,0,d);return n.makeTensorInfo(i,m.dtype,m.values)}var AV={kernelName:xr,backendName:"cpu",kernelFunc:EV};function $V(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<t?n=a+1:r=a;return r}function RV(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<=t?n=a+1:r=a;return r}function FV(e,t,n,r,a,s){let i=Sa.getArrayFromDType("int32",n*a);for(let o=0;o<n;++o){let n=e.slice(o*r,(o+1)*r),l=o*a;for(let e=0;e<a;++e)i[l+e]="left"===s?$V(n,t[e+l]):RV(n,t[e+l])}return i}function DV(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:i}=r,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,u=FV(o,l,a.shape[0],a.shape[1],s.shape[1],i);return n.makeTensorInfo(s.shape,"int32",u)}var MV={kernelName:wr,backendName:"cpu",kernelFunc:DV};function OV(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t;IO([r,a,s],"select");let i=r.shape.length,o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,u=n.data.get(s.dataId).values,p=Cs(a.dtype,s.dtype),c=Sa.makeZerosTypedArray(Sa.sizeFromShape(a.shape),p),d=0,h=0===i||i>1||1===a.shape.length?1:Sa.sizeFromShape(a.shape.slice(1));for(let f=0;f<o.length;f++)for(let e=0;e<h;e++)1===o[f]?c[d++]=l[f]:c[d++]=u[f];return n.makeTensorInfo(a.shape,p,c)}var PV={kernelName:kr,backendName:"cpu",kernelFunc:OV},LV=Qx.SELU_SCALEALPHA,zV=Qx.SELU_SCALE,BV=JO(Ir,(e=>e>=0?zV*e:LV*(Math.exp(e)-1))),WV={kernelName:Ir,backendName:"cpu",kernelFunc:BV},UV=JO(_r,(e=>e<0?-1:e>0?1:0)),VV={kernelName:_r,backendName:"cpu",kernelFunc:UV},GV=JO(Nr,(e=>Math.sin(e))),HV={kernelName:Nr,backendName:"cpu",kernelFunc:GV},jV=JO(Tr,(e=>Math.sinh(e))),qV={kernelName:Tr,backendName:"cpu",kernelFunc:jV},KV=1.1920928955078125e-7,XV=Math.log(KV)+2,JV=JO(Er,(e=>{let t,n=e>-XV,r=e<XV,a=Math.exp(e);return t=r?a:n?e:Math.log(1+a),t})),YV={kernelName:Er,backendName:"cpu",kernelFunc:JV};function ZV(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r;IO([a],"spaceToBatchND");let o=Sa.sizeFromShape(s),l=[[0,0]];l.push(...i);for(let g=1+s.length;g<a.shape.length;++g)l.push([0,0]);let u=nV.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),p=Qx.getReshaped(u.shape,s,o,!1),c=Qx.getPermuted(p.length,s.length,!1),d=Qx.getReshapedPermuted(u.shape,s,o,!1),h=gz({inputs:{x:u},backend:n,attrs:{shape:p}}),f=QP({inputs:{x:h},backend:n,attrs:{perm:c}}),m=gz({inputs:{x:f},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),m}var QV={kernelName:Rr,backendName:"cpu",kernelFunc:ZV};function eG(e){let{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:s,defaultValue:i}=t;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${s.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Values must be a vector, saw:\n        ${a.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);let o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,u=n.data.get(s.dataId).values,p=n.data.get(i.dataId).values[0],[c,d,h,f,m]=AL(o,r.shape,r.dtype,l,a.dtype,u,p);return[n.makeTensorInfo(d,r.dtype,c),n.makeTensorInfo([d[0]],a.dtype,h),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}var tG={kernelName:Mr,backendName:"cpu",kernelFunc:eG};function nG(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:s}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${a.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(n.data.get(a.dataId).values),o=n.data.get(r.dataId).values,l=Array.from(n.data.get(s.dataId).values),[u,p,c]=$L(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(p,r.dtype,u),n.makeTensorInfo([c.length],s.dtype,new Int32Array(c))]}var rG={kernelName:Or,backendName:"cpu",kernelFunc:nG};function aG(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${s.shape}`);if(a.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[u,p]=RL(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(p,r.dtype,u)}var sG={kernelName:Pr,backendName:"cpu",kernelFunc:aG};function iG(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${s.shape}`);if(a.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[u,p]=RL(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(p,r.dtype,u)}var oG={kernelName:Lr,backendName:"cpu",kernelFunc:iG};function lG(e){let t,{inputs:n,backend:r,attrs:a}=e,{sparseIndices:s,sparseValues:i,defaultValue:o}=n,{outputShape:l}=a,{sliceRank:u,numUpdates:p,sliceSize:c,strides:d,outputSize:h}=Qx.calculateShapes(i,s,l),f=!1,m=r.bufferSync(s);switch(i.dtype){case"bool":{let e=r.bufferSync(i),n=!!r.data.get(o.dataId).values[0];t=IL(m,e,l,h,c,p,u,d,n,f);break}case"float32":{let e=r.bufferSync(i),n=r.data.get(o.dataId).values[0];t=IL(m,e,l,h,c,p,u,d,n,f);break}case"int32":{let e=r.bufferSync(i),n=r.data.get(o.dataId).values[0];t=IL(m,e,l,h,c,p,u,d,n,f);break}case"string":{let e=r.bufferSync(i),n=Sa.decodeString(r.data.get(o.dataId).values[0]);t=IL(m,e,l,h,c,p,u,d,n,f);break}default:throw new Error(`Unsupported type ${i.dtype}`)}return r.makeTensorInfo(l,t.dtype,t.values)}var uG={kernelName:zr,backendName:"cpu",kernelFunc:lG};function pG(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=r,o=Sa.parseAxisParam(i,a.shape)[0],l=Qx.prepareSplitSize(a,s,o),u=new Array(a.shape.length).fill(0),p=a.shape.slice();return l.map((e=>{let t=[...p];t[o]=e;let r=CL({inputs:{x:a},backend:n,attrs:{begin:u,size:t}});return u[o]+=e,r}))}var cG={kernelName:Fr,backendName:"cpu",kernelFunc:pG},dG={kernelName:Wr,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{let{x:n}=e,r=t;IO(n,"square");let a=r.data.get(n.dataId).values,s=new Float32Array(a.length);for(let i=0;i<a.length;++i){let e=a[i];s[i]=e*e}return{dataId:r.write(s,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},hG=JO(sa,((e,t)=>{let n=t;return isNaN(e)?NaN:e>0?1:n.alpha})),fG={kernelName:sa,backendName:"cpu",kernelFunc:hG};function mG(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:p,newAxisMask:c,shrinkAxisMask:d}=r;IO(a,"stridedSlice");let h,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:y,isSimpleSlice:b,begin:x,end:v,strides:w}=Tx.sliceInfo(a.shape,s,i,o,l,u,p,c,d);if(g)h=gz({inputs:{x:a},backend:n,attrs:{shape:m}});else if(y||b){Sa.assert(a.shape.length>=1,(()=>`Input must have rank at least 1, got: ${a.shape.length}`));let e=Tx.computeOutShape(x,v,w),t=CL({inputs:{x:a},backend:n,attrs:{begin:x,size:e}});h=gz({inputs:{x:t},backend:n,attrs:{shape:m}}),n.disposeIntermediateTensorInfo(t)}else{let e=n.bufferSync(a),t=UL(f,e,w,x);h=n.makeTensorInfo(m,t.dtype,t.values)}return h}var gG={kernelName:Vr,backendName:"cpu",kernelFunc:mG};function yG(e){let{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:p,dataSplits:c}=t,d=n.data.get(p.dataId).values,h=n.data.get(c.dataId).values,[f,m]=GL(d,h,a,s,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(c.shape,"int32",m)]}var bG={kernelName:Gr,backendName:"cpu",kernelFunc:yG};function xG(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:s,delimiter:i}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values[0],[u,p,c]=jL(o,l,a),d=p.length;return[n.makeTensorInfo([d,2],"int32",u),n.makeTensorInfo([d],"string",p),n.makeTensorInfo([2],"int32",new Int32Array(c))]}var vG={kernelName:Hr,backendName:"cpu",kernelFunc:xG};function wG(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");let i=n.data.get(s.dataId).values,o=qL(i,a);return n.makeTensorInfo(s.shape,"int32",o)}var kG={kernelName:jr,backendName:"cpu",kernelFunc:wG},IG=JO(Kr,(e=>Math.tan(e))),SG={kernelName:Kr,backendName:"cpu",kernelFunc:IG},NG=JO(Xr,(e=>Math.tanh(e))),TG={kernelName:Xr,backendName:"cpu",kernelFunc:NG};function _G(e){let{inputs:t,backend:n}=e,{tensor:r,indices:a,updates:s}=t,{sliceRank:i,numUpdates:o,sliceSize:l,strides:u,outputSize:p}=Qx.calculateShapes(s,a,r.shape),c=!1,d=n.bufferSync(a),h=n.bufferSync(s),f=n.bufferSync(r),m=IL(d,h,r.shape,p,l,o,i,u,f,c);return n.makeTensorInfo(r.shape,m.dtype,m.values)}var CG={kernelName:vr,backendName:"cpu",kernelFunc:_G};function EG(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:s}=r;IO(a,"tile");let i=ZL(n.bufferSync(a),s);return n.makeTensorInfo(i.shape,i.dtype,i.values)}var AG={kernelName:Jr,backendName:"cpu",kernelFunc:EG};function $G(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:i}=r;IO(a,"topk");let o=n.data.get(a.dataId).values,[l,u]=tz(o,a.shape,a.dtype,s,i);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}var RG={kernelName:Yr,backendName:"cpu",kernelFunc:$G};function FG(e){let{inputs:t,attrs:n,backend:r}=e,{image:a,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=n,[p,c,d,h]=a.shape,[f,m]=null!=u?u:[c,d],g=[p,f,m,h],y=Sa.computeStrides(a.shape),b=y[0],x=y[1],v=y[2],w=Sa.computeStrides(g),k=w[0],I=w[1],S=w[2],N=Sa.getTypedArrayFromDType(a.dtype,Sa.sizeFromShape(g));N.fill(l);let T=r.data.get(a.dataId).values,_=r.data.get(s.dataId).values;for(let C=0;C<p;++C){let e=1===s.shape[0]?_:_.subarray(8*C,8*C+8);for(let t=0;t<f;++t)for(let n=0;n<m;++n)for(let r=0;r<h;++r){let a,s=e[6]*n+e[7]*t+1;if(0===s)continue;let u=(e[0]*n+e[1]*t+e[2])/s,p=(e[3]*n+e[4]*t+e[5])/s,h=MG(u,d,o),f=MG(p,c,o);switch(i){case"nearest":a=WG(T,c,d,b,x,v,C,f,h,r,l);break;case"bilinear":a=UG(T,c,d,b,x,v,C,f,h,r,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}let m=C*k+t*I+n*S+r;N[m]=a}return r.makeTensorInfo(g,a.dtype,N)}return{dataId:r.write(N,g,a.dtype),shape:a.shape,dtype:a.dtype}}var DG={kernelName:Zr,backendName:"cpu",kernelFunc:FG};function MG(e,t,n){switch(n){case"reflect":return OG(e,t);case"wrap":return PG(e,t);case"nearest":return zG(e,t);case"constant":default:return LG(e,t)}}function OG(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{let e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return Sa.clamp(0,n,t-1)}function PG(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{let e=t-1;n-=t*Math.trunc(n/e)}return Sa.clamp(0,n,t-1)}function LG(e,t){return e}function zG(e,t){return Sa.clamp(0,e,t-1)}function BG(e,t,n,r,a,s,i,o,l,u,p){let c=i*r+o*a+l*s+u;return 0<=o&&o<t&&0<=l&&l<n?e[c]:p}function WG(e,t,n,r,a,s,i,o,l,u,p){let c=Math.round(o),d=Math.round(l);return BG(e,t,n,r,a,s,i,c,d,u,p)}function UG(e,t,n,r,a,s,i,o,l,u,p){let c=Math.floor(o),d=Math.floor(l),h=c+1,f=d+1,m=(f-l)*BG(e,t,n,r,a,s,i,c,d,u,p)+(l-d)*BG(e,t,n,r,a,s,i,c,f,u,p),g=(f-l)*BG(e,t,n,r,a,s,i,h,d,u,p)+(l-d)*BG(e,t,n,r,a,s,i,h,f,u,p);return(h-o)*m+(o-c)*g}function VG(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t;IO(s,"unique");let i=r.data.get(s.dataId).values,{outputValues:o,outputShape:l,indices:u}=nz(i,a,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}var GG={kernelName:ea,backendName:"cpu",kernelFunc:VG};function HG(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:s}=r;s<0&&(s+=a.shape.length);let i=a.shape.length,o=a.shape[s],l=new Array(i-1),u=0;for(let h=0;h<i;h++)h!==s&&(l[u++]=a.shape[h]);let p=new Array(i).fill(0),c=a.shape.slice();c[s]=1;let d=new Array(o);for(let h=0;h<d.length;h++){p[s]=h;let e=CL({inputs:{x:a},backend:n,attrs:{begin:p,size:c}});d[h]=gz({inputs:{x:e},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(e)}return d}var jG={kernelName:ta,backendName:"cpu",kernelFunc:HG};function qG(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:s}=t,{numSegments:i}=r;IO(a,"unsortedSegmentSum");let o=a.shape.length,l=s.shape.length,u=[],p=[],c=o-l,d=s;for(let f=0;f<c;++f){let e=bW({inputs:{input:d},backend:n,attrs:{dim:f+1}});d=e,p.push(e)}for(let f=0;f<i;++f){let e=Sa.createScalarValue(f,"int32"),t=n.makeTensorInfo([],"int32",e),r=rP({inputs:{a:t,b:d},backend:n}),s=zO({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),i=GP({inputs:{a:s,b:a},backend:n}),o=aW({inputs:{x:i},backend:n,attrs:{axis:0,keepDims:!1}});u.push(o),p.push(t),p.push(r),p.push(s),p.push(i),p.push(o)}let h=QU({inputs:u,backend:n,attrs:{axis:0}});return p.forEach((e=>n.disposeIntermediateTensorInfo(e))),h}var KG={kernelName:na,backendName:"cpu",kernelFunc:qG},XG=[wz,EO,Iz,Nz,jO,_z,Ez,$z,Fz,Mz,Pz,zz,Wz,Gz,jz,Zz,eB,nB,aB,xz,iB,lB,pB,dB,BO,eP,fB,RO,gB,vB,kB,SB,TB,CB,AB,RB,DB,OB,LB,BB,UB,GB,jB,KB,JB,ZB,eW,tW,nW,rW,oW,sz,uW,aP,yW,oP,xW,pP,EW,$W,FW,hP,gP,MW,PW,zW,WW,wP,SP,MO,VW,bB,HW,qW,XW,oz,_P,AP,YW,DP,QW,nU,aU,oU,uU,cU,hU,LP,mU,yU,xU,wU,IU,NU,_U,WP,EU,RU,PU,HP,KP,BU,VU,jU,YP,KU,ZU,eV,nV,sV,pz,rL,oV,uV,cV,hV,PO,kW,mV,dz,fz,yz,yV,xV,wV,IV,NV,TV,CV,kL,AV,MV,PV,WV,TL,VV,HV,qV,EL,MU,YV,QV,tG,rG,sG,oG,uG,cG,ML,dG,LL,WL,fG,gG,bG,vG,kG,YL,sW,SG,TG,CG,AG,RG,DG,eL,GG,jG,KG,JU];for(let cle of XG)ba(cle);var JG={};g(JG,{assertNotComplex:()=>cj,bindCanvasToFramebuffer:()=>BH,bindColorTextureToFramebuffer:()=>WH,bindTextureToProgramUniformSampler:()=>zH,bindTextureUnit:()=>MH,bindVertexBufferToProgramAttribute:()=>DH,callAndCheck:()=>dH,canBeRepresented:()=>gH,createFragmentShader:()=>vH,createFramebuffer:()=>FH,createProgram:()=>NH,createStaticIndexBuffer:()=>EH,createStaticVertexBuffer:()=>CH,createTexture:()=>$H,createVertexShader:()=>xH,getBatchDim:()=>qH,getExtensionOrThrow:()=>bH,getFramebufferErrorMessage:()=>GH,getMaxTexturesInShader:()=>nj,getNumChannels:()=>AH,getProgramUniformLocation:()=>LH,getProgramUniformLocationOrThrow:()=>PH,getRowsCols:()=>KH,getShapeAs3D:()=>XH,getTextureShapeFromLogicalShape:()=>JH,getWebGLDisjointQueryTimerVersion:()=>rj,getWebGLErrorMessage:()=>yH,getWebGLMaxTextureSize:()=>QH,hasExtension:()=>aj,isCapableOfRenderingToFloatTexture:()=>ij,isDownloadFloatTextureEnabled:()=>oj,isReshapeFree:()=>ZH,isWebGLFenceEnabled:()=>pj,isWebGLVersionEnabled:()=>sj,linkProgram:()=>TH,logShaderSourceAndInfoLog:()=>SH,resetMaxTextureSize:()=>ej,resetMaxTexturesInShader:()=>tj,unbindColorTextureFromFramebuffer:()=>UH,unbindTextureUnit:()=>OH,validateFramebuffer:()=>VH,validateProgram:()=>_H,validateTextureSize:()=>RH});var YG,ZG,QG,eH={},tH={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function nH(e,t){eH[e]=t}function rH(e,t){if(!(e in eH)||null!=t){let n=sH(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;eH[e]=n}let n=eH[e];return null==n||n.isContextLost()?(delete eH[e],rH(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),eH[e])}function aH(e){if(!We().getBool("IS_SAFARI")&&"undefined"!=typeof OffscreenCanvas&&2===e)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function sH(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let n=null==t?aH(e):t;return n.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete eH[e]}),!1),We().getBool("SOFTWARE_WEBGL_ENABLED")&&(tH.failIfMajorPerformanceCaveat=!1),1===e?n.getContext("webgl",tH)||n.getContext("experimental-webgl",tH):n.getContext("webgl2",tH)}function iH(e,t){return[t,e]}function oH(e,t){return e*t}function lH(e){let t=Sa.sizeFromShape(e),n=Math.ceil(t/4);return Sa.sizeToSquarishShape(n)}function uH(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function pH(e,t){let[n,r]=uH(e,t);return n*r*4}function cH(e,t){let n,r,a,s,i,o,l,u,p,c,d=e;return 2===We().getNumber("WEBGL_VERSION")?(n=d.R32F,r=d.R16F,a=d.RGBA16F,s=d.RGBA32F,i=d.RED,l=4,u=1,p=d.HALF_FLOAT,c=d.FLOAT,o=d.RGBA8):(n=e.RGBA,r=e.RGBA,a=e.RGBA,s=d.RGBA,i=e.RGBA,l=4,u=4,p=null!=t?t.HALF_FLOAT_OES:null,c=e.FLOAT,o=e.RGBA),{internalFormatFloat:n,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:s,textureFormatFloat:i,downloadTextureFormat:o,downloadUnpackNumChannels:l,defaultNumChannels:u,textureTypeHalfFloat:p,textureTypeFloat:c}}function dH(e,t){let n=t();return We().getBool("DEBUG")&&hH(e),n}function hH(e){let t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+yH(e,t))}(function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"})(YG||(YG={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(ZG||(ZG={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(QG||(QG={}));var fH=5.96e-8,mH=65504;function gH(e){return!!(We().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||fH<Math.abs(e)&&Math.abs(e)<mH)}function yH(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function bH(e,t){return HH(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}function xH(e,t){let n=HH(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(dH(e,(()=>e.shaderSource(n,t))),dH(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function vH(e,t){let n=HH(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(dH(e,(()=>e.shaderSource(n,t))),dH(e,(()=>e.compileShader(n))),We().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw SH(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}var wH,kH,IH=/ERROR: [0-9]+:([0-9]+):/g;function SH(e,t){let n=IH.exec(t);if(null==n)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(e);let r=+n[1],a=e.split("\n"),s=a.length.toString().length+2,i=a.map(((e,t)=>Sa.rightPad((t+1).toString(),s)+e)),o=0;for(let c=0;c<i.length;c++)o=Math.max(i[c].length,o);let l=i.slice(0,r-1),u=i.slice(r-1,r),p=i.slice(r);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${Sa.rightPad(u[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(p.join("\n"))}function NH(e){return HH(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}function TH(e,t){if(dH(e,(()=>e.linkProgram(t))),!We().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function _H(e,t){if(dH(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function CH(e,t){let n=HH(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return dH(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),dH(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}function EH(e,t){let n=HH(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return dH(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),dH(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}function AH(){return 2===We().getNumber("WEBGL_VERSION")?1:4}function $H(e){return HH(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}function RH(e,t){let n=We().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){let n=`[${e}x${t}]`;throw new Error("Requested texture size "+n+" is invalid.")}if(e>n||t>n){let r=`[${e}x${t}]`,a=`[${n}x${n}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+a+".")}}function FH(e){return HH(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}function DH(e,t,n,r,a,s,i){let o=e.getAttribLocation(t,n);return-1!==o&&(dH(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,r))),dH(e,(()=>e.vertexAttribPointer(o,a,e.FLOAT,!1,s,i))),dH(e,(()=>e.enableVertexAttribArray(o))),!0)}function MH(e,t,n){jH(e,n),dH(e,(()=>e.activeTexture(e.TEXTURE0+n))),dH(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}function OH(e,t){jH(e,t),dH(e,(()=>e.activeTexture(e.TEXTURE0+t))),dH(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function PH(e,t,n){return HH(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}function LH(e,t,n){return e.getUniformLocation(t,n)}function zH(e,t,n,r){dH(e,(()=>MH(e,t,r))),dH(e,(()=>e.uniform1i(n,r)))}function BH(e){dH(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),dH(e,(()=>e.viewport(0,0,e.canvas.width,e.canvas.height))),dH(e,(()=>e.scissor(0,0,e.canvas.width,e.canvas.height)))}function WH(e,t,n){dH(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),dH(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function UH(e,t){dH(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),dH(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function VH(e){let t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+GH(e,t))}function GH(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function HH(e,t,n){let r=dH(e,(()=>t()));if(null==r)throw new Error(n);return r}function jH(e,t){let n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){let e=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${e}.`)}}function qH(e,t=2){return Sa.sizeFromShape(e.slice(0,e.length-t))}function KH(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function XH(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[qH(e),...KH(e)]),t}function JH(e,t=!1){let n=We().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=We().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&We().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),t&&(n*=2,r*=2,e=e.map(((t,n)=>n>=e.length-2?Sa.nearestLargerEven(e[n]):e[n])),1===e.length&&(e=[2,e[0]])),2!==e.length&&(e=Sa.squeezeShape(e).newShape);let a=Sa.sizeFromShape(e),s=null;e.length<=1&&a<=n?s=[1,a]:2===e.length&&e[0]<=n&&e[1]<=n?s=e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?s=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?s=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?s=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(s=[e[0],e[1]*e[2]*e[3]]);let i=null!=s&&Math.max(...s)>r&&Math.min(...s)<=(t?2:1)&&Math.min(...s)>0;if(null==s||i)if(t){let t=qH(e),n=2,r=2;e.length&&([n,r]=KH(e)),a=t*(n/2)*(r/2),s=Sa.sizeToSquarishShape(a).map((e=>2*e))}else s=Sa.sizeToSquarishShape(a);return s}function YH(e){return e%2===0}function ZH(e,t){if(e=e.slice(-2),t=t.slice(-2),Sa.arraysEqual(e,t)||!e.length||!t.length||0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){let n=e[e.length-1],r=t[t.length-1];if(n===r||YH(n)&&YH(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&YH(e[0])&&YH(t[0])}function QH(e){if(null==wH){let t=rH(e);wH=t.getParameter(t.MAX_TEXTURE_SIZE)}return wH}function ej(){wH=null}function tj(){kH=null}function nj(e){if(null==kH){let t=rH(e);kH=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,kH)}function rj(e){if(0===e)return 0;let t,n=rH(e);return t=aj(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:aj(n,"EXT_disjoint_timer_query")?1:0,t}function aj(e,t){return null!=e.getExtension(t)}function sj(e){try{if(null!=rH(e))return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function ij(e){if(0===e)return!1;let t=rH(e);if(1===e){if(!aj(t,"OES_texture_float"))return!1}else if(!aj(t,"EXT_color_buffer_float"))return!1;return lj(t)}function oj(e){if(0===e)return!1;let t=rH(e);if(1!==e){if(aj(t,"EXT_color_buffer_float"))return lj(t);let e="EXT_color_buffer_half_float";if(aj(t,e)){let n=t.getExtension(e);return uj(t,n)}return!1}return!(!aj(t,"OES_texture_float")||!aj(t,"WEBGL_color_buffer_float"))&&lj(t)}function lj(e){let t=cH(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);let r=1,a=1;e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,r,a,0,t.textureFormatFloat,t.textureTypeFloat,null);let s=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,s),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);let i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(s),i}function uj(e,t){let n=cH(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);let a=1,s=1;e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,a,s,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);let i=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);let o=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(i),o}function pj(e){return 2===e&&null!=rH(e).fenceSync}function cj(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&Sa.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the WebGL backend.`))}))}var dj=We();function hj(){let e,t,n,r,a,s,i,o,l,u;return 2===We().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",r="in",a="texture",s="outputColor",i="out vec4 outputColor;",o=We().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",l="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",r="varying",a="texture2D",s="gl_FragColor",i="",o="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:a,output:s,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:l,defineRound:u}}function fj(e,t,n="index"){let r=Sa.computeStrides(t);return r.map(((t,a)=>{let s=`int ${e[a]} = ${n} / ${t}`,i=a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * ${t}`:`index -= ${e[a]} * ${t}`;return`${s}; ${i};`})).join("")}function mj(e,t,n="index"){let r=Sa.computeStrides(t);return r.map(((t,a)=>{let s=`int ${e[a]} = ${n} / outShapeStrides[${a}]`,i=a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * outShapeStrides[${a}]`:`index -= ${e[a]} * outShapeStrides[${a}]`;return`${s}; ${i};`})).join("")}function gj(e,t){let n=e.length,r=e.map((e=>`${t}[${e}]`)),a=new Array(n-1);a[n-2]=r[n-1];for(let s=n-3;s>=0;--s)a[s]=`(${a[s+1]} * ${r[s+1]})`;return a}function yj(e,t,n="index"){let r=e.map(((e,t)=>t)),a=gj(r,t);return a.map(((t,r)=>{let s=`int ${e[r]} = ${n} / ${a[r]}`,i=r===a.length-1?`int ${e[r+1]} = ${n} - ${e[r]} * ${a[r]}`:`index -= ${e[r]} * ${a[r]}`;return`${s}; ${i};`})).join("")}function bj(e){let t=Sa.computeStrides(e).map((e=>e.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}function xj(){return"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n"}dj.registerFlag("HAS_WEBGL",(()=>dj.getNumber("WEBGL_VERSION")>0)),dj.registerFlag("WEBGL_VERSION",(()=>sj(2)?2:sj(1)?1:0)),dj.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),dj.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===dj.get("WEBGL_VERSION"))),dj.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),dj.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),dj.registerFlag("WEBGL_PACK",(()=>dj.getBool("HAS_WEBGL"))),dj.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>dj.getBool("WEBGL_PACK"))),dj.registerFlag("WEBGL_PACK_CLIP",(()=>dj.getBool("WEBGL_PACK"))),dj.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>dj.getBool("WEBGL_PACK"))),dj.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>dj.getBool("WEBGL_PACK"))),dj.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>dj.getBool("WEBGL_PACK"))),dj.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>dj.getBool("WEBGL_PACK"))),dj.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>dj.getBool("WEBGL_PACK"))),dj.registerFlag("WEBGL_PACK_REDUCE",(()=>dj.getBool("WEBGL_PACK"))),dj.registerFlag("WEBGL_LAZILY_UNPACK",(()=>dj.getBool("WEBGL_PACK"))),dj.registerFlag("WEBGL_CONV_IM2COL",(()=>dj.getBool("WEBGL_PACK"))),dj.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>QH(dj.getNumber("WEBGL_VERSION")))),dj.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>nj(dj.getNumber("WEBGL_VERSION")))),dj.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{let e=dj.getNumber("WEBGL_VERSION");return 0===e?0:rj(e)})),dj.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>dj.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!js.isMobile())),dj.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>ij(dj.getNumber("WEBGL_VERSION")))),dj.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!dj.getBool("WEBGL_FORCE_F16_TEXTURES")&&dj.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),dj.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>oj(dj.getNumber("WEBGL_VERSION")))),dj.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>pj(dj.getNumber("WEBGL_VERSION")))),dj.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>dj.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),dj.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)})),dj.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>js.isMobile()?1:-1),(e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)})),dj.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),dj.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),dj.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),dj.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128)),dj.registerFlag("WEBGL_EXP_CONV",(()=>!1)),dj.registerFlag("SOFTWARE_WEBGL_ENABLED",(()=>dj.getBool("IS_TEST"))),dj.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",(()=>1/0)),dj.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",(()=>!1)),dj.registerFlag("WEBGL2_ISNAN_CUSTOM",(()=>!1)),dj.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1));var vj="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:wj}=Qx;function kj(e,t,n){let r=[];if(e.forEach((e=>{let t=Sa.sizeFromShape(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?r.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(r.push(`uniform sampler2D ${e.name};`),r.push(`uniform int offset${e.name};`)),n.enableShapeUniforms){let{uniformShape:t}=pq(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:r.push(`uniform int ${e.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${e.name}Shape;`);break;default:break}r.push(`uniform ivec2 ${e.name}TexShape;`)}})),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break;default:break}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((e=>{r.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)}));let a,s,i=r.join("\n"),o=e.map((e=>Nj(e,t,n.packedInputs,n.enableShapeUniforms))).join("\n"),l=t.texShape,u=hj(),p=Cj(u),c=$j(u);return t.isPacked?(a=Tj(t.logicalShape,l,n.enableShapeUniforms),s=Aj(u)):(a=_j(t.logicalShape,l,n.enableShapeUniforms),s=Ej(u)),n.packedInputs&&(c+=Mj),[c,p,s,i,a,o,n.userCode].join("\n")}function Ij(e,t=!1){let n=e.shapeInfo.logicalShape;switch(n.length){case 0:return Xj(e,t);case 1:return Yj(e,t);case 2:return Qj(e,t);case 3:return tq(e,t);case 4:return rq(e,t);case 5:return aq(e);case 6:return sq(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function Sj(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return Kj(e);case 1:return Jj(e,t);case 2:return Zj(e,t);case 3:return eq(e,t);default:return nq(e,t)}}function Nj(e,t,n=!1,r){let a="";a+=n?Sj(e,r):Ij(e,r);let s=e.shapeInfo.logicalShape,i=t.logicalShape;return s.length<=i.length&&(a+=n?oq(e,t):lq(e,t)),a}function Tj(e,t,n){switch(e.length){case 0:return Oj();case 1:return Pj(e,t,n);case 2:return Hj(e,t,n);case 3:return zj(e,t,n);default:return Wj(e,t,n)}}function _j(e,t,n){switch(e.length){case 0:return Oj();case 1:return Lj(e,t,n);case 2:return jj(e,t,n);case 3:return Bj(e,t,n);case 4:return Uj(e,t,n);case 5:return Vj(e,t);case 6:return Gj(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}function Cj(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}function Ej(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}function Aj(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}function $j(e){return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${Rj}\n    ${Fj}\n    ${Dj}\n  `}var Rj="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Fj="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Dj="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Mj="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function Oj(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function Pj(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===r[0]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `:1===r[1]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}function Lj(e,t,n){return 1===t[0]?n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `:1===t[1]?n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}function zj(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[2]/2),s=a*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}function Bj(e,t,n){if(n)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${mj(["r","c","d"],e)}\n    return ivec3(r, c, d);\n  }\n`;let r=fj(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}function Wj(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[e.length-1]/2),s=a*Math.ceil(e[e.length-2]/2),i=s,o="",l="b, r, c";for(let u=2;u<e.length-1;u++)i*=e[e.length-u-1],o=`\n      int b${u} = index / ${i};\n      index -= b${u} * ${i};\n    `+o,l=`b${u}, `+l;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${o}\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec${e.length}(${l});\n    }\n  `}function Uj(e,t,n){if(n)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${mj(["r","c","d","d2"],e)}\n      return ivec4(r, c, d, d2);\n    }\n  `;let r=fj(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}function Vj(e,t){let n=fj(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}function Gj(e,t){let n=fj(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}function Hj(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(Sa.arraysEqual(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;let a=Math.ceil(e[1]/2);return n?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}function jj(e,t,n){return Sa.arraysEqual(e,t)?n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===e[1]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===e[0]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:n?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}function qj(e){return`offset${e}`}function Kj(e){let t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=hj();return`\n    vec4 ${n}() {\n      return ${r.texture2D}(${t}, halfCR);\n    }\n  `}function Xj(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;let[a,s]=e.shapeInfo.texShape;if(1===a&&1===s)return`\n      float ${r}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;let i=qj(n);if(t)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `;let[o,l]=e.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${o}, ${l}, ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `}function Jj(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=e.shapeInfo.texShape,s=hj();if(t)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `;let i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${i[0]}, ${i[1]}, index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `}function Yj(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${iq(e)}\n      }\n    `;let a=e.shapeInfo.texShape,s=a[0],i=a[1];if(1===i&&1===s)return`\n      float ${r}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;let o=qj(n);return 1===i?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${s}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:1===s?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:t?`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${s}, ${i}, index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `}function Zj(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,i=s[0],o=s[1],l=hj();if(null!=s&&Sa.arraysEqual(n,s))return t?`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `;if(t)return`\n    vec4 ${a}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `;let u=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],p=Math.ceil(n[1]/2);return`\n    vec4 ${a}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${p}, ${u[0]}, ${u[1]}, row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `}function Qj(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape;if(null!=s&&Sa.arraysEqual(n,s)){if(t)return`\n      float ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `;let e=s[0],n=s[1];return`\n    float ${a}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}.0, ${e}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}let{newShape:i,keptDims:o}=Sa.squeezeShape(n),l=i;if(l.length<n.length){let n=cq(e,l),r=["row","col"];return`\n      ${Ij(n,t)}\n      float ${a}(int row, int col) {\n        return ${a}(${dq(r,o)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${iq(e)}\n      }\n    `;let u=s[0],p=s[1],c=qj(r);return 1===p?t?`\n      float ${a}(int row, int col) {\n        float index = dot(vec3(row, col, ${c}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col) {\n      float index = dot(vec3(row, col, ${c}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `:1===u?t?`\n      float ${a}(int row, int col) {\n        float index = dot(vec3(row, col, ${c}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col) {\n      float index = dot(vec3(row, col, ${c}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${p}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `:t?`\n      float ${a}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${c};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n  float ${a}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${c};\n    vec2 uv = uvFromFlat(${u}, ${p}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}function eq(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(1===n[0]){let r=n.slice(1),s=[1,2],i=cq(e,r),o=["b","row","col"];return`\n        ${Sj(i,t)}\n        vec4 ${a}(int b, int row, int col) {\n          return ${a}(${dq(o,s)});\n        }\n      `}let o=hj();if(t)return`\n    vec4 ${a}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `;let l=i[0],u=i[1],p=Math.ceil(n[2]/2),c=p*Math.ceil(n[1]/2);return`\n    vec4 ${a}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${u}, ${c}, ${p}, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `}function tq(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[1]*n[2],i=n[2],{newShape:o,keptDims:l}=Sa.squeezeShape(n),u=o;if(u.length<n.length){let n=cq(e,u),r=["row","col","depth"];return`\n        ${Ij(n,t)}\n        float ${a}(int row, int col, int depth) {\n          return ${a}(${dq(r,l)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${s}, ${i}, 1)));\n        ${iq(e)}\n      }\n    `;let p=e.shapeInfo.texShape,c=p[0],d=p[1],h=e.shapeInfo.flatOffset;if(d===s&&null==h)return t?`\n      float ${a}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${a}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${i}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${d}.0, ${c}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(d===i&&null==h)return t?`\n      float ${a}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${c}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;let f=qj(r);return t?`\n    float ${a}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${f};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `:`\n      float ${a}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s} + col * ${i} + depth + ${f};\n        vec2 uv = uvFromFlat(${c}, ${d}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}function nq(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=hj();if(t)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${a.texture2D}(${n}, uv);\n    }\n  `;let s=e.shapeInfo.logicalShape,i=s.length,o=e.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=l[0],p=l[1],c=Math.ceil(s[i-1]/2),d=c*Math.ceil(s[i-2]/2),h="int b, int row, int col",f=`b * ${d} + (row / 2) * ${c} + (col / 2)`;for(let m=2;m<i-1;m++)h=`int b${m}, `+h,d*=s[i-m-1],f=`b${m} * ${d} + `+f;return`\n    vec4 ${r}(${h}) {\n      int index = ${f};\n      int texR = index / ${p};\n      int texC = index - texR * ${p};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}, ${u});\n      return ${a.texture2D}(${n}, uv);\n    }\n  `}function rq(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[3],i=n[2]*s,o=n[1]*i,{newShape:l,keptDims:u}=Sa.squeezeShape(n);if(l.length<n.length){let n=cq(e,l),r=["row","col","depth","depth2"];return`\n      ${Ij(n,t)}\n      float ${a}(int row, int col, int depth, int depth2) {\n        return ${a}(${dq(r,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${o}, ${i}, ${s}, 1)));\n        ${iq(e)}\n      }\n    `;let p=e.shapeInfo.flatOffset,c=e.shapeInfo.texShape,d=c[0],h=c[1],f=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(h===o&&null==p)return t?`\n      float ${a}(int row, int col, int depth, int depth2) {\n        ${f}\n        ${m}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${i}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${h}.0, ${d}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(h===s&&null==p)return t?`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${h}.0, ${d}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;let y=qj(r);return t?`\n    float ${a}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${f}\n      ${m}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `:`\n    float ${a}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} +\n          depth * ${s} + depth2;\n      vec2 uv = uvFromFlat(${d}, ${h}, index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `}function aq(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=t[4],s=t[3]*a,i=t[2]*s,o=t[1]*i,{newShape:l,keptDims:u}=Sa.squeezeShape(t);if(l.length<t.length){let t=cq(e,l),n=["row","col","depth","depth2","depth3"];return`\n      ${Ij(t)}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${dq(n,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${o}, ${i}, ${s}, ${a})) +\n          depth3;\n        ${iq(e)}\n      }\n    `;let p=e.shapeInfo.flatOffset,c=e.shapeInfo.texShape,d=c[0],h=c[1];if(h===o&&null==p)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${s}, ${a}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${h}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(h===a&&null==p)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${h}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;let f=qj(n);return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} + depth * ${s} +\n          depth2 * ${a} + depth3 + ${f};\n      vec2 uv = uvFromFlat(${d}, ${h}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}function sq(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:a,keptDims:s}=Sa.squeezeShape(t);if(a.length<t.length){let t=cq(e,a),n=["row","col","depth","depth2","depth3","depth4"];return`\n      ${Ij(t)}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${dq(n,s)});\n      }\n    `}let i=t[5],o=t[4]*i,l=t[3]*o,u=t[2]*l,p=t[1]*u;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${p}, ${u}, ${l}, ${o})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${iq(e)}\n      }\n    `;let c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],f=d[1];if(f===p&&null==c)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${l}, ${o}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(f===i&&null==c)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;let m=qj(n);return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${p} + col * ${u} + depth * ${l} +\n          depth2 * ${o} + depth3 * ${i} + depth4 + ${m};\n      vec2 uv = uvFromFlat(${h}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}function iq(e){let t=e.name,n=Sa.sizeFromShape(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function oq(e,t){let n,r=e.name,a=r.charAt(0).toUpperCase()+r.slice(1),s="get"+a+"AtOutCoords",i=e.shapeInfo.logicalShape.length,o=t.logicalShape.length,l=wj(e.shapeInfo.logicalShape,t.logicalShape),u=uq(o),p=o-i,c=["x","y","z","w","u","v"];n=0===i?"":o<2&&l.length>=1?"coords = 0;":l.map((e=>`coords.${c[e+p]} = 0;`)).join("\n");let d="";d=o<2&&i>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${c[t+p]}`)).join(", ");let h="return outputValue;",f=1===Sa.sizeFromShape(e.shapeInfo.logicalShape),m=1===Sa.sizeFromShape(t.logicalShape);if(1!==i||f||m){if(f&&!m)h=1===o?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(l.length){let e=i-2,t=i-1;l.indexOf(e)>-1&&l.indexOf(t)>-1?h="return vec4(outputValue.x);":l.indexOf(e)>-1?h="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":l.indexOf(t)>-1&&(h="return vec4(outputValue.xx, outputValue.zz);")}}else h="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${s}() {\n      ${u} coords = getOutputCoords();\n      ${n}\n      vec4 outputValue = get${a}(${d});\n      ${h}\n    }\n  `}function lq(e,t){let n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",s=t.texShape,i=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===l&&null==e.shapeInfo.flatOffset&&Sa.arraysEqual(i,s))return`\n      float ${a}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;let u,p=uq(l),c=wj(e.shapeInfo.logicalShape,t.logicalShape),d=l-o,h=["x","y","z","w","u","v"];u=0===o?"":l<2&&c.length>=1?"coords = 0;":c.map((e=>`coords.${h[e+d]} = 0;`)).join("\n");let f="";return f=l<2&&o>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${h[t+d]}`)).join(", "),`\n    float ${a}() {\n      ${p} coords = getOutputCoords();\n      ${u}\n      return get${r}(${f});\n    }\n  `}function uq(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function pq(e,t,n){let{newShape:r,keptDims:a}=Sa.squeezeShape(t),s=t.length,i=e&&3===s&&1===t[0],o=i?t.slice(1):r,l=!e&&s>1&&!Sa.arraysEqual(t,n)&&r.length<s||i;return{useSqueezeShape:l,uniformShape:l?o:t,keptDims:a}}function cq(e,t){let n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function dq(e,t){return t.map((t=>e[t])).join(", ")}function hq(e,t,n,r){let a=n.map(((e,n)=>{let r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:r}})),s=a.map((e=>e.shapeInfo)),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},o=kj(a,i,t),l=vH(e.gl,o),u=e.createProgram(l);return We().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:s,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:s,outShapeInfo:i},fq(e,t,u))}function fq(e,t,n){let r,a,s,i=[],o=[],l=null,u=null;u=e.getUniformLocation(n,"NAN",!1),1===We().getNumber("WEBGL_VERSION")&&(l=e.getUniformLocation(n,"INFINITY",!1));let p=!1;for(let c of t.variableNames){let r={name:c,uniform:e.getUniformLocation(n,c,p),offset:e.getUniformLocation(n,`offset${c}`,p)};t.enableShapeUniforms&&(r.shape=e.getUniformLocation(n,`${c}Shape`,p),r.texShape=e.getUniformLocation(n,`${c}TexShape`,p)),i.push(r)}if(t.enableShapeUniforms&&(r=e.getUniformLocation(n,"outShape",p),s=e.getUniformLocation(n,"outShapeStrides",p),a=e.getUniformLocation(n,"outTexShape",p)),t.customUniforms)for(let c of t.customUniforms)o.push(e.getUniformLocation(n,c.name,p));return{variablesLocations:i,customUniformLocations:o,infLoc:l,nanLoc:u,outShapeLocation:r,outShapeStridesLocation:s,outTexShapeLocation:a}}function mq(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach(((e,n)=>{let r=e.logicalShape,a=t[n],s=a.shape;if(!Sa.arraysEqual(r,s))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${s} must match`);if(e.isUniform&&a.isUniform)return;let i=e.texShape,o=a.isUniform?null:a.texData.texShape;if(!Sa.arraysEqual(i,o))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${o} must match`)}))}function gq(e,t,n,r,a){t.program.enableShapeUniforms||(mq(t.inShapeInfos,n),mq([t.outShapeInfo],[r]));let s=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(s.texture,i[0],i[1]):e.setOutputMatrixTexture(s.texture,i[0],i[1]),e.setProgram(t.webGLProgram),1===We().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN);for(let l=0;l<n.length;++l){let r=n[l],{uniform:a,offset:s,shape:i,texShape:o}=t.variablesLocations[l];if(i){let{uniformShape:n}=pq(t.program.packedInputs,r.shape,r.texData.texShape);switch(n.length){case 1:e.gl.uniform1iv(i,new Int32Array(n));break;case 2:e.gl.uniform2iv(i,new Int32Array(n));break;case 3:e.gl.uniform3iv(i,new Int32Array(n));break;case 4:e.gl.uniform4iv(i,new Int32Array(n));break;default:break}}if(o&&e.gl.uniform2i(o,r.texData.texShape[0],r.texData.texShape[1]),null!=a){if(r.isUniform){if(Sa.sizeFromShape(r.shape)<2)e.gl.uniform1f(a,r.uniformValues[0]);else{let t=r.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(a,t)}continue}null!=r.texData.slice&&null!=s&&e.gl.uniform1i(s,r.texData.slice.flatOffset),e.setInputMatrixTexture(r.texData.texture.texture,a,l)}}let o=t.outShapeLocation;if(o)switch(r.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(r.shape));break;default:break}if(t.outShapeStridesLocation){let n=Sa.computeStrides(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n));break;default:break}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&a)for(let l=0;l<t.program.customUniforms.length;++l){let n=t.program.customUniforms[l],r=t.customUniformLocations[l],s=a[l];if("float"===n.type)e.gl.uniform1fv(r,s);else if("vec2"===n.type)e.gl.uniform2fv(r,s);else if("vec3"===n.type)e.gl.uniform3fv(r,s);else if("vec4"===n.type)e.gl.uniform4fv(r,s);else if("int"===n.type)e.gl.uniform1iv(r,s);else if("ivec2"===n.type)e.gl.uniform2iv(r,s);else if("ivec3"===n.type)e.gl.uniform3iv(r,s);else{if("ivec4"!==n.type)throw Error(`uniform type ${n.type} is not supported yet.`);e.gl.uniform4iv(r,s)}}e.executeProgram()}function yq(e,t,n){let r="";t.concat(n).forEach((t=>{let a=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){let s=t.texData.texShape,{useSqueezeShape:i,uniformShape:o,keptDims:l}=pq(e.packedInputs,t.shape,s),u="",p="",c="";if(1===o.length&&e.packedInputs){let e=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];u=`${e[0]>1}_${e[1]>1}`}else if(2!==o.length||e.packedInputs){if(o.length>2&&!e.packedInputs){let e=Sa.computeStrides(o);c=`${e[0]===s[1]}_${e[e.length-1]===s[1]}`}}else p=`${o[0]>1}_${o[1]>1}`;let d=t.shape.length,h=2===o.length&&Sa.arraysEqual(t.shape,s),f=1===Sa.sizeFromShape(t.shape),m=Qx.getBroadcastDims(t.shape,n.shape),g=!e.packedInputs&&d===n.shape.length&&Sa.arraysEqual(s,n.texData.texShape),y=e.packedInputs||o.length>2?"":`${s[0]>1}_${s[1]>1}`;r+=`${d}_${g}_${i?l:""}_${o.length}_${f}_${m}_${h}_${u}_${p}_${c}_${y}_${a}`}else{let e=t.isUniform?"uniform":t.texData.texShape;r+=`${t.shape}_${e}_${a}`}}));let a=e.userCode,s=e.constructor.name;return s+="_"+r+"_"+a+`${We().getNumber("WEBGL_VERSION")}`,s}function bq(e){return We().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}var xq=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=YG.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=hj();this.outputShape=e,this.enableShapeUniforms=bq(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?mj(["r","c","d"],e):fj(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${t.output} = result;\n      }\n    `}},vq=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=YG.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=hj();this.outputShape=e,this.enableShapeUniforms=bq(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?mj(["r","c","d"],e):fj(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${t.output} = result;\n      }\n    `}},wq=class{constructor(e){this.variableNames=["A"],this.outTexUsage=ZG.DOWNLOAD;let t=hj();this.outputShape=e,this.userCode=`\n      ${vj}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}},kq=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=ZG.DOWNLOAD;let t=hj();this.outputShape=e,this.userCode=`\n      ${vj}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}},Iq={R:0,G:1,B:2,A:3},Sq=class{constructor(e,t=!1,n="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let r=hj();this.outputShape=e,this.enableShapeUniforms=bq(this.outputShape.length);let a="result";t&&(a="floor(result * 255. + 0.5)");let s="";for(let i=0;i<n.length;i++){let e=n[i];s+=`\n          if(offset == ${i}) {\n            result = values[${Iq[e]}];\n          }`}this.userCode=`\n      ${this.enableShapeUniforms?xj():bj(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${n.length});\n\n        flatIndex = idiv(flatIndex, ${n.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${r.texture2D}(A, uv);\n          ${s}\n        }\n        ${r.output} = vec4(${a}, 0., 0., 0.);\n      }\n    `}},Nq=class{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=hj();this.outputShape=e,this.enableShapeUniforms=bq(this.outputShape.length);let r="",a="result";t&&(a="floor(result * 255. + 0.5)");for(let s=0;s<=1;s++)for(let t=0;t<=1;t++){let a=2*s+t;r+=`\n          localCoords = coords;\n          if(localCoords[2] + ${t} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {\n          localCoords[2] += ${t};\n          if (localCoords[1] + ${s} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {\n            localCoords[1] += ${s};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${a}] = values[0];\n            } else if (offset == 1) {\n              result[${a}] = values[1];\n            } else if (offset == 2) {\n              result[${a}] = values[2];\n            } else {\n              result[${a}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?xj():bj(e)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${r}\n\n          ${n.output} = ${a};\n        }\n    `}},Tq={};function _q(e){let t=hj(),n=`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`;return xH(e,n)}function Cq(e){let t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return CH(e,t)}function Eq(e){let t=new Uint16Array([0,1,2,2,1,3]);return EH(e,t)}function Aq(e,t,n,r,a,s){RH(t,n);let i=$H(e),o=e.TEXTURE_2D;return dH(e,(()=>e.bindTexture(o,i))),dH(e,(()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),dH(e,(()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),dH(e,(()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST))),dH(e,(()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST))),1===We().getNumber("WEBGL_VERSION")?dH(e,(()=>e.texImage2D(o,0,r,t,n,0,a,s,null))):dH(e,(()=>e.texStorage2D(o,1,r,t,n))),dH(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),{texture:i,texShape:[n,t]}}function $q(e){return e.internalFormatFloat}function Rq(e,t,n,r){let[a,s]=iH(t,n);return Aq(e,a,s,$q(r),r.textureFormatFloat,e.FLOAT)}function Fq(e){return e.internalFormatHalfFloat}function Dq(e,t,n,r){let[a,s]=iH(t,n);return Aq(e,a,s,Fq(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function Mq(e){return e.downloadTextureFormat}function Oq(e,t,n,r){let[a,s]=iH(t,n);return Aq(e,a,s,Mq(r),e.RGBA,e.UNSIGNED_BYTE)}function Pq(e){return e.internalFormatPackedFloat}function Lq(e,t,n,r){let[a,s]=uH(t,n);return Aq(e,a,s,Pq(r),e.RGBA,e.FLOAT)}function zq(e){return e.internalFormatPackedHalfFloat}function Bq(e,t,n,r){let[a,s]=uH(t,n);return Aq(e,a,s,zq(r),e.RGBA,r.textureTypeHalfFloat)}function Wq(e,t,n){return dH(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),DH(e,t,"clipSpacePos",n,3,20,0)&&DH(e,t,"uv",n,2,20,12)}function Uq(e,t,n,r,a,s){let i,o,l;dH(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),a instanceof Uint8Array?(i=new Uint8Array(n*r*4),o=e.UNSIGNED_BYTE,l=e.RGBA):(i=new Float32Array(n*r*4),o=e.FLOAT,l=s.internalFormatPackedFloat),i.set(a),2===We().getNumber("WEBGL_VERSION")?dH(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,o,i))):dH(e,(()=>e.texImage2D(e.TEXTURE_2D,0,l,n,r,0,e.RGBA,o,i))),dH(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function Vq(e,t,n){dH(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?2===We().getNumber("WEBGL_VERSION")?dH(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data))):dH(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):2===We().getNumber("WEBGL_VERSION")?dH(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n))):dH(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),dH(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function Gq(e,t,n,r){let a=e.createBuffer();dH(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,a)));let s=16*t*n;return dH(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,s,e.STREAM_READ))),dH(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),dH(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),a}function Hq(e,t,n){let r=e,a=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,a),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),a}function jq(e,t,n,r){let[a,s]=iH(t,n),i=4,o=new Uint8Array(oH(t*n,i));return dH(e,(()=>e.readPixels(0,0,a,s,r.downloadTextureFormat,e.UNSIGNED_BYTE,o))),new Float32Array(o.buffer)}function qq(e,t,n,r,a,s,i,o){let l=e,u=new Float32Array(pH(s,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function Kq(e,t,n){let r=new Float32Array(t*n*4);return dH(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r))),r}g(Tq,{bindVertexProgramAttributeStreams:()=>Wq,createBufferFromOutputTexture:()=>Gq,createFloat16MatrixTexture:()=>Dq,createFloat16PackedMatrixTexture:()=>Bq,createFloat32MatrixTexture:()=>Rq,createIndexBuffer:()=>Eq,createPackedMatrixTexture:()=>Lq,createUnsignedBytesMatrixTexture:()=>Oq,createVertexBuffer:()=>Cq,createVertexShader:()=>_q,downloadByteEncodedFloatMatrixFromOutputTexture:()=>jq,downloadFloat32MatrixFromBuffer:()=>Hq,downloadMatrixFromPackedOutputTexture:()=>Kq,downloadPackedMatrixFromBuffer:()=>qq,getInternalFormatForFloat16MatrixTexture:()=>Fq,getInternalFormatForFloat16PackedMatrixTexture:()=>zq,getInternalFormatForFloat32MatrixTexture:()=>$q,getInternalFormatForPackedMatrixTexture:()=>Pq,getInternalFormatForUnsignedBytesMatrixTexture:()=>Mq,uploadDenseMatrixToTexture:()=>Uq,uploadPixelDataToTexture:()=>Vq});var Xq=class{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];let t=We().getNumber("WEBGL_VERSION");if(null!=e?(this.gl=e,nH(t,e)):this.gl=rH(t),e=this.gl,2===We().getNumber("WEBGL_VERSION")){let t=e;this.createVertexArray=()=>dH(t,(()=>t.createVertexArray())),this.bindVertexArray=e=>dH(t,(()=>t.bindVertexArray(e))),this.deleteVertexArray=e=>dH(t,(()=>t.deleteVertexArray(e))),this.getVertexArray=()=>dH(t,(()=>t.getParameter(t.VERTEX_ARRAY_BINDING)))}else if(null!=e){let t=e.getExtension("OES_vertex_array_object");if(null==t)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>dH(e,(()=>t.createVertexArrayOES())),this.bindVertexArray=n=>dH(e,(()=>t.bindVertexArrayOES(n))),this.deleteVertexArray=n=>dH(e,(()=>t.deleteVertexArrayOES(n))),this.getVertexArray=()=>dH(e,(()=>e.getParameter(t.VERTEX_ARRAY_BINDING_OES)))}let n="WEBGL_color_buffer_float",r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===We().getNumber("WEBGL_VERSION")){let e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=bH(this.gl,e),aj(this.gl,t))this.textureHalfFloatExtension=bH(this.gl,t);else if(We().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),aj(this.gl,r))this.colorBufferHalfFloatExtension=bH(this.gl,r);else if(We().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",aj(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!aj(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=Cq(this.gl),this.indexBuffer=Eq(this.gl),this.framebuffer=FH(this.gl),this.textureConfig=cH(this.gl,this.textureHalfFloatExtension)}get debug(){return We().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let e=this.gl;dH(e,(()=>e.finish())),dH(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),dH(e,(()=>e.deleteFramebuffer(this.framebuffer))),dH(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),dH(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),dH(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),Rq(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),Dq(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),Oq(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),Vq(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),Uq(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),Bq(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),Lq(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(UH(this.gl,this.framebuffer),this.outputTexture=null),dH(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>jq(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,r,a,s){return qq(this.gl,e,t,n,r,a,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return Hq(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);let r=Gq(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(We().getBool("WEBGL_FENCE_API_ENABLED")){let r=e,a=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{let e=r.clientWaitSync(a,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=a}else We().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,We().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>Kq(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();let t=this.gl;null==this.vertexShader&&(this.vertexShader=_q(t));let n,r=NH(t);return dH(t,(()=>t.attachShader(r,this.vertexShader))),dH(t,(()=>t.attachShader(r,e))),TH(t,r),n=Object.assign(r,{vao:this.createVertexArray()}),this.bindVertexArray(n.vao),dH(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer))),console.assert(Wq(t,n,this.vertexBuffer),"gpgpu_util.bindVertexProgramAttributeStreams not fully successful."),this.debug&&_H(t,n),this.setProgram(n),n}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(dH(this.gl,(()=>this.gl.deleteProgram(e))),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&(this.bindVertexArray(this.program.vao),this.debug&&_H(this.gl,this.program)),dH(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?PH(this.gl,e,t):LH(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),dH(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),zH(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();let[r,a]=uH(t,n);this.setOutputMatrixTextureDriver(e,r,a)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&_H(this.gl,this.program),VH(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;if(this.debug){let e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}dH(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),dH(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=bH(this.gl,2===We().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===We().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){let e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===We().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){let e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await Sa.repeatedTry((()=>this.disposed||this.isQueryAvailable(e,We().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,We().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){let t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{let t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){let t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{let t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){let e=Jq(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){let{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in We().platform&&(n=We().platform.setTimeoutCustom.bind(We().platform)),Sa.repeatedTry((()=>(this.pollItems(),0===this.itemsToPoll.length)),(()=>0),null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),WH(this.gl,e,this.framebuffer),this.debug&&VH(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(WH(this.gl,this.outputTexture,this.framebuffer),this.debug&&VH(this.gl)):UH(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();let r=this.gl;WH(r,e,this.framebuffer),this.debug&&VH(r),this.outputTexture=e,dH(r,(()=>r.viewport(0,0,t,n))),dH(r,(()=>r.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),dH(this.gl,(()=>this.gl.scissor(e,t,n,r)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}};function Jq(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}var{addImpl:Yq,bincountImpl:Zq,bincountReduceImpl:Qq,castImpl:eK,ceilImpl:tK,concatImpl:nK,equalImpl:rK,expImpl:aK,expm1Impl:sK,floorImpl:iK,gatherNdImpl:oK,gatherV2Impl:lK,greaterImpl:uK,greaterEqualImpl:pK,lessImpl:cK,lessEqualImpl:dK,linSpaceImpl:hK,logImpl:fK,maxImpl:mK,maximumImpl:gK,minimumImpl:yK,multiplyImpl:bK,negImpl:xK,notEqualImpl:vK,prodImpl:wK,raggedGatherImpl:kK,raggedRangeImpl:IK,raggedTensorToTensorImpl:SK,rangeImpl:NK,rsqrtImpl:TK,scatterImpl:_K,sigmoidImpl:CK,simpleAbsImpl:EK,sliceImpl:AK,sparseFillEmptyRowsImpl:$K,sparseReshapeImpl:RK,sparseSegmentReductionImpl:FK,sqrtImpl:DK,staticRegexReplaceImpl:MK,stridedSliceImpl:OK,stringNGramsImpl:PK,stringSplitImpl:LK,stringToHashBucketFastImpl:zK,subImpl:BK,tileImpl:WK,topKImpl:UK,transposeImpl:VK,uniqueImpl:GK}=TO;function HK(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>`${e}.${t}`))}function jK(e,t){return 1===t?[e]:HK(e,t)}function qK(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}var KK=class{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=bq(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{let e=jK("rc",this.rank),t=uq(this.rank),n=this.getOutOfBoundsCondition(e),r=this.getSetup(e),a=this.getOutput(e);this.userCode=`\n        void main() {\n          ${t} rc = getOutputCoords();\n\n          if(${n}) {\n            setOutput(vec4(0));\n          } else {\n            ${r}\n\n            setOutput(vec4(${a}));\n          }\n        }\n      `}}getSourceCoordsArr(e){let t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let a=`${0===n?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let t=2;t<this.rank;t++)a=`${e[e.length-1-t]},`+a;t.push(a)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";let t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${t[0]};\n      int c = ${t[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${n};\n      bool rEdge = rp1 >= ${r};\n    `}getOutput(e){let t=this.getSourceCoordsArr(e);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),\n            cEdge ? 0. : getA(${t[1]}),\n            rEdge ? 0. : getA(${t[2]}),\n            rEdge || cEdge ? 0. : getA(${t[3]})`}},XK=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=bq(this.outputShape.length);let n="";for(let r=0;r<4;r++){let e="thisRC = rc;";r%2===1&&(e+="thisRC.z += 1;"),r>1&&(e+="thisRC.y += 1;"),n+=`\n        ${e}\n        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${r}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${r>0?"}":""}\n      `}this.userCode=`\n      ${JK(t,this.enableShapeUniforms)}\n      ${this.enableShapeUniforms?xj():bj(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}};function JK(e,t){return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${t?yj(["r","c","d"],"inputShape"):fj(["r","c","d"],e)}\n      return ivec3(r, c, d);\n    }\n  `}var YK=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){let r=nX(t,n),a=rX(e,r,n);a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]);let s,i=QK(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();let e=this.freeTextures[a].pop();return this.usedTextures[a].push(e),e}return r===QG.PACKED_2X2_FLOAT32?s=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===QG.PACKED_2X2_FLOAT16?s=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===QG.UNPACKED_FLOAT32?s=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===QG.UNPACKED_FLOAT16?s=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===QG.PACKED_4X1_UNSIGNED_BYTE&&(s=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[a].push(s),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),s}releaseTexture(e,t,n,r){if(null==this.freeTextures)return;let a=nX(n,r),s=rX(t,a,r);s in this.freeTextures||(this.freeTextures[s]=[]);let i=QK(t,a,this.gpgpu.gl,this.gpgpu.textureConfig,r),o=We().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==o&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[s].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;let l=this.usedTextures[s],u=l&&l.indexOf(e);if(null==u||u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[u]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;let e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(let e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));for(let e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function ZK(e,t){let n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F||t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function QK(e,t,n,r,a){let s,i=eX(t,r);if(a){let[t,n]=uH(e[0],e[1]);s=t*n}else{let[t,n]=iH(e[0],e[1]);s=t*n}let o=ZK(n,i);return s*o}function eX(e,t){switch(e){case QG.PACKED_2X2_FLOAT32:return Pq(t);case QG.PACKED_2X2_FLOAT16:return zq(t);case QG.UNPACKED_FLOAT32:return $q(t);case QG.UNPACKED_FLOAT16:return Fq(t);case QG.PACKED_4X1_UNSIGNED_BYTE:return Mq(t);default:throw new Error(`Unknown physical texture type ${e}`)}}function tX(e){return We().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?QG.PACKED_2X2_FLOAT32:QG.UNPACKED_FLOAT32:e?QG.PACKED_2X2_FLOAT16:QG.UNPACKED_FLOAT16}function nX(e,t){if(e===ZG.UPLOAD)return QG.PACKED_2X2_FLOAT32;if(e===ZG.RENDER||null==e)return tX(t);if(e===ZG.DOWNLOAD||e===ZG.PIXELS)return QG.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function rX(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}var aX=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=bq(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}},sX="if (isnan(x)) return x;",iX="return x;",oX="return abs(x);",lX="return (x >= 0.0) ? x : (exp(x) - 1.0);",uX=sX+"\n  return (x < 0.0) ? 0.0 : x;\n",pX=sX+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",cX="return x;",dX="return 1.0 / (1.0 + exp(-1.0 * x));",hX="return x;",fX="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",mX="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",gX="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",yX="return 1.0 / (1.0 + exp(-1.0 * x));",bX=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=bq(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}},xX=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=bq(this.outputShape.length);let t=e.length,n=jK("rc",t),r=uq(t),a=qK(t,n),s=n.slice(-2),i=t<=1?"rc":`vec2(${s.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${a});\n\n        setOutput(getChannel(packedInput, ${i}));\n      }\n    `}},vX=sw.whereImpl,wX=1e-7,kX=1e-4,IX={};function SX(e){return e in IX||(IX[e]={}),IX[e]}var NX=We().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),TX=600;function _X(){return null==We().global.screen?1024:We().global.screen.height*We().global.screen.width*window.devicePixelRatio*TX/1024/1024}var CX=class extends W{nextDataId(){return CX.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!We().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof Xq)t=e;else{let n=rH(We().getNumber("WEBGL_VERSION"),e);t=new Xq(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let e=rH(We().getNumber("WEBGL_VERSION"));t=new Xq(e),this.binaryCache=SX(We().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new YK(this.gpgpu),this.numMBBeforeWarning=_X(),this.texData=new B(this,$o())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,r,a,s){let i=this.makeTensorInfo(t,n),o=this.texData.get(i.dataId);o.isPacked=!1,o.texture={texture:e,texShape:[r,a]},o.texShape=[r,a];let l=XH(t),u=new Sq(l,!1,s),p=this.runWebGLProgram(u,[i],n,[[r,a]]);return p.shape=t,o.texture=null,this.disposeIntermediateTensorInfo(i),p.dataId}write(e,t,n){if((We().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||We().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:ZG.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){let t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){let t=this.texData.get(e);t.refCount--}}move(e,t,n,r,a){if(We().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:ZG.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){let t=this.texData.get(e),{values:n,dtype:r,complexTensorInfos:a,slice:s,shape:i,isPacked:o}=t;if(null!=s){let t;t=o?new bX(i,cX):new aX(i,cX);let n=this.runWebGLProgram(t,[{dataId:e,shape:i,dtype:r}],r),a=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===r)return n;let l,u,p=null!=this.activeTimers;if(p&&(l=Sa.now()),"complex64"===r){let e=this.readSync(a.real.dataId),t=this.readSync(a.imag.dataId);u=Qx.mergeRealAndImagArrays(e,t)}else u=this.getValuesFromTexture(e);return p&&(this.downloadWaitMs+=Sa.now()-l),this.convertAndCacheOnCPU(e,u)}async read(e){if(this.pendingRead.has(e)){let t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}let t=this.texData.get(e),{values:n,shape:r,slice:a,dtype:s,complexTensorInfos:i,isPacked:o}=t;if(null!=a){let t;t=o?new bX(r,cX):new aX(r,cX);let n=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:s}],s),a=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if(We().getBool("DEBUG")&&!We().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===We().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,u,p=null;if("complex64"!==s&&We().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(e);let t=this.texData.get(l.dataId);p=this.gpgpu.createBufferFromTexture(t.texture.texture,...lH(r))}if(this.pendingRead.set(e,[]),"complex64"!==s&&await this.gpgpu.createAndWaitForFence(),"complex64"===s){let e=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]),t=e[0],n=e[1];u=Qx.mergeRealAndImagArrays(t,n)}else if(null==p)u=this.getValuesFromTexture(e);else{let e=Sa.sizeFromShape(r);u=this.gpgpu.downloadFloat32MatrixFromBuffer(p,e)}if(null!=l&&this.disposeIntermediateTensorInfo(l),null!=p){let e=this.gpgpu.gl;dH(e,(()=>e.deleteBuffer(p)))}let c=this.convertAndCacheOnCPU(e,u),d=this.pendingRead.get(e);return this.pendingRead.delete(e),d.forEach((e=>e(c))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&$o().removeDataId(e,this),this.pendingDeletes--),c}readToGPU(e,t={}){let n=this.texData.get(e),{values:r,shape:a,slice:s,dtype:i,isPacked:o,texture:l}=n;if("complex64"===i)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=s){let n;n=o?new bX(a,cX):new aX(a,cX);let r=this.runWebGLProgram(n,[{dataId:e,shape:a,dtype:i}],i),s=this.readToGPU(r,t);return this.disposeIntermediateTensorInfo(r),s}if(null==l)throw null!=r?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let u=this.decode(e,t.customTexShape),p=$o().makeTensorFromTensorInfo(u),c=this.texData.get(u.dataId);return Object.assign({tensorRef:p},c.texture)}bufferSync(e){let t=this.readSync(e.dataId);if("string"===e.dtype)try{let n=t.map((e=>Sa.decodeString(e)));return xo(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return xo(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){let n=e[t];if(!gH(n))throw We().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${n} cannot be represented on this device.`)}}getValuesFromTexture(e){let{shape:t,dtype:n,isPacked:r}=this.texData.get(e),a=Sa.sizeFromShape(t);if(We().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let n=this.decode(e),r=this.texData.get(n.dataId),s=this.gpgpu.downloadMatrixFromPackedTexture(r.texture.texture,...lH(t)).subarray(0,a);return this.disposeIntermediateTensorInfo(n),s}let s=We().getBool("WEBGL_PACK")&&!0===r,i=s?XH(t):t,o=s?new kq(i):new wq(i),l=this.runWebGLProgram(o,[{shape:i,dtype:n,dataId:e}],"float32"),u=this.texData.get(l.dataId),p=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(l),p}timerAvailable(){return We().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){let t=this.activeTimers,n=[],r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();let a=Sa.flatten(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),s=Sa.flatten(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,r&&(this.programTimersStack=null);let i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(We().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let e=await Promise.all(a);i.kernelMs=Sa.sum(e),i.getExtraProfileInfo=()=>e.map(((e,t)=>({name:s[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return We().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Sa.now(),endMs:null}}endTimer(e){return We().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Sa.now(),e)}async getQueryTime(e){if(We().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);let t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);let{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){let{texture:t,dtype:n,texShape:r,usage:a,isPacked:s,slice:i}=this.texData.get(e),o=i&&i.origDataId||e,l=this.dataRefCount.get(o);l>1?this.dataRefCount.set(o,l-1):(this.dataRefCount.delete(o),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,a,s)));let u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=NX){return We().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>null==this.texData.get(e.dataId).texture&&Sa.sizeFromShape(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){Qx.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let t=e.dataSync();return vX(e.shape,t)}packedUnaryOp(e,t,n){let r=new bX(e.shape,t),a=this.compileAndRun(r,[e],n);return $o().makeTensorFromTensorInfo(a)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){let t=EK(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(We().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,oX,e.dtype);let t=new aX(e.shape,oX),n=this.compileAndRun(t,[e]);return $o().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&Sa.isString(n[0])){let a=n.map((e=>Sa.encodeString(e)));r=this.write(a,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){return $o().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){let t=new xX(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){let t=new KK(e.shape),n=!0;return this.runWebGLProgram(t,[e],e.dtype,null,n)}packedReshape(e,t){let n=[qH(e.shape),...KH(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},a=[qH(t),...KH(t)],s=new XK(a,n),i=!0,o=[n],l=this.runWebGLProgram(s,[r],e.dtype,o,i);return{dataId:l.dataId,shape:t,dtype:l.dtype}}decode(e,t){let n=this.texData.get(e),{isPacked:r,shape:a,dtype:s}=n;if(null!=t){let e=Sa.sizeFromShape(a),n=t[0]*t[1]*4;Sa.assert(e<=n,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}let i,o=XH(a);i=r?new vq(o):new xq(o);let l=!0,u=[null!=t?t:lH(o)],p=this.runWebGLProgram(i,[{shape:o,dtype:s,dataId:e}],s,u,l,t);return{dtype:s,shape:a,dataId:p.dataId}}runWebGLProgram(e,t,n,r,a=!1,s){let i=this.makeTensorInfo(e.outputShape,n),o=this.texData.get(i.dataId);if(e.packedOutput&&(o.isPacked=!0),e.outPackingScheme===YG.DENSE){let t=null!=s?s:lH(e.outputShape);o.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(o.usage=e.outTexUsage),0===Sa.sizeFromShape(i.shape))return o.values=Sa.getTypedArrayFromDType(i.dtype,0),i;let l=[],u=t.map((t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&Sa.sizeFromShape(t.shape)<=We().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!=!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),l.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!ZH(n.shape,t.shape)){let e=t,r=t.shape;t.shape=n.shape,t=this.packedReshape(t,r),l.push(t),n=this.texData.get(t.dataId),e.shape=r}return{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(i.dataId);let p,c={shape:i.shape,texData:o,isUniform:!1},d=yq(e,u,c),h=this.getAndSaveBinary(d,(()=>hq(this.gpgpu,e,u,c))),f=null!=this.activeTimers;f&&(p=this.startTimer()),We().get("ENGINE_COMPILE_ONLY")||gq(this.gpgpu,h,u,c,r),l.forEach((e=>this.disposeIntermediateTensorInfo(e))),f&&(p=this.endTimer(p),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(p)}));let m=We().get("WEBGL_FLUSH_THRESHOLD");if(m>0){let e=Sa.now();e-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!We().getBool("WEBGL_LAZILY_UNPACK")&&o.isPacked&&!1===a){let e=this.unpackTensor(i);return this.disposeIntermediateTensorInfo(i),e}return i}compileAndRun(e,t,n,r,a=!1){return n=n||t[0].dtype,this.runWebGLProgram(e,t,n,r,a)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(We().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]})),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=Do((()=>{if(!We().get("WEBGL_RENDER_FLOAT32_ENABLED")){let e=We().getBool("DEBUG");We().set("DEBUG",!1);let t=this.abs(Zp(1e-8)).dataSync()[0];if(We().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?wX:kX}uploadToGPU(e){let t=this.texData.get(e),{shape:n,dtype:r,values:a,texture:s,usage:i,isPacked:o}=t;if(null!=s)return;let l,u=null!=this.activeTimers;u&&(l=Sa.now());let p=t.texShape;if(null==p&&(p=JH(n,o),t.texShape=p),null!=a){let e,s=XH(n),i=p[1],c=p[0],d=a instanceof Uint8Array||a instanceof Uint8ClampedArray;(o||!d)&&([i,c]=uH(p[0],p[1])),e=o?new Nq(s,d):new Sq(s,d);let h=d?[c,i]:p,f=this.makeTensorInfo(h,r),m=this.texData.get(f.dataId);m.usage=d?ZG.PIXELS:ZG.UPLOAD,m.texShape=h,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),i,c,a);let g=[[c,i]],y=!0,b=this.runWebGLProgram(e,[f],r,g,y),x=this.texData.get(b.dataId);t.texShape=x.texShape,t.isPacked=x.isPacked,t.usage=x.usage,We().get("ENGINE_COMPILE_ONLY")?this.disposeData(b.dataId):(t.texture=x.texture,t.values=null,this.texData.delete(b.dataId)),this.disposeIntermediateTensorInfo(f),u&&(this.uploadWaitMs+=Sa.now()-l)}else{let e=this.acquireTexture(p,i,r,o);t.texture=e}}convertAndCacheOnCPU(e,t){let n=this.texData.get(e),{dtype:r}=n;return null!=t&&(n.values=EX(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){let e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*Sa.bytesPerElement(t)}checkCompileCompletion(){for(let[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){let e=[];if(this.gpgpu.parallelCompilationExtension){for(let[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(let[,t]of Object.entries(this.binaryCache)){let n=new Promise((e=>{try{this.checkCompletion_(t),e(!0)}catch(n){throw n}}));e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await Yx(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS))throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)?(SH(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let e of Object.values(this.binaryCache)){let{variablesLocations:t,customUniformLocations:n,infLoc:r,nanLoc:a,outShapeLocation:s,outShapeStridesLocation:i,outTexShapeLocation:o}=fq(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=n,e.infLoc=r,e.nanLoc=a,e.outShapeLocation=s,e.outShapeStridesLocation=i,e.outTexShapeLocation=o}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";let{texture:r,height:a,width:s,channels:i}=e,o=$o().backend;if(!o.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");let l=o.writeTexture(r,t,n,a,s,i);return $o().makeTensorFromDataId(l,t,n,o)}};function EX(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){let n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error(`Unknown dtype ${t}`)}CX.nextDataId=0;var AX="4.3.0";function $X(){We().set("WEBGL_FORCE_F16_TEXTURES",!0)}js.isBrowser()&&Go("webgl",(()=>new CX),2);var RX={forceHalfFloat:$X},FX="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n",DX=class{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=Qx.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=bq(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}},MX="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n",OX=class{constructor(e,t,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Qx.assertAndGetBroadcastShape(t,n);let a=this.outputShape.length;this.enableShapeUniforms=bq(a);let s="";if(r)if(0===a||1===Sa.sizeFromShape(this.outputShape))s="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(s=`\n          ${uq(a)} coords = getOutputCoords();\n        `,1===a)this.enableShapeUniforms?s+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":s+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{let e=jK("coords",a);this.enableShapeUniforms?s+=`\n            bool nextRowOutOfBounds =\n              (${e[a-2]} + 1) >= outShape[${a} - 2];\n            bool nextColOutOfBounds =\n              (${e[a-1]} + 1) >= outShape[${a} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:s+=`\n            bool nextRowOutOfBounds =\n              (${e[a-2]} + 1) >= ${this.outputShape[a-2]};\n            bool nextColOutOfBounds =\n              (${e[a-1]} + 1) >= ${this.outputShape[a-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${s}\n\n        setOutput(result);\n      }\n    `}};function PX(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var LX={kernelName:un,backendName:"webgl",kernelFunc:PX};function zX(e){let{inputs:t,backend:n}=e,{real:r,imag:a}=t,s=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(s.dataId),o=PX({inputs:{x:r},backend:n}),l=PX({inputs:{x:a},backend:n});return i.complexTensorInfos={real:o,imag:l},s}var BX={kernelName:vt,backendName:"webgl",kernelFunc:zX},WX="return (a < 0.) ? b * a : a;",UX="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";function VX(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:s}=r,i=n.makeTensorInfo([],"float32",Sa.createScalarValue(s,"float32")),o=We().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new OX(UX,a.shape,i.shape):new DX(WX,a.shape,i.shape),l=n.runWebGLProgram(o,[a,i],"float32");return n.disposeIntermediateTensorInfo(i),l}var GX={kernelName:mn,backendName:"webgl",kernelFunc:VX},HX="return (a < 0.) ? b * a : a;",jX="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";function qX(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t,s=We().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new OX(jX,r.shape,a.shape):new DX(HX,r.shape,a.shape);return n.runWebGLProgram(s,[r,a],"float32")}var KX={kernelName:tr,backendName:"webgl",kernelFunc:qX},XX="if (isnan(x)) return x;";function JX({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:a,backend:s})=>{let{x:i}=a,o=s,l=r||i.dtype;if(o.shouldExecuteOnCPU([i])&&null!=n){let e=o.texData.get(i.dataId),t=n(e.values,l);return o.makeTensorInfo(i.shape,l,t)}let u,p=We().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t;return u=p?new bX(i.shape,t):new aX(i.shape,e),o.runWebGLProgram(u,[i],l)}}function YX({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:a,dtype:s}){return({inputs:i,backend:o})=>{let{a:l,b:u}=i,p=o;if(r&&"complex64"===l.dtype){let t=p.texData.get(l.dataId),n=p.texData.get(u.dataId),[r,a]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((t=>{let[n,r]=t,a={dataId:n.dataId,dtype:n.dtype,shape:l.shape},s={dataId:r.dataId,dtype:r.dtype,shape:u.shape},i=new DX(e,l.shape,u.shape);return p.runWebGLProgram(i,[a,s],Cs(n.dtype,r.dtype))})),s=zX({inputs:{real:r,imag:a},backend:p});return p.disposeIntermediateTensorInfo(r),p.disposeIntermediateTensorInfo(a),s}let c=s||Cs(l.dtype,u.dtype);if(("string"===l.dtype||"string"===u.dtype||p.shouldExecuteOnCPU([l,u]))&&null!=a){let e=p.texData.get(l.dataId).values,t=p.texData.get(u.dataId).values,n="string"===l.dtype?Qx.fromUint8ToStringArray(e):e,r="string"===l.dtype?Qx.fromUint8ToStringArray(t):t,[s,i]=a(l.shape,u.shape,n,r,c),o=p.makeTensorInfo(i,c),d=p.texData.get(o.dataId);return d.values=s,o}let d,h=We().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t;return d=h?new OX(t,l.shape,u.shape,n):new DX(e,l.shape,u.shape),p.runWebGLProgram(d,[l,u],c)}}function ZX(e,t=!1){if("linear"===e)return t?hX:iX;if("relu"===e)return t?mX:uX;if("elu"===e)return t?fX:lX;if("relu6"===e)return t?gX:pX;if("prelu"===e)return t?jX:HX;if("leakyrelu"===e)return t?UX:WX;if("sigmoid"===e)return t?yX:dX;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}var QX=class{constructor(e,t,n,r=!1,a=!1,s=!1,i=null,o=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=bq(this.outputShape.length);let u=r?e[1]:e[2],p=Math.ceil(u/2),c=r?"i * 2, rc.y":"rc.y, i * 2",d=a?"rc.z, i * 2":"i * 2, rc.z",h=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],m="",g="";i&&(m=o?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${i}\n        }`:l?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${i}\n        }`:`vec4 activation(vec4 x) {\n          ${i}\n        }`,g="result = activation(result);");let y=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let b="rc.x",x="rc.x";e[0]<t[0]?b=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(x=`imod(rc.x, ${t[0]})`),this.userCode=`\n      ${m}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${p}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${b};\n        int batchB = ${x};\n        for (int i = 0; i < ${p}; i++) {\n          vec4 a = getMatrixA(batchA, ${c});\n          vec4 b = getMatrixB(batchB, ${d});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${h[0]} * ${f[0]});\n          result += (${h[1]} * ${f[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${y}\n\n        ${g}\n\n        setOutput(result);\n      }\n    `}},eJ={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},tJ=class{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Qx.assertAndGetBroadcastShape(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}},nJ="return a * b;";function rJ(e){let t,{inputs:n,backend:r}=e,{a:a,b:s}=n,i=Qx.upcastType(a.dtype,s.dtype);if("complex64"===a.dtype){let e=r.texData.get(a.dataId),t=r.texData.get(s.dataId),n=new tJ(eJ.REAL,a.shape,s.shape),i=new tJ(eJ.IMAG,a.shape,s.shape),o=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:a.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:s.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:s.shape}],l=r.runWebGLProgram(n,o,"float32"),u=r.runWebGLProgram(i,o,"float32"),p=zX({inputs:{real:l,imag:u},backend:r});return r.disposeIntermediateTensorInfo(l),r.disposeIntermediateTensorInfo(u),p}if(r.shouldExecuteOnCPU([a,s])){let e=r.texData.get(a.dataId),t=r.texData.get(s.dataId),[n,o]=bK(a.shape,s.shape,e.values,t.values,i),l=r.makeTensorInfo(o,i),u=r.texData.get(l.dataId);return u.values=n,l}return t=We().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new OX(nJ,a.shape,s.shape):new DX(nJ,a.shape,s.shape),r.runWebGLProgram(t,[a,s],i)}var aJ={kernelName:Vn,backendName:"webgl",kernelFunc:rJ};function sJ(e,t,n){let r=[qH(e.shape),...KH(e.shape)],a={dtype:e.dtype,shape:r,dataId:e.dataId},s=[qH(t),...KH(t)],i=new XK(s,r),o=!0,l=[r],u=n.runWebGLProgram(i,[a],e.dtype,l,o);return{dataId:u.dataId,shape:t,dtype:u.dtype}}function iJ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:s}=r,i=n,o=Sa.sizeFromShape(a.shape),l=Sa.inferFromImplicitShape(s,o),u=Sa.sizeFromShape(l);Sa.assert(o===u,(()=>`The new shape (${l}) has ${u} elements and the old shape (${a.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`));let p=i.texData.get(a.dataId);return!p.isPacked||ZH(a.shape,l)||null!==p.texture&&ZH(p.shape,l)?(i.incRef(a.dataId),{dataId:a.dataId,shape:l,dtype:a.dtype}):sJ(a,l,i)}var oJ={kernelName:pr,backendName:"webgl",kernelFunc:iJ},lJ=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:a,outSize:s}=e;this.outputShape=[r,s];let i=4*Math.floor(n/4),o=n%4,l="sumValue += dot(values, ones);";if(null!=t){let e=1/t;l=`sumValue += dot(values * ${Sa.isInt(e)?e.toPrecision(2):e}, ones);`}let u="";a%n>0&&(u=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${1===o}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${l}\n        } else if (${2===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${l}\n        } else if (${3===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}},uJ=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:a,outSize:s}=e;this.outputShape=[r,s];let i="0.0",o="";"prod"===t?i="1.0":"min"===t?(i="1.0 / 1e-20",o="min"):"max"===t&&(i="-1.0 / 1e-20",o="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?l="sumValue":"prod"===t?l="prodValue":"all"===t?l="allValue":"any"===t&&(l="anyValue");let u=4*Math.floor(n/4),p=n%4,c=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${o}(values, minMaxValue);\n        if (${"min"===t} || ${"max"===t}) {\n          minMaxValue = ${o}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,d="vec4";"all"===t?(i="1.0",c="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",d="bvec4"):"any"===t&&(i="0.0",c="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",d="bvec4");let h="";a%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${i};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${h}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${i});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${c}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===p}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${c}\n        } else if (${2===p}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${c}\n        } else if (${3===p}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${c}\n        }\n        setOutput(${l});\n      }\n    `}};function pJ(e){let t=[];for(;0===t.length||1!==t[t.length-1].outSize;){let n=t.length?t[t.length-1].outSize:e[1],r=Qx.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}function cJ(e,t,n,r){let a=pJ(e.shape),s=e;for(let i=0;i<a.length;i++){let o,l,{inSize:u,windowSize:p,outSize:c}=a[i];o="mean"===n?0===i?new lJ({windowSize:p,inSize:u,batchSize:e.shape[0],outSize:c},u):new lJ({windowSize:p,inSize:u,batchSize:e.shape[0],outSize:c}):new uJ({windowSize:p,inSize:u,batchSize:e.shape[0],outSize:c},n),l=s,s=r.runWebGLProgram(o,[s],t),l.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(l)}return s}var dJ=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[t[s]];this.outputShape=n,this.rank=n.length;let r=uq(this.rank),a=hJ(t);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${a}));\n    }\n    `}};function hJ(e){let t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let a=0;a<e.length;a++)r[e[a]]=n[a];return r.join()}var fJ=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let n=new Array(e.length);for(let u=0;u<n.length;u++)n[u]=e[t[u]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let r=uq(this.rank),a=HK("rc",this.rank),s=new Array(this.rank);for(let u=0;u<t.length;u++)s[t[u]]=a[u];let i=`vec2(${s.slice(-2).join()})`,o=`++${a[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${s.join()}), ${i})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${o}) {\n        result[1] = ${l};\n      }\n      --${a[this.rank-1]};\n      if(++${a[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${l};\n        if(${o}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `}};function mJ(e,t,n){let r=We().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new fJ(e.shape,t):new dJ(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function gJ(e,t,n,r){let a=t,s=e.shape.length,i=Sa.parseAxisParam(a,e.shape),o=i,l=Qx.getAxesPermutation(o,s),u=null!=l,p=e;u&&(p=mJ(e,l,r),o=Qx.getInnerMostAxes(o.length,s)),Qx.assertAxesAreInnerMostDims("sum",o,s);let[c,d]=Qx.computeOutAndReduceShapes(p.shape,o),h=c;n&&(h=Qx.expandShapeToKeepDim(c,i));let f=Sa.sizeFromShape(d),m=Sa.sizeFromShape(e.shape)/f,g=iJ({inputs:{x:p},attrs:{shape:[m,f]},backend:r}),y=Es(e.dtype),b=cJ(g,y,"sum",r),x=iJ({inputs:{x:b},attrs:{shape:h},backend:r});return r.disposeIntermediateTensorInfo(g),r.disposeIntermediateTensorInfo(b),u&&r.disposeIntermediateTensorInfo(p),x}function yJ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;return gJ(a,s,i,n)}var bJ={kernelName:$r,backendName:"webgl",kernelFunc:yJ};function xJ(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{perm:i}=a,o=r,l=s.shape.length,u=new Array(l);for(let p=0;p<u.length;p++)u[p]=s.shape[i[p]];if(o.shouldExecuteOnCPU([s])){let e=o.texData.get(s.dataId).values,n=VK(e,s.shape,s.dtype,i,u);t=o.makeTensorInfo(u,s.dtype);let r=o.texData.get(t.dataId);r.values=n}else t=mJ(s,i,o);return t}var vJ={kernelName:Qr,backendName:"webgl",kernelFunc:xJ},wJ=1e3;function kJ({a:e,b:t,transposeA:n,transposeB:r,backend:a,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}){let u=e.shape.length,p=t.shape.length,c=n?e.shape[u-2]:e.shape[u-1],d=r?t.shape[p-1]:t.shape[p-2],h=n?e.shape[u-1]:e.shape[u-2],f=r?t.shape[p-2]:t.shape[p-1],m=e.shape.slice(0,-2),g=t.shape.slice(0,-2),y=Sa.sizeFromShape(m),b=Sa.sizeFromShape(g),x=bp.assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([h,f]);Sa.assert(c===d,(()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`));let v,w=n?[y,c,h]:[y,h,c],k=r?[b,f,d]:[b,d,f],I=iJ({inputs:{x:e},backend:a,attrs:{shape:w}}),S=iJ({inputs:{x:t},backend:a,attrs:{shape:k}}),N=[I,S],T=Math.max(y,b),_=n?I.shape[1]:I.shape[2],C=null!=s,E=null!=i,A="leakyrelu"===l,$=null!=l?ZX(l,!0):null,R=C||E||A||null!=$;if((1===h||1===f)&&_>wJ&&!1===R){let e=I,t=S;n&&(e=xJ({inputs:{x:I},backend:a,attrs:{perm:[0,2,1]}}),N.push(e)),r&&(t=xJ({inputs:{x:S},backend:a,attrs:{perm:[0,2,1]}}),N.push(t));let s=1!==f,i=1===f,o=e;s&&(o=iJ({inputs:{x:e},backend:a,attrs:{shape:[T,_,1]}}),N.push(o));let l=1===f?2:1,u=t;i&&(u=iJ({inputs:{x:t},backend:a,attrs:{shape:[T,1,_]}}),N.push(u));let p=rJ({inputs:{a:o,b:u},backend:a});v=yJ({inputs:{x:p},backend:a,attrs:{axis:l,keepDims:!0}}),N.push(p)}else{let l=Cs(e.dtype,t.dtype),u=new QX(w,k,[T,h,f],n,r,C,$,E,A),p=[I,S];if(null!=s&&p.push(s),E&&p.push(i),A){let e=a.makeTensorInfo([],"float32",Sa.createScalarValue(o,"float32"));p.push(e),N.push(e)}v=a.runWebGLProgram(u,p,l)}let F=iJ({inputs:{x:v},backend:a,attrs:{shape:x}});N.push(v);for(let D of N)a.disposeIntermediateTensorInfo(D);return F}function IJ(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:p,leakyreluAlpha:c}=r;return kJ({a:a,b:s,transposeA:l,transposeB:u,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:c,activation:p})}var SJ={kernelName:la,backendName:"webgl",kernelFunc:IJ},NJ="return abs(x);";function TJ(e){let t,{inputs:n,backend:r}=e,{x:a}=n;if(r.shouldExecuteOnCPU([a])&&"complex64"!==a.dtype){let e=r.texData.get(a.dataId),t=EK(e.values);return r.makeTensorInfo(a.shape,a.dtype,t)}return t=We().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new bX(a.shape,NJ):new aX(a.shape,NJ),r.runWebGLProgram(t,[a],a.dtype)}var _J={kernelName:Ke,backendName:"webgl",kernelFunc:TJ},CJ=sX+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n",EJ=JX({opSnippet:CJ}),AJ={kernelName:Xe,backendName:"webgl",kernelFunc:EJ},$J=sX+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));",RJ=JX({opSnippet:$J}),FJ={kernelName:Je,backendName:"webgl",kernelFunc:RJ},DJ="return a + b;",MJ=YX({opSnippet:DJ,packedOpSnippet:DJ,supportsComplex:!0,cpuKernelImpl:Yq}),OJ={kernelName:Ye,backendName:"webgl",kernelFunc:MJ},PJ=class{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));let n=[];this.variableNames.forEach((e=>{n.push(`float v${e} = get${e}AtOutCoords();`)}));let r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}},LJ=class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));let n=[];this.variableNames.forEach((e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)}));let r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}};function zJ(e){let{inputs:t,backend:n}=e,r=t;if(1===r.length)return PX({inputs:{x:r[0]},backend:n});if(r.length>We().get("WEBGL_MAX_TEXTURES_IN_SHADER")){let e=Math.floor(r.length/2),t=zJ({inputs:r.slice(0,e),backend:n}),a=zJ({inputs:r.slice(e),backend:n});return zJ({inputs:[t,a],backend:n})}let a=r.map((e=>e.dtype)).reduce(((e,t)=>Cs(e,t))),s=r.map((e=>e.shape)),i=We().getBool("WEBGL_PACK")?new LJ(r[0].shape,s):new PJ(r[0].shape,s);return n.runWebGLProgram(i,r,a)}var BJ={kernelName:Ze,backendName:"webgl",kernelFunc:zJ};function WJ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=Sa.parseAxisParam(s,a.shape),u=l,p=Qx.getAxesPermutation(u,o),c=a;null!=p&&(c=xJ({inputs:{x:a},backend:n,attrs:{perm:p}}),u=Qx.getInnerMostAxes(u.length,o)),Qx.assertAxesAreInnerMostDims("all",u,o);let d,[h,f]=Qx.computeOutAndReduceShapes(c.shape,u),m=Sa.sizeFromShape(f),g=iJ({inputs:{x:c},backend:n,attrs:{shape:[-1,m]}}),y=cJ(g,g.dtype,"all",n);if(i){let e=Qx.expandShapeToKeepDim(h,l);d=iJ({inputs:{x:y},backend:n,attrs:{shape:e}})}else d=iJ({inputs:{x:y},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),null!=p&&n.disposeIntermediateTensorInfo(c),d}var UJ={kernelName:Qe,backendName:"webgl",kernelFunc:WJ};function VJ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=Sa.parseAxisParam(s,a.shape),u=l,p=Qx.getAxesPermutation(u,o),c=a;null!=p&&(c=xJ({inputs:{x:a},backend:n,attrs:{perm:p}}),u=Qx.getInnerMostAxes(u.length,o)),Qx.assertAxesAreInnerMostDims("any",u,o);let d,[h,f]=Qx.computeOutAndReduceShapes(c.shape,u),m=Sa.sizeFromShape(f),g=iJ({inputs:{x:c},backend:n,attrs:{shape:[-1,m]}}),y=cJ(g,g.dtype,"any",n);if(i){let e=Qx.expandShapeToKeepDim(h,l);d=iJ({inputs:{x:y},backend:n,attrs:{shape:e}})}else d=iJ({inputs:{x:y},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),null!=p&&n.disposeIntermediateTensorInfo(c),d}var GJ={kernelName:et,backendName:"webgl",kernelFunc:VJ},HJ=class{constructor(e,t,n){this.variableNames=["A"];let{windowSize:r,batchSize:a,outSize:s}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[a,s];let i="max"===t?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${o};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${i} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}},jJ=class{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,Sa.assert(e.length>2,(()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));let a=e[e.length-1],s=Math.ceil(a/t);this.outputShape=e.slice(0,-1),s>1&&this.outputShape.push(s),r||this.variableNames.push("bestIndicesA");let i,o,l=this.outputShape,u=l.length,p=uq(u),c=jK("coords",u);if(1===s){o=u+1;let e=uq(o);i=`\n        ${e} sourceLocR = ${e}(${c.join()}, 0);\n        ++${c[u-1]};\n        ${e} sourceLocG = ${e}(${c.join()}, 0);\n        ++${c[u-2]};\n        ${e} sourceLocA = ${e}(${c.join()}, 0);\n        --${c[u-1]};\n        ${e} sourceLocB = ${e}(${c.join()}, 0);\n        --${c[u-2]};`}else o=u,i=`\n        ${p} sourceLocR = coords;\n        ++${c[u-1]};\n        ${p} sourceLocG = coords;\n        ++${c[u-2]};\n        ${p} sourceLocA = coords;\n        --${c[u-1]};\n        ${p} sourceLocB = coords;\n        --${c[u-2]};`;let d=["x","y","z","w","u","v"].slice(0,o),h="."+d[o-1],f=d.map((e=>"int "+e)),m=jK("sourceLocR",o-1).concat("inIdx.r"),g=jK("sourceLocG",o-1).concat("inIdx.g"),y=jK("sourceLocB",o-1).concat("inIdx.b"),b=jK("sourceLocA",o-1).concat("inIdx.a"),x="max"===n?"greaterThan":"lessThan",v=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${b.join()})));`,w=`vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${g.join()}) : 0.,\n            hasNextRow ? getAChannel(${y.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,k=r?"":`\n      float getBestIndicesAChannel(${f.join()}) {\n        return getChannel(getBestIndicesA(${d.join()}),\n                                          vec2(${d.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${f.join()}) {\n        return getChannel(getA(${d.join()}),\n                               vec2(${d.slice(-2).join()}));\n      }\n      ${k}\n      void main() {\n        ${p} coords = getOutputCoords();\n        bool hasNextCol = ${c[u-1]} < ${l[u-1]-1};\n        bool hasNextRow = ${c[u-2]} < ${l[u-2]-1};\n        ${i}\n        ivec4 srcIdx = ivec4(sourceLocR${h}, sourceLocG${h},\n          sourceLocB${h}, sourceLocA${h}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${w};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${v}\n          vec4 candidate = ${w};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${x}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}};function qJ(e,t,n,r=null){let a=t.shape[0],s=t.shape[1];null!=r&&(a=r.shape[0],s=r.shape[1]);let i=Qx.computeOptimalWindowSize(s),o={windowSize:i,inSize:s,batchSize:a,outSize:Math.ceil(s/i)},l=new HJ(o,n,null==r),u=[t];null!=r&&u.push(r);let p=e.runWebGLProgram(l,u,"int32");if(1===p.shape[1])return p;let c=qJ(e,t,n,p);return e.disposeIntermediateTensorInfo(p),c}function KJ(e,t,n,r=null){let a=null!=r?r.shape:t.shape,s=a[a.length-1],i=Qx.computeOptimalWindowSize(s),o=new jJ(a,i,n,null==r),l=null==r?[t]:[t,r],u=e.runWebGLProgram(o,l,"int32");if(u.shape.length===t.shape.length){let r=KJ(e,t,n,u);return e.disposeIntermediateTensorInfo(u),r}return u}function XJ(e,t,n,r){let a=[n];if(Qx.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),a,t.shape.length),!We().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let n=[],s=e.texData.get(t.dataId),i=null!==s&&s.isPacked,o=t;i&&(o=e.unpackTensor(t),n.push(o));let[l,u]=Qx.computeOutAndReduceShapes(o.shape,a),p=Sa.sizeFromShape(u),c=iJ({inputs:{x:o},backend:e,attrs:{shape:[-1,p]}});n.push(c);let d=qJ(e,c,r);n.push(d);let h=iJ({inputs:{x:d},backend:e,attrs:{shape:l}});return n.forEach((t=>e.disposeIntermediateTensorInfo(t))),h}return KJ(e,t,r)}function JJ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r,i=Sa.parseAxisParam(s,a.shape),o=Qx.getAxesPermutation(i,a.shape.length),l=a,u=[];null!=o&&(l=xJ({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=Qx.getInnerMostAxes(i.length,l.shape.length)),Qx.assertAxesAreInnerMostDims("argMax",[i[0]],l.shape.length);let p=XJ(n,l,i[0],"max");return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}var YJ={kernelName:tt,backendName:"webgl",kernelFunc:JJ};function ZJ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r,i=Sa.parseAxisParam(s,a.shape),o=Qx.getAxesPermutation(i,a.shape.length),l=a,u=[];null!=o&&(l=xJ({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=Qx.getInnerMostAxes(i.length,l.shape.length)),Qx.assertAxesAreInnerMostDims("argMin",[i[0]],l.shape.length);let p=XJ(n,l,i[0],"min");return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}var QJ={kernelName:nt,backendName:"webgl",kernelFunc:ZJ},eY=sX+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n",tY=JX({opSnippet:eY}),nY={kernelName:rt,backendName:"webgl",kernelFunc:tY},rY=sX+"return log(x + sqrt(x * x + 1.0));",aY=JX({opSnippet:rY}),sY={kernelName:at,backendName:"webgl",kernelFunc:aY},iY=sX+"\n  return atan(x);\n",oY=JX({opSnippet:iY}),lY={kernelName:st,backendName:"webgl",kernelFunc:oY},uY=FX+"\n  return atan(a, b);\n",pY="\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+MX+"\n  return result;\n",cY=YX({opSnippet:uY,packedOpSnippet:pY}),dY={kernelName:ot,backendName:"webgl",kernelFunc:cY},hY=sX+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;",fY=JX({opSnippet:hY}),mY={kernelName:it,backendName:"webgl",kernelFunc:fY},gY=class{constructor(e,t,n,r=!1,a=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");let s=e.filterWidth,i=e.strideHeight,o=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,p=e.effectiveFilterHeight,c=e.effectiveFilterWidth,d=e.padInfo.top,h=e.padInfo.left;this.outputShape=e.outShape;let f="avg"===t,m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`,y="0.0";if(f||(y="-1.0 / 1e-20"),n){let t=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${i}, ${o});\n        const ivec2 pads = ivec2(${d}, ${h});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${p};\n              wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${c};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?a?m:g:`wR * ${c} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let b="max",x=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(x="avgValue / max(count, 1.0)");let v=4*Math.floor(s/4),w=s%4,k=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${b}(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${i}, ${o});\n      const ivec2 pads = ivec2(${d}, ${h});\n      const float initializationValue = ${y};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${y});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${p};\n            wR += ${l}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${v}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${k}\n          }\n\n          int xC = xCCorner + ${v};\n          if (${1===w}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${k}\n          } else if (${2===w}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${k}\n          } else if (${3===w}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${k}\n          }\n        }\n        setOutput(${x});\n      }\n    `}},yY=class{constructor(e,t,n,r=!1,a=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");let s=e.filterWidth,i=e.strideDepth,o=e.strideHeight,l=e.strideWidth,u=e.dilationDepth,p=e.dilationHeight,c=e.dilationWidth,d=e.effectiveFilterDepth,h=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;let b="avg"===t,x="0.0";if(b||(x="-1.0 / 1e-20"),n){let t=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${i}, ${o}, ${l});\n        const ivec3 pads = ivec3(${m}, ${g}, ${y});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${d};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${h};\n                wR += ${p}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${c}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?a?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${h} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let v="max",w=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(w="avgValue / max(count, 1.0)");let k=4*Math.floor(s/4),I=s%4,S=`\n      if (${b}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${v}(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${i}, ${o}, ${l});\n      const ivec3 pads = ivec3(${m}, ${g}, ${y});\n      const float initializationValue = ${x};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${x});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h};\n            wR += ${p}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${k}; wC += 4) {\n              int xC = xCCorner + wC * ${c};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${c}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${c}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${c}, ch)\n              );\n\n              ${S}\n            }\n\n            int xC = xCCorner + ${k};\n            if (${1===I}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${2===I}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${c}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${3===I}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${c}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${c}, ch),\n                initializationValue\n              );\n\n              ${S}\n            }\n          }\n        }\n        setOutput(${w});\n      }\n    `}};function bY(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;cj(a,"avgPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r,u=1;Sa.assert(Qx.eitherStridesOrDilationsAreOne(i,u),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`));let p=Qx.computePool2DInfo(a.shape,s,i,u,o,l);if(1===p.filterWidth&&1===p.filterHeight&&Sa.arraysEqual(p.inShape,p.outShape))return PX({inputs:{x:a},backend:n});let c=new gY(p,"avg",!1);return n.runWebGLProgram(c,[a],"float32")}var xY={kernelName:lt,backendName:"webgl",kernelFunc:bY};function vY(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,p=[1,1,1],c=Qx.computePool3DInfo(a.shape,s,i,p,o,l,u),d=new yY(c,"avg",!1);return n.runWebGLProgram(d,[a],"float32")}var wY={kernelName:pt,backendName:"webgl",kernelFunc:vY},kY=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=o-1-e.padInfo.top,p=l-1-e.padInfo.left,c=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${u}, ${p});\n      const float avgMultiplier = float(${c});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n            wR += ${s}) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${l};\n            wC+= ${i}) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},IY=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,p=e.effectiveFilterDepth,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,h=p-1-e.padInfo.front,f=c-1-e.padInfo.top,m=d-1-e.padInfo.left,g=1/(t*n*r);this.userCode=`\n      const ivec3 pads = ivec3(${h}, ${f}, ${m});\n      const float avgMultiplier = float(${g});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${p};\n            wD += ${o}) {\n          float dyD = float(dyDCorner + wD) / ${a}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${c};\n              wR += ${l}) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${d};\n                wC += ${u}) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};function SY(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s,{filterSize:o,strides:l,pad:u,dimRoundingMode:p}=r,c=[1,1,1],d=Qx.computePool3DInfo(i.shape,o,l,c,u,p),h=new IY(d);return n.runWebGLProgram(h,[a],i.dtype)}var NY={kernelName:ct,backendName:"webgl",kernelFunc:SY};function TY(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s;cj([a,s],"avgPoolGrad");let{filterSize:o,strides:l,pad:u}=r,p=Qx.computePool2DInfo(i.shape,o,l,1,u),c=new kY(p);return n.runWebGLProgram(c,[a],i.dtype)}var _Y={kernelName:ut,backendName:"webgl",kernelFunc:TY};function CY(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:s}=t,{transposeA:i,transposeB:o}=r;return kJ({a:a,b:s,transposeA:i,transposeB:o,backend:n})}var EY={kernelName:dt,backendName:"webgl",kernelFunc:CY},AY=class{constructor(e,t,n,r,a,s){this.outputShape=[],this.variableNames=["x","mean","variance"],Qx.assertAndGetBroadcastShape(e,t),Qx.assertAndGetBroadcastShape(e,n);let i="0.0";null!=r&&(Qx.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="1.0";null!=a&&(Qx.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${i};\n        float scale = ${o};\n        float inv = scale * inversesqrt(variance + float(${s}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}},$Y=class{constructor(e,t,n,r,a,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Qx.assertAndGetBroadcastShape(e,t),Qx.assertAndGetBroadcastShape(e,n);let i="vec4(0.0)";null!=r&&(Qx.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="vec4(1.0)";null!=a&&(Qx.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${i};\n        vec4 scale = ${o};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${s}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}},RY=({inputs:e,backend:t,attrs:n})=>{let{x:r,mean:a,variance:s,offset:i,scale:o}=e;Sa.assert(a.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Sa.assert(null==i||a.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Sa.assert(null==o||a.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:l}=n;null==l&&(l=.001);let u=[r,a,s],p=null;null!=i&&(p=i.shape,u.push(i));let c=null;null!=o&&(c=o.shape,u.push(o));let d=We().getBool("WEBGL_PACK_NORMALIZATION")?new $Y(r.shape,a.shape,s.shape,p,c,l):new AY(r.shape,a.shape,s.shape,p,c,l);return t.runWebGLProgram(d,u,u[0].dtype)},FY={kernelName:rn,backendName:"webgl",kernelFunc:RY},DY=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;let t=uq(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let n,r=OY(this.rank),a=e.map(((e,t)=>`sourceLoc.${MY[t]} = start[${t}] + coords.${MY[t]};`));n=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${a.join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${n}\n        setOutput(getSource(${r}));\n      }\n    `}},MY=["x","y","z","w","u","v"];function OY(e){if(1===e)return"sourceLoc";if(e<=6)return MY.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}var PY=class{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let t=uq(this.rank),n=jK("coords",this.rank),r=jK("sourceLoc",this.rank),a=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,s=`getChannel(getSource(${r.join()}), ${a})`,i=`\n      result.x = ${s};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${s};\n        --${r[this.rank-1]};\n      }\n    `,o=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${s};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${s};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map(((e,t)=>`start[${t}]`)).join()});`:e.map(((e,t)=>`${r[t]} = ${n[t]} + start[${t}];`)).join("\n");this.userCode=`\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${i}\n        ${o}\n        setOutput(result);\n      }\n    `}};function LY(e,t,n,r){let a=r.texData.get(e.dataId),s=r.makeTensorInfo(n,e.dtype),i=r.texData.get(s.dataId);Object.assign(i,a),i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=Tx.computeFlatOffset(t,Sa.computeStrides(e.shape));a.slice&&(o+=a.slice.flatOffset),i.slice={flatOffset:o,origDataId:a.slice&&a.slice.origDataId||e.dataId};let l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),s}function zY(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,size:i}=r,[o,l]=Tx.parseSliceParams(a,s,i);if(Tx.assertParamsValid(a,o,l),0===Sa.sizeFromShape(l))return n.makeTensorInfo(l,a.dtype,[]);if(n.shouldExecuteOnCPU([a])||"string"===a.dtype){let e=n.texData.get(a.dataId),t=AK(e.values,o,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,t)}let{isPacked:u}=n.texData.get(a.dataId),p=Tx.isSliceContinous(a.shape,o,l);if(u||!p){let e=We().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new PY(l):new DY(l),t=[o];return n.runWebGLProgram(e,[a],a.dtype,t)}return n.uploadToGPU(a.dataId),LY(a,o,l,n)}var BY={kernelName:Sr,backendName:"webgl",kernelFunc:zY},WY=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r;Sa.assert(a.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));let o=s.reduce(((e,t)=>e*t)),l=Qx.getReshaped(a.shape,s,o),u=Qx.getPermuted(l.length,s.length),p=Qx.getReshapedPermuted(a.shape,s,o),c=Qx.getSliceBeginCoords(i,s.length),d=Qx.getSliceSize(p,i,s.length),h=[],f=iJ({inputs:{x:a},backend:n,attrs:{shape:l}}),m=xJ({inputs:{x:f},backend:n,attrs:{perm:u}}),g=iJ({inputs:{x:m},backend:n,attrs:{shape:p}}),y=zY({inputs:{x:g},backend:n,attrs:{begin:c,size:d}});return h.push(f),h.push(m),h.push(g),h.forEach((e=>n.disposeIntermediateTensorInfo(e))),y},UY={kernelName:ht,backendName:"webgl",kernelFunc:WY};function VY(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i}=r,o=n.readSync(a.dataId),l=n.readSync(s.dataId),u=Zq(o,l,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,u)}var GY={kernelName:ft,backendName:"webgl",kernelFunc:VY};function HY(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.readSync(r.dataId),i=n.readSync(a.dataId),o=Qx.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}var jY={kernelName:gt,backendName:"webgl",kernelFunc:HY},qY="return float(a != b);",KY=YX({opSnippet:qY,cpuKernelImpl:vK,dtype:"bool"}),XY={kernelName:Hn,backendName:"webgl",kernelFunc:KY};function JY(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.texData.get(r.dataId);return PX({inputs:{x:a.complexTensorInfos.real},backend:n})}var YY={kernelName:or,backendName:"webgl",kernelFunc:JY},ZY="return float(int(x));";function QY(e,t){let n=new aX(e.shape,ZY),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}function eZ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dtype:s}=r;if("complex64"===s){if("complex64"===a.dtype)return PX({inputs:{x:a},backend:n});let e=Od(a.shape),t=eZ({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),r=zX({inputs:{real:t,imag:e},backend:n});return e.dispose(),n.disposeIntermediateTensorInfo(t),r}if("complex64"===a.dtype){let e=JY({inputs:{input:a},backend:n}),t=eZ({inputs:{x:e},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(e),t}if(!Sa.hasEncodingLoss(a.dtype,s)){let e=PX({inputs:{x:a},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:s}}if(n.shouldExecuteOnCPU([a])){let e=n.texData.get(a.dataId).values,[t,r,i]=eK(e,a.shape,a.dtype,s);return n.makeTensorInfo(t,r,i)}if("int32"===s)return QY(a,n);if("bool"===s){let e=n.makeTensorInfo([],"bool",Sa.getTypedArrayFromDType("bool",1)),t=KY({inputs:{a:a,b:e},backend:n});return n.disposeIntermediateTensorInfo(e),t}throw new Error(`Error in Cast: failed to cast ${a.dtype} to ${s}`)}var tZ={kernelName:yt,backendName:"webgl",kernelFunc:eZ},nZ="return ceil(x);",rZ=JX({opSnippet:nZ,packedOpSnippet:nZ,cpuKernelImpl:tK}),aZ={kernelName:bt,backendName:"webgl",kernelFunc:rZ},sZ=class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}},iZ=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}};function oZ(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{clipValueMin:i,clipValueMax:o}=a;t=We().getBool("WEBGL_PACK_CLIP")?new iZ(s.shape):new sZ(s.shape);let l=[[i],[o]];return r.runWebGLProgram(t,[s],s.dtype,l)}var lZ={kernelName:xt,backendName:"webgl",kernelFunc:oZ},uZ=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}};function pZ(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}function cZ(e){let{inputs:t,backend:n}=e,{x:r}=t,a=n.texData.get(r.dataId),s=new uZ(r.shape),i=[pZ(r,a.complexTensorInfos.real),pZ(r,a.complexTensorInfos.imag)];return n.runWebGLProgram(s,i,i[0].dtype)}var dZ={kernelName:wt,backendName:"webgl",kernelFunc:cZ},hZ=class{constructor(e){this.outputShape=[],this.outputShape=Qx.computeOutShape(e,1),this.variableNames=e.map(((e,t)=>`T${t}`));let t=new Array(e.length-1);t[0]=e[0][1];for(let s=1;s<t.length;s++)t[s]=t[s-1]+e[s][1];let n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let s=1;s<t.length;s++){let e=t[s-1];n.push(`else if (yC < ${t[s]}) setOutput(getT${s}(yR, yC-${e}));`)}let r=t.length,a=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${a}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}},fZ=class{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Qx.computeOutShape(e,t);let n=this.outputShape,r=n.length,a=uq(r),s=jK("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map(((e,t)=>`T${t}`));let o=new Array(e.length-1);o[0]=e[0][t];for(let f=1;f<o.length;f++)o[f]=o[f-1]+e[f][t];let l=i[t],u=i.slice(-2),p=i.join(),c=`if (${l} < ${o[0]}) {\n        return getChannel(\n            getT0(${p}), vec2(${u.join()}));\n        }`;for(let f=1;f<o.length;f++){let e=o[f-1];c+=`\n        if (${l} < ${o[f]}  && ${l} >= ${o[f-1]}) {\n          return getChannel(\n            getT${f}(${mZ(i,l,e)}),\n            vec2(${mZ(u,l,e)}));\n        }`}let d=o.length,h=o[o.length-1];c+=`\n        return getChannel(\n          getT${d}(${mZ(i,l,h)}),\n          vec2(${mZ(u,l,h)}));`,this.userCode=`\n      float getValue(${i.map((e=>"int "+e))}) {\n        ${c}\n      }\n\n      void main() {\n        ${a} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${s}), 0., 0., 0.);\n\n        ${s[r-1]} = ${s[r-1]} + 1;\n        if (${s[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${s});\n        }\n\n        ${s[r-2]} = ${s[r-2]} + 1;\n        if (${s[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${s});\n        }\n\n        ${s[r-1]} = ${s[r-1]} - 1;\n        if (${s[r-2]} < ${n[r-2]} &&\n            ${s[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${s});\n        }\n        setOutput(result);\n      }\n    `}};function mZ(e,t,n){let r=e.indexOf(t);return e.map(((e,t)=>t===r?`${e} - ${n}`:e)).join()}function gZ(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.texData.get(r.dataId);return PX({inputs:{x:a.complexTensorInfos.imag},backend:n})}var yZ={kernelName:cn,backendName:"webgl",kernelFunc:gZ};function bZ(e,t,n){let r=e[0].dtype;if("complex64"===r){let r=e.map((e=>JY({inputs:{input:e},backend:n}))),a=e.map((e=>gZ({inputs:{input:e},backend:n}))),s=bZ(r,t,n),i=bZ(a,t,n),o=zX({inputs:{real:s,imag:i},backend:n});return r.forEach((e=>n.disposeIntermediateTensorInfo(e))),a.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),o}let a=n.shouldExecuteOnCPU(e);if("string"===r&&(a=!0),a){let a=e.map((e=>{let r=[-1,Sa.sizeFromShape(e.shape.slice(t))];return iJ({inputs:{x:e},backend:n,attrs:{shape:r}})})),s=a.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),i=Qx.computeOutShape(a.map((e=>e.shape)),1),o=1===a[0].shape[0],l=nK(s,i,r,o),u=Qx.computeOutShape(e.map((e=>e.shape)),t),p=n.makeTensorInfo(u,r,l);return a.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}let s=e.filter((e=>Sa.sizeFromShape(e.shape)>0)),i=We().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(1===s.length){let t=i?new aX(e[0].shape,cX):new bX(e[0].shape,cX);return n.runWebGLProgram(t,e,r)}let o=We().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>o){let e=[];for(let a=0;a<s.length;a+=o){let r=s.slice(a,a+o);e.push(bZ(r,t,n))}let r=bZ(e,t,n);for(let t of e)n.disposeIntermediateTensorInfo(t);return r}if(i){let e=new fZ(s.map((e=>e.shape)),t);return n.runWebGLProgram(e,s,r)}let{tensors2D:l,outShape:u}=xZ(s,t,n),p=new hZ(l.map((e=>e.shape))),c=n.runWebGLProgram(p,l,r);l.forEach((e=>n.disposeIntermediateTensorInfo(e)));let d=iJ({inputs:{x:c},attrs:{shape:u},backend:n});return n.disposeIntermediateTensorInfo(c),d}function xZ(e,t,n){let r=Qx.computeOutShape(e.map((e=>e.shape)),t);return{tensors2D:e.map((e=>iJ({inputs:{x:e},attrs:{shape:[-1,Sa.sizeFromShape(e.shape.slice(t))]},backend:n}))),outShape:r}}function vZ(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,s=Sa.parseAxisParam(a,t[0].shape)[0],i=t.map((e=>e.shape));Qx.assertParamsConsistent(i,s);let o=Qx.computeOutShape(t.map((e=>e.shape)),s);if(0===Sa.sizeFromShape(o))return n.makeTensorInfo(o,t[0].dtype,[]);let l=t.filter((e=>Sa.sizeFromShape(e.shape)>0));return 1===l.length?PX({inputs:{x:l[0]},backend:n}):bZ(l,s,n)}var wZ={kernelName:kt,backendName:"webgl",kernelFunc:vZ},kZ=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;let s=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,p=e.dilationWidth,c=e.filterHeight,d=e.filterWidth,h=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,y=m?2:3,b=m?3:1,x="",v="";n&&(x=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,v="result = activation(result);");let w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${x}\n\n      const ivec2 strides = ivec2(${o}, ${l});\n      const ivec2 pads = ivec2(${s}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${b}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${y}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${c}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${d}; wC++) {\n            int xC = xCCorner + wC * ${p};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${h}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${h}) *\n                    getW(wR, wC, ${h}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${h}, xR, xC) *\n                    getW(wR, wC, ${h}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${h}, d2),\n                getW(wR, wC, ${h} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${h}),\n                  getX(batch, xR, xC, ${h} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${h}, xR, xC),\n                  getX(batch, ${h} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${h}, d2),\n                getW(wR, wC, ${h} + 1, d2),\n                getW(wR, wC, ${h} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${h}),\n                  getX(batch, xR, xC, ${h} + 1),\n                  getX(batch, xR, xC, ${h} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${h}, xR, xC),\n                  getX(batch, ${h} + 1, xR, xC),\n                  getX(batch, ${h} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${w}\n        ${v}\n        setOutput(result);\n      }\n    `}},IZ=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,p=e.filterDepth,c=e.filterHeight,d=e.filterWidth,h=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${a}, ${s}, ${i});\n      const ivec3 pads = ivec3(${t}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${p}; wF++) {\n          int xF = xFCorner + wF * ${o};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${c}; wR++) {\n            int xR = xRCorner + wR * ${l};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${h}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${h}) *\n                  getW(wF, wR, wC, ${h}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${h}),\n                  getX(batch, xF, xR, xC, ${h} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${h}, d2),\n                  getW(wF, wR, wC, ${h} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${h}),\n                  getX(batch, xF, xR, xC, ${h} + 1),\n                  getX(batch, xF, xR, xC, ${h} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${h}, d2),\n                  getW(wF, wR, wC, ${h} + 1, d2),\n                  getW(wF, wR, wC, ${h} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},SZ=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=bq(this.outputShape.length);let s=e.padInfo.left,i=e.strideWidth,o=e.dilationWidth,l=e.filterHeight,u=e.filterWidth,p=u,c="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let m=0;m<u;m++)c+=`\n           vec4 xTexelC${2*m};\n           int xTexelC${2*m}Ready;\n           vec4 xTexelC${2*m+1};\n           int xTexelC${2*m+1}Ready;\n           vec4 xC${m};`;c+=`\n     for (int r = 0; r < ${l}; r++) {\n      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {\n       `;for(let m=0;m<u;m++)c+=`\n           xTexelC${2*m} = vec4(0.0);\n           xTexelC${2*m}Ready = 0;\n           xTexelC${2*m+1} = vec4(0.0);\n           xTexelC${2*m+1}Ready = 0;\n           xC${m} = vec4(0.0);`;c+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let m=0;m<(p+1)/2;m++){let t=2*m;if(c+=`\n           xC = xCCorner + ${t*o};\n           `,1===i){if(t<u&&(s%2===1?(c+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n               `,c+=1===o&&t>0?`\n                 xC${t} = vec4(xTexelC${t-2}.zw, xTexelC${t}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${t} = vec4(previous.zw, xTexelC${t}.xy);\n                   } else {\n                     xC${t} = vec4(0.0, 0.0, xTexelC${t}.xy);\n                   }\n                   `):c+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 xC${t} = xTexelC${t};\n                 `,t+1<u)){let e=s%2===0?Sa.nearestLargerEven(o):o;o%2===0&&s%2===1||o%2!==0&&s%2!==1?(c+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                     xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${t+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${t+1}Ready = 1;\n                   }\n                   `,c+=o>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${t+1} = vec4(previous.zw, xTexelC${t+1}.xy);\n                     } else {\n                      xC${t+1} = vec4(0.0, 0.0, xTexelC${t+1}.xy);\n                     }\n                     `:`\n                     xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.xy);\n                     `):c+=1===e?`\n                     xC${t+1} = xTexelC${t};\n                     `:`\n                     xCOffset = xC + ${e};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                       xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${t+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${t+1}Ready = 1;\n                     }\n\n                     xC${t+1} = xTexelC${t+1};\n                     `}}else t<u&&(s%2===1?(c+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${t+1}Ready == 0) {\n                   xTexelC${t+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${t+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${t+1}Ready = 1;\n                 }\n\n                 xC${t} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n               `,t+1<u&&(c+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${t+1} = vec4(xTexelC${t+1}.xy, final.xy);\n                 `)):(c+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                   xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t+1}.zw = vec2(0.);\n                   }\n                   xTexelC${t+1}Ready = 1;\n                 }\n\n                 xC${t} = vec4(\n                   xTexelC${t}.xy, xTexelC${t+1}.xy);\n               `,t+1<u&&(c+=`\n                   xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n                 `)));t<u&&(c+=`\n             wTexel = getW(r, ${t}, d1, d2);\n             dotProd += xC${t}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${e.inChannels}) {\n               dotProd += xC${t}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,t+1<u&&(c+=`\n               wTexel = getW(r, ${t+1}, d1, d2);\n               dotProd += xC${t+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${e.inChannels}) {\n                 dotProd += xC${t+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}c+="\n     }\n   ",c+="\n     }\n   ",c+="\n     }\n   ";let d="",h="";n&&(d=r?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${n}\n         }`:a?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${n}\n         }`:`vec4 activation(vec4 x) {\n           ${n}\n         }`,h="result = activation(result);");let f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${d}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${c}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${f}\n         ${h}\n         setOutput(result);\n       }\n     `}},NZ=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=bq(this.outputShape.length);let{dataFormat:n}=t,r=hj(),a="channelsLast"===n,s=a?1:2,i=a?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`,l="";for(let u=0;u<=1;u++)for(let e=0;e<=1;e++)l+=`\n          blockIndex = rc.z + ${e};\n          pos = rc.y + ${u};\n\n          ${o}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${s}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${i}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${a}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*u+e}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*u+e}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${l}\n\n        ${r.output} = result;\n      }\n    `}};function TZ(e,t){let n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function _Z({x:e,filter:t,convInfo:n,backend:r,bias:a=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:o=null}){let l,u=e.shape,p=r.texData.get(e.dataId),c=n.inChannels,d=u[0]*u[1]*u[2],h=n.outChannels,f="channelsLast"===n.dataFormat,m=!1,g=!1,y=[];if(null!=s){let e=TZ(s.shape,f);null!=e&&(s=iJ({inputs:{x:s},backend:r,attrs:{shape:e}}),y.push(s))}if(null!=a){let e=TZ(a.shape,f);null!=e&&(a=iJ({inputs:{x:a},backend:r,attrs:{shape:e}}),y.push(a))}if((1!==d&&1!==h||!(c>wJ))&&p.isPacked&&f&&null!=p.texture&&u[2]%2!==0&&Sa.arraysEqual(p.shape.slice(-3),u.slice(-3))){let c=u[0]*u[1]*(u[2]+1),d={dataId:e.dataId,shape:[1,c,n.inChannels],dtype:e.dtype},h=p.shape;p.shape=p.shape.slice(),p.shape[p.shape.length-2]++,Sa.assert(ZH(p.shape,d.shape),(()=>`packed reshape ${p.shape} to ${d.shape} isn't free`));let f=iJ({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});y.push(f);let b=kJ({a:d,b:f,backend:r,transposeA:m,transposeB:g,bias:a,activation:o,preluActivationWeights:s,leakyreluAlpha:i}),x=r.texData.get(b.dataId);Sa.assert(x.isPacked,(()=>"batchMatMul result is expected to be packed")),p.shape=h,x.shape=n.outShape,l=PX({inputs:{x:b},backend:r}),l.shape=n.outShape,y.push(b)}else{let u=n.outHeight*n.outWidth,p=iJ({inputs:{x:e},backend:r,attrs:{shape:f?[n.batchSize,u,n.inChannels]:[n.batchSize,n.inChannels,u]}}),c=iJ({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),d=kJ({a:f?p:c,b:f?c:p,transposeA:!f,transposeB:g,backend:r,bias:a,activation:o,preluActivationWeights:s,leakyreluAlpha:i});l=iJ({inputs:{x:d},backend:r,attrs:{shape:n.outShape}}),y.push(p),y.push(c),y.push(d)}for(let b of y)r.disposeIntermediateTensorInfo(b);return l}function CZ({x:e,filter:t,convInfo:n,backend:r,bias:a=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:o=null}){let{filterWidth:l,filterHeight:u,inChannels:p,outWidth:c,outHeight:d,dataFormat:h}=n,f="channelsLast"===h,m=l*u*p,g=d*c,y=[n.batchSize,m,g],b=!0,x=!1,v=[];if(null!=s){let e=TZ(s.shape,f);null!=e&&(s=iJ({inputs:{x:s},backend:r,attrs:{shape:e}}),v.push(s))}if(null!=a){let e=TZ(a.shape,f);null!=e&&(a=iJ({inputs:{x:a},backend:r,attrs:{shape:e}}),v.push(a))}let w=iJ({inputs:{x:t},backend:r,attrs:{shape:[1,m,Sa.sizeFromShape(t.shape)/m]}});v.push(w);let k=new NZ(y,n),I=[e.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],S=r.runWebGLProgram(k,[e],"float32",I),N=iJ({inputs:{x:S},backend:r,attrs:{shape:y}});v.push(S),v.push(N);let T=null!=a,_=null!=s,C="leakyrelu"===o,E=o?ZX(o,!0):null,A=new QX(f?N.shape:w.shape,f?w.shape:N.shape,f?[n.batchSize,g,n.outChannels]:[n.batchSize,n.outChannels,g],b,x,T,E,_,C),$=f?[N,w]:[w,N];if(a&&$.push(a),_&&$.push(s),C){let e=r.makeTensorInfo([],"float32",Sa.createScalarValue(i,"float32"));$.push(e),v.push(e)}let R=r.runWebGLProgram(A,$,"float32"),F=iJ({inputs:{x:R},backend:r,attrs:{shape:n.outShape}});v.push(R);for(let D of v)r.disposeIntermediateTensorInfo(D);return F}function EZ(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s,filter:i}=n,{strides:o,pad:l,dataFormat:u,dilations:p,dimRoundingMode:c}=a,d=Qx.convertConv2DDataFormat(u),h=Qx.computeConv2DInfo(s.shape,i.shape,o,p,l,c,!1,d);if(1!==h.filterHeight||1!==h.filterWidth||1!==h.dilationHeight||1!==h.dilationWidth||1!==h.strideHeight||1!==h.strideWidth||"SAME"!==h.padInfo.type&&"VALID"!==h.padInfo.type)if(h.strideWidth<=2&&"channelsLast"===d&&We().getBool("WEBGL_EXP_CONV")){let e=new SZ(h),n=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];t=r.runWebGLProgram(e,[s,i],"float32",n)}else if(We().getBool("WEBGL_CONV_IM2COL"))t=CZ({x:s,filter:i,convInfo:h,backend:r});else{let e=new kZ(h);t=r.runWebGLProgram(e,[s,i],"float32")}else t=_Z({x:s,filter:i,convInfo:h,backend:r});let f=iJ({inputs:{x:t},backend:r,attrs:{shape:h.outShape}});return r.disposeIntermediateTensorInfo(t),f}var AZ={kernelName:It,backendName:"webgl",kernelFunc:EZ},$Z=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,s="channelsLast"===e.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${a};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              ${s?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},RZ=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s="channelsLast"===e.dataFormat,i=t-1-e.padInfo.top,o=n-1-e.padInfo.left,l=s?1:2,u=s?2:3,p=s?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${p}];\n\n        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${s}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},FZ=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.padInfo.front,s=e.padInfo.top,i=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${a};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${s};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${r} - ${i};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},DZ=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.front,l=n-1-e.padInfo.top,u=r-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${o}, ${l}, ${u});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${a}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};function MZ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:p}=r,c=Qx.convertConv2DDataFormat(l),d=Qx.computeConv2DInfo(a.shape,p,i,1,o,u,!1,c),h=new $Z(d);return n.runWebGLProgram(h,[a,s],"float32")}var OZ={kernelName:St,backendName:"webgl",kernelFunc:MZ},PZ=class{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=bq(this.outputShape.length);let t=e.filterHeight,n=e.filterWidth,r=t-1-e.padInfo.top,a=n-1-e.padInfo.left;this.userCode=`\n      const ivec2 pads = ivec2(${r}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            int wCPerm = ${n} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}};function LZ(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:p}=r,c=Qx.convertConv2DDataFormat(u),d=Qx.computeConv2DInfo(i,s.shape,o,1,l,p,!1,c);if(We().getBool("WEBGL_PACK")&&"channelsLast"===c){let e=[[d.strideHeight,d.strideWidth]],t=new PZ(d);return n.runWebGLProgram(t,[a,s],"float32",e)}{let e=new RZ(d);return n.runWebGLProgram(e,[a,s],"float32")}}var zZ={kernelName:Nt,backendName:"webgl",kernelFunc:LZ};function BZ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r,u=Qx.computeConv3DInfo(a.shape,s.shape,i,l,o),p=new IZ(u);return n.runWebGLProgram(p,[a,s],"float32")}var WZ={kernelName:Tt,backendName:"webgl",kernelFunc:BZ};function UZ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=r,u=Qx.computeConv3DInfo(a.shape,l,i,1,o),p=new FZ(u);return n.runWebGLProgram(p,[a,s],"float32")}var VZ={kernelName:_t,backendName:"webgl",kernelFunc:UZ};function GZ(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=r,u=Qx.computeConv3DInfo(l,s.shape,o,1,i),p=new DZ(u);return n.runWebGLProgram(p,[a,s],"float32")}var HZ,jZ={kernelName:Ct,backendName:"webgl",kernelFunc:GZ},qZ=XX+"\n  return cos(x);\n",KZ=`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${MX}\n  return result;\n`,XZ=JX({opSnippet:qZ,packedOpSnippet:KZ}),JZ={kernelName:Et,backendName:"webgl",kernelFunc:XZ},YZ="\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n",ZZ=JX({opSnippet:YZ}),QZ={kernelName:At,backendName:"webgl",kernelFunc:ZZ},eQ=class{constructor(e,t,n,r,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[s,i,o,l]=e,[u]=t,[p,c]=n;this.outputShape=[u,p,c,l];let d="bilinear"===r?1:0,[h,f]=[i-1+".0",o-1+".0"],[m,g,y]=p>1?[""+(i-1)/(p-1),"(y2-y1) * height_ratio",`y1*${h} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${h}`],[b,x,v]=c>1?[""+(o-1)/(c-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${b});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${s}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${x};\n\n        float in_y = ${y};\n        if( in_y < 0.0 || in_y > ${h} ) {\n          setOutput(float(${a}));\n          return;\n        }\n        float in_x = ${v};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${a}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${d} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}},tQ=e=>{let{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,p=new eQ(a.shape,s.shape,o,l,u);return n.runWebGLProgram(p,[a,s,i],"float32")},nQ={kernelName:Ft,backendName:"webgl",kernelFunc:tQ};(function(e){e.Prod="*",e.Sum="+"})(HZ||(HZ={}));var rQ=class{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];let a=this.outputShape.length,s=this.op===HZ.Prod?"1.0":"0.0",i=n?s:`getX(${aQ(a,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1],l="",u="";n?(l=r?"end != "+(o-1):"end != 0",u=r?"end + 1":"end - 1"):(l=r?`end + pow2 < ${o}`:"end >= pow2",u=r?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${uq(a)} coords = getOutputCoords();\n        int end = ${sQ(a,"coords",this.op)};\n        float val = ${i};\n        int pow2 = int(pow(2.0, index));\n        if (${l}) {\n          int idx = ${u};\n          ${sQ(a,"coords",this.op)} = idx;\n          val ${this.op}= getX(${aQ(a,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}};function aQ(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function sQ(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function iQ(e,t,n,r,a,s){let i=t.shape.length,o=Qx.getAxesPermutation([r],i),l=t;null!=o&&(l=xJ({inputs:{x:t},backend:n,attrs:{perm:o}}));let u=Qx.getInnerMostAxes(1,i)[0];if(u!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);let p=l.shape[u],c=PX({inputs:{x:l},backend:n});for(let d=0;d<=Math.ceil(Math.log2(p))-1;d++){let t=new rQ(e,l.shape,!1,s),r=[[d]],a=c;c=n.runWebGLProgram(t,[c],c.dtype,r),n.disposeIntermediateTensorInfo(a)}if(a){let t=new rQ(e,l.shape,a,s),r=c;c=n.runWebGLProgram(t,[c],c.dtype),n.disposeIntermediateTensorInfo(r)}if(null!=o){let e=Qx.getUndoAxesPermutation(o),t=xJ({inputs:{x:c},backend:n,attrs:{perm:e}});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(l),t}return c}function oQ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;return iQ(HZ.Prod,a,n,s,i,o)}var lQ={kernelName:$t,backendName:"webgl",kernelFunc:oQ};function uQ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;return iQ(HZ.Sum,a,n,s,i,o)}var pQ={kernelName:Rt,backendName:"webgl",kernelFunc:uQ};function cQ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i,binaryOutput:o}=r;if(1===a.shape.length){let e=n.readSync(a.dataId),t=n.readSync(s.dataId),r=Zq(e,t,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,r)}if(2===a.shape.length){let e=n.bufferSync(a),t=n.bufferSync(s),r=Qq(e,t,i,o);return n.makeTensorInfo(r.shape,s.dtype,r.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}var dQ={kernelName:Dt,backendName:"webgl",kernelFunc:cQ},hQ=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function fQ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:s,dataFormat:i}=r,o=a.shape[0],l="NHWC"===i?a.shape[1]:a.shape[2],u="NHWC"===i?a.shape[2]:a.shape[3],p="NHWC"===i?a.shape[3]:a.shape[1],c=l*s,d=u*s,h=p/(s*s),f="NHWC"===i?[o,c,d,h]:[o,h,c,d],m=new hQ(f,s,i);return n.runWebGLProgram(m,[a],a.dtype)}var mQ={kernelName:Mt,backendName:"webgl",kernelFunc:fQ},gQ=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=bq(this.outputShape.length);let s=e.filterHeight,i=e.filterWidth,o=e.outChannels/e.inChannels,l="",u="";n&&(l=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,u="result = activation(result);");let p=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${l}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${o};\n        int q = d2 - d1 * ${o};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${s}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${p}\n        ${u}\n        setOutput(result);\n      }\n    `}},yQ=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=bq(this.outputShape.length);let s=e.outChannels/e.inChannels,i=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,p=e.filterWidth,c=p,d="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let g=0;g<p;g++)d+=`\n          vec4 xTexelC${2*g};\n          int xTexelC${2*g}Ready;\n          vec4 xTexelC${2*g+1};\n          int xTexelC${2*g+1}Ready;\n          vec4 xC${g};`;d+=`\n    for (int r = 0; r < ${u}; r++) {\n      `;for(let g=0;g<p;g++)d+=`\n          xTexelC${2*g} = vec4(0.0);\n          xTexelC${2*g}Ready = 0;\n          xTexelC${2*g+1} = vec4(0.0);\n          xTexelC${2*g+1}Ready = 0;\n          xC${g} = vec4(0.0);`;d+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let g=0;g<(c+1)/2;g++){let e=2*g;if(d+=`\n          xC = xCCorner + ${e*l};\n          `,1===o){if(e<p&&(i%2===1?(d+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n              `,d+=1===l&&e>0?`\n                xC${e} = vec4(xTexelC${e-2}.zw, xTexelC${e}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${e} = vec4(previous.zw, xTexelC${e}.xy);\n                  } else {\n                    xC${e} = vec4(0.0, 0.0, xTexelC${e}.xy);\n                  }\n                  `):d+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xC${e} = xTexelC${e};\n                `,e+1<p)){let t=i%2===0?Sa.nearestLargerEven(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(d+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${t};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                    xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${e+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${e+1}Ready = 1;\n                  }\n                  `,d+=l>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${e+1} = vec4(previous.zw, xTexelC${e+1}.xy);\n                    } else {\n                     xC${e+1} = vec4(0.0, 0.0, xTexelC${e+1}.xy);\n                    }\n                    `:`\n                    xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.xy);\n                    `):d+=1===t?`\n                    xC${e+1} = xTexelC${e};\n                    `:`\n                    xCOffset = xC + ${t};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                      xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${e+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${e+1}Ready = 1;\n                    }\n\n                    xC${e+1} = xTexelC${e+1};\n                    `}}else e<p&&(i%2===1?(d+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n              `,e+1<p&&(d+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${e+1} = vec4(xTexelC${e+1}.xy, final.xy);\n                `)):(d+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(\n                  xTexelC${e}.xy, xTexelC${e+1}.xy);\n              `,e+1<p&&(d+=`\n                  xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n                `)));e<p&&(d+=`\n            wTexel = getW(r, ${e}, d1, q);\n            dotProd += xC${e} * vec4(wTexel.xz, wTexel.xz);\n          `,e+1<p&&(d+=`\n              wTexel = getW(r, ${e+1}, d1, q);\n              dotProd += xC${e+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}d+="\n    }\n  ",d+="\n      }\n    ";let h="",f="";n&&(h=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,f="result = activation(result);");let m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${h}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${s};\n        int q = d2 - d1 * ${s};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${d}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${m}\n        ${f}\n        setOutput(result);\n      }\n    `}};function bQ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r,p=l;null==p&&(p=[1,1]),Sa.assert(Qx.eitherStridesOrDilationsAreOne(i,p),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${p}'`));let c,d=Qx.computeConv2DInfo(a.shape,s.shape,i,p,o,u,!0);c=We().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels===1?new yQ(d):new gQ(d);let h=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return n.runWebGLProgram(c,[a,s],"float32",h)}var xQ={kernelName:Ot,backendName:"webgl",kernelFunc:bQ},vQ=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${s} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${a};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},wQ=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=t-1-e.padInfo.top,i=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${s}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${o}; dm++) {\n              int d2 = d1 * ${o} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};function kQ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:p}=r,c=Qx.computeConv2DInfo(a.shape,p,i,o,l,u,!0),d=new vQ(c);return n.runWebGLProgram(d,[a,s],"float32")}var IQ={kernelName:Pt,backendName:"webgl",kernelFunc:kQ};function SQ(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:p}=r,c=Qx.computeConv2DInfo(p,s.shape,i,o,l,u,!0),d=new wQ(c);return n.runWebGLProgram(d,[a,s],"float32")}var NQ={kernelName:Lt,backendName:"webgl",kernelFunc:SQ},TQ=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}};function _Q(e){let{inputs:t,backend:n}=e,{x:r}=t,a=[...r.shape,...r.shape],s=Sa.sizeFromShape(r.shape),i=iJ({inputs:{x:r},backend:n,attrs:{shape:[s]}}),o=new TQ(s),l=n.runWebGLProgram(o,[i],i.dtype),u=iJ({inputs:{x:l},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),u}var CQ={kernelName:zt,backendName:"webgl",kernelFunc:_Q},EQ=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let{inHeight:t,inWidth:n,padInfo:r,strideHeight:a,strideWidth:s,filterHeight:i,filterWidth:o,dilationHeight:l,dilationWidth:u}=e,{top:p,left:c}=r;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${s});\n      const ivec2 pads = ivec2(${p}, ${c});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${i}; h++) {\n          int hIn = hBeg + h * ${l};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${o}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}};function AQ(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s,filter:i}=n,{strides:o,pad:l,dilations:u}=a,p=Qx.computeDilation2DInfo(s.shape,i.shape,o,l,"NHWC",u),c=new EQ(p);t=r.runWebGLProgram(c,[s,i],"float32");let d=iJ({inputs:{x:t},backend:r,attrs:{shape:p.outShape}});return r.disposeIntermediateTensorInfo(t),d}var $Q={kernelName:Bt,backendName:"webgl",kernelFunc:AQ};function RQ(e){let{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,s=t,{allDims:i,summedDims:o,idDims:l}=Qx.decodeEinsumEquation(a,s.length);Qx.checkEinsumDimSizes(i.length,l,s);let{path:u,steps:p}=Qx.getEinsumComputePath(o,l),c=p.length,d=null,h=i.length,f=[];for(let m=0;m<c;++m){for(let e of p[m]){let t,{permutationIndices:r,expandDims:a}=Qx.getEinsumPermutation(h,l[e]);Qx.isIdentityPermutation(r)?t=s[e]:(t=xJ({inputs:{x:s[e]},backend:n,attrs:{perm:r}}),f.push(t));let i=t.shape.slice();for(let e=0;e<a.length;++e)i.splice(a[e],0,1);Sa.arraysEqual(t.shape,i)||(t=iJ({inputs:{x:t},backend:n,attrs:{shape:i}}),f.push(t)),null===d?d=t:(d=rJ({inputs:{a:t,b:d},backend:n}),f.push(d))}m<c-1&&(u[m]>=0&&(d=yJ({inputs:{x:d},backend:n,attrs:{axis:u[m]-(i.length-h),keepDims:!1}}),f.push(d)),h--)}for(let m of f)m!==d&&n.disposeIntermediateTensorInfo(m);return d}var FQ={kernelName:Gt,backendName:"webgl",kernelFunc:RQ},DQ="return (x >= 0.0) ? x : (exp(x) - 1.0);",MQ="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",OQ=JX({opSnippet:DQ,packedOpSnippet:MQ}),PQ={kernelName:Ht,backendName:"webgl",kernelFunc:OQ},LQ="return (b >= 0.0) ? a : a * (b + 1.0);",zQ="\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",BQ=e=>{let{inputs:t,backend:n}=e,{dy:r,y:a}=t,s=We().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new OX(zQ,r.shape,a.shape):new DX(LQ,r.shape,a.shape);return n.runWebGLProgram(s,[r,a],r.dtype)},WQ={kernelName:jt,backendName:"webgl",kernelFunc:BQ},UQ="\n  return vec4(equal(a, b));\n",VQ="return float(a == b);",GQ=YX({opSnippet:VQ,packedOpSnippet:UQ,dtype:"bool",cpuKernelImpl:rK}),HQ={kernelName:Kt,backendName:"webgl",kernelFunc:GQ},jQ=`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${Qx.ERF_P};\n  float a1 = ${Qx.ERF_A1};\n  float a2 = ${Qx.ERF_A2};\n  float a3 = ${Qx.ERF_A3};\n  float a4 = ${Qx.ERF_A4};\n  float a5 = ${Qx.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`,qQ=JX({opSnippet:jQ}),KQ={kernelName:qt,backendName:"webgl",kernelFunc:qQ},XQ=XX+"\n  return exp(x);\n",JQ="\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",YQ=JX({opSnippet:XQ,packedOpSnippet:JQ,cpuKernelImpl:aK,dtype:"float32"}),ZQ={kernelName:Xt,backendName:"webgl",kernelFunc:YQ};function QQ(e){let{inputs:t,attrs:n,backend:r}=e,{dim:a}=n,{input:s}=t,i=s.shape.length,o=s.shape.slice(),l=a;return a<0&&(Sa.assert(-(i+1)<=a,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),l=i+a+1),o.splice(l,0,1),iJ({inputs:{x:s},backend:r,attrs:{shape:o}})}var e0={kernelName:Jt,backendName:"webgl",kernelFunc:QQ},t0="return exp(x) - 1.0;",n0=JX({opSnippet:t0,packedOpSnippet:t0,cpuKernelImpl:sK}),r0={kernelName:Yt,backendName:"webgl",kernelFunc:n0},a0=class{constructor(e,t,n){this.variableNames=["real","imag"];let r=t[1];this.outputShape=t;let a,s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=n?`${r}.0`:"1.0";if("real"===e)a="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);a="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${s};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${a}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${i};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}};function s0(e,t,n){let r=n.texData.get(e.dataId),a=Sa.sizeFromShape(e.shape),s=e.shape[e.shape.length-1],i=a/s,o=iJ({inputs:{x:e},backend:n,attrs:{shape:[i,s]}}),l=o.shape,u=new a0("real",l,t),p=new a0("imag",l,t),c=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],d=n.runWebGLProgram(u,c,"float32"),h=n.runWebGLProgram(p,c,"float32"),f=zX({inputs:{real:d,imag:h},backend:n});n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h);let m=iJ({inputs:{x:f},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(f),m}function i0(e){let{inputs:t,backend:n}=e,{input:r}=t;return s0(r,!1,n)}var o0={kernelName:Zt,backendName:"webgl",kernelFunc:i0},l0=class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}};function u0(e){let{backend:t,attrs:n}=e,{shape:r,value:a}=n,{dtype:s}=n;if(s=s||Sa.inferDtype(a),"string"===s){let e=Sa.getArrayFromDType(s,Sa.sizeFromShape(r));return e.fill(a),t.makeTensorInfo(r,s,e)}{let e=new l0(r,a),n=[[a]];return t.runWebGLProgram(e,[],s,n)}}var p0,c0={kernelName:Qt,backendName:"webgl",kernelFunc:u0},d0=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];let t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}},h0={kernelName:en,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{let{image:n}=e,r=t,a=new d0(n.shape);return r.runWebGLProgram(a,[n],n.dtype)}},f0="return floor(x);",m0=JX({opSnippet:f0,packedOpSnippet:f0,cpuKernelImpl:iK}),g0={kernelName:tn,backendName:"webgl",kernelFunc:m0},y0="\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",b0="\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",x0=YX({opSnippet:y0,packedOpSnippet:b0,dtype:"int32"}),v0={kernelName:nn,backendName:"webgl",kernelFunc:x0},w0=class{constructor(e){this.variableNames=["A"];let t=hj(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}},k0=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let t=hj(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}},I0={kernelName:ia,backendName:"webgl",kernelFunc:N0},S0=We().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function N0(e){let{inputs:t,backend:n,attrs:r}=e,{pixels:a}=t,{numChannels:s}=r,i="undefined"!=typeof HTMLVideoElement&&a instanceof HTMLVideoElement,o="undefined"!=typeof HTMLImageElement&&a instanceof HTMLImageElement,[l,u]=i?[a.videoWidth,a.videoHeight]:[a.width,a.height],p=[u,l],c=[u,l,s];if(o||i){let e=We().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(null==p0||e!==S0)&&(S0=e,p0=document.createElement("canvas").getContext("2d",{willReadFrequently:S0})),p0.canvas.width=l,p0.canvas.height=u,p0.drawImage(a,0,0,l,u),a=p0.canvas}let d=n.makeTensorInfo(p,"int32");n.texData.get(d.dataId).usage=ZG.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),a);let h=We().getBool("WEBGL_PACK")?new k0(c):new w0(c),f=n.runWebGLProgram(h,[d],"int32");return n.disposeData(d.dataId),f}function T0(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s,filter:i,bias:o,preluActivationWeights:l}=n,{strides:u,pad:p,dataFormat:c,dilations:d,dimRoundingMode:h,activation:f,leakyreluAlpha:m}=a,g=Qx.convertConv2DDataFormat(c),y=Qx.computeConv2DInfo(s.shape,i.shape,u,d,p,h,!1,g),b=[],x=null!=o,v=null!=l,w="leakyrelu"===f,k=()=>{let e=[s,i],t=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){let t=iJ({inputs:{x:e},backend:r,attrs:{shape:[e.shape[0],1,1]}});return b.push(t),t}return e};if(x&&e.push(t(o,c)),v&&e.push(t(l,c)),w){let t=r.makeTensorInfo([],"float32",Sa.createScalarValue(m,"float32"));e.push(t),b.push(t)}return e};if(1!==y.filterHeight||1!==y.filterWidth||1!==y.dilationHeight||1!==y.dilationWidth||1!==y.strideHeight||1!==y.strideWidth||"SAME"!==y.padInfo.type&&"VALID"!==y.padInfo.type)if(y.strideWidth<=2&&"channelsLast"===g&&We().getBool("WEBGL_EXP_CONV")){let e=f?ZX(f,!0):null,n=new SZ(y,x,e,v,w),a=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],s=k();t=r.runWebGLProgram(n,s,"float32",a)}else if(We().getBool("WEBGL_CONV_IM2COL"))t=CZ({x:s,filter:i,convInfo:y,backend:r,bias:o,activation:f,preluActivationWeights:l,leakyreluAlpha:m});else{let e=f?ZX(f,!1):null,n=new kZ(y,x,e,v,w),a=k();t=r.runWebGLProgram(n,a,"float32")}else t=_Z({x:s,filter:i,convInfo:y,backend:r,bias:o,activation:f,preluActivationWeights:l,leakyreluAlpha:m});let I=iJ({inputs:{x:t},backend:r,attrs:{shape:y.outShape}});return b.push(t),b.forEach((e=>r.disposeIntermediateTensorInfo(e))),I}var _0={kernelName:ua,backendName:"webgl",kernelFunc:T0};function C0(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:p,dimRoundingMode:c,activation:d,leakyreluAlpha:h}=r,f=[],m=p;null==m&&(m=[1,1]),Sa.assert(Qx.eitherStridesOrDilationsAreOne(l,m),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`));let g,y=Qx.computeConv2DInfo(a.shape,s.shape,l,m,u,c,!0),b=We().getBool("WEBGL_PACK_DEPTHWISECONV")&&y.strideWidth<=2&&y.outChannels/y.inChannels===1,x=d?ZX(d,b):null,v=[a,s],w=null!=i,k=null!=o,I="leakyrelu"===d;if(w&&v.push(i),k&&v.push(o),I){let e=n.makeTensorInfo([],"float32",Sa.createScalarValue(h,"float32"));v.push(e),f.push(e)}g=b?new yQ(y,w,x,k,I):new gQ(y,w,x,k,I);let S=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],N=n.runWebGLProgram(g,v,"float32",S);return f.forEach((e=>n.disposeIntermediateTensorInfo(e))),N}var E0={kernelName:pa,backendName:"webgl",kernelFunc:C0},A0=class{constructor(e,t,n,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;let a=uq(n.length),s="\n    int index;";for(let i=0;i<this.sliceDim;i++)s+=`\n          index = round(getIndices(coords[0], ${i}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[i]};\n          flattenIndex += index * ${this.strides[i]};`;this.userCode=`\n         void main() {\n          ${a} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${s}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}};function $0(e){let{inputs:t,backend:n}=e,{params:r,indices:a}=t,s=a.shape,i=s[s.length-1],o=Sa.sizeFromShape(r.shape),[l,u,p,c]=Qx.prepareAndValidate(r,a),d=iJ({inputs:{x:a},backend:n,attrs:{shape:[u,i]}}),h=iJ({inputs:{x:r},backend:n,attrs:{shape:[Sa.sizeFromShape(r.shape)/p,p]}});if(n.shouldExecuteOnCPU([r,a])||"string"===r.dtype){let e=n.readSync(a.dataId),t=n.bufferSync(r),s=oK(e,t,r.dtype,u,i,p,c,r.shape,o);return n.makeTensorInfo(l,r.dtype,s.values)}let f=new A0(i,c,[u,p],r.shape),m=n.runWebGLProgram(f,[h,d],h.dtype),g=iJ({inputs:{x:m},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),g}var R0={kernelName:sn,backendName:"webgl",kernelFunc:$0},F0=class{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;let n=uq(this.rank),r=D0(e,2);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${r}));\n      }\n    `}};function D0(e,t){let n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let a=0;a<e.length;a++)2===a?r.push("index"):r.push(`${n[a]}`);return r.join()}function M0(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,indices:s}=t,{axis:i,batchDims:o}=r,l=Sa.parseAxisParam(i,a.shape)[0];if(We().get("DEBUG")){let e=n.readSync(s.dataId),t=a.shape[l];for(let n=0;n<e.length;++n){let r=e[n];Sa.assert(r<=t-1&&r>=0,(()=>`GatherV2: the index value ${r} is not in [0, ${t-1}]`))}}let u=Qx.segment_util.collectGatherOpShapeInfo(a,s,l,o),p=Sa.sizeFromShape(s.shape),c=[],d=iJ({inputs:{x:a},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),h=iJ({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,p/u.batchSize]}});c.push(d),c.push(h);let f=[u.batchSize,u.outerSize,p/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([a,s])||"string"===a.dtype){let e=n.bufferSync(h),t=n.bufferSync(d),r=lK(t,e,f);return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(u.outputShape,r.dtype,r.values)}let m=new F0(d.shape,f),g=n.runWebGLProgram(m,[d,h],d.dtype);c.push(g);let y=iJ({inputs:{x:g},backend:n,attrs:{shape:u.outputShape}});return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}var O0={kernelName:an,backendName:"webgl",kernelFunc:M0},P0="return float(a > b);",L0="\n  return vec4(greaterThan(a, b));\n",z0=YX({opSnippet:P0,packedOpSnippet:L0,cpuKernelImpl:uK,dtype:"bool"}),B0={kernelName:on,backendName:"webgl",kernelFunc:z0},W0="return float(a >= b);",U0="\n  return vec4(greaterThanEqual(a, b));\n",V0=YX({opSnippet:W0,packedOpSnippet:U0,dtype:"bool",cpuKernelImpl:pK}),G0={kernelName:ln,backendName:"webgl",kernelFunc:V0};function H0(e){let{inputs:t,backend:n}=e,{input:r}=t;return s0(r,!0,n)}var j0={kernelName:pn,backendName:"webgl",kernelFunc:H0},q0="return float(!isnan(x) && !isinf(x));",K0=JX({opSnippet:q0,dtype:"bool"}),X0={kernelName:dn,backendName:"webgl",kernelFunc:K0},J0="return float(isinf(x));",Y0=JX({opSnippet:J0,dtype:"bool"}),Z0={kernelName:hn,backendName:"webgl",kernelFunc:Y0},Q0="return float(isnan(x));",e1=JX({opSnippet:Q0,dtype:"bool"}),t1={kernelName:fn,backendName:"webgl",kernelFunc:e1},n1="return float(a < b);",r1="\n  return vec4(lessThan(a, b));\n",a1=YX({opSnippet:n1,packedOpSnippet:r1,cpuKernelImpl:cK,dtype:"bool"}),s1={kernelName:gn,backendName:"webgl",kernelFunc:a1},i1="return float(a <= b);",o1="\n  return vec4(lessThanEqual(a, b));\n",l1=YX({opSnippet:i1,packedOpSnippet:o1,cpuKernelImpl:dK,dtype:"bool"}),u1={kernelName:yn,backendName:"webgl",kernelFunc:l1};function p1(e){let{backend:t,attrs:n}=e,{start:r,stop:a,num:s}=n,i=hK(r,a,s);return t.makeTensorInfo([i.length],"float32",i)}var c1={kernelName:bn,backendName:"webgl",kernelFunc:p1},d1=XX+"\n  return x < 0.0 ? 0./0. : log(x);\n",h1="\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",f1=JX({opSnippet:d1,packedOpSnippet:h1,cpuKernelImpl:fK}),m1={kernelName:xn,backendName:"webgl",kernelFunc:f1},g1=XX+"\n  return log(1.0 + x);\n",y1=JX({opSnippet:g1}),b1={kernelName:vn,backendName:"webgl",kernelFunc:y1},x1="return float(a >= 1.0 && b >= 1.0);",v1="\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",w1=YX({opSnippet:x1,packedOpSnippet:v1,dtype:"bool"}),k1={kernelName:wn,backendName:"webgl",kernelFunc:w1},I1="return float(!(x >= 1.0));",S1=JX({opSnippet:I1}),N1={kernelName:kn,backendName:"webgl",kernelFunc:S1},T1="return float(a >= 1.0 || b >= 1.0);",_1="\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",C1=YX({opSnippet:T1,packedOpSnippet:_1,dtype:"bool"}),E1={kernelName:In,backendName:"webgl",kernelFunc:C1},A1=class{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[];let s=t,i=e[3]-1;this.outputShape=e;let o,l=`float(${n}) + float(${r}) * sum`;o=.5===a?`inversesqrt(${l})`:1===a?`1.0/(${l})`:`exp(log(${l}) * float(-${a}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${s}; j <= ${s}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${i}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${o};\n        setOutput(val);\n      }\n    `}},$1=class{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let s=t,i=e[3]-1;this.outputShape=e;let o,l=`float(${n}) + float(${r}) * sum`;o=.5===a?`inversesqrt(${l})`:1===a?`1.0/(${l})`:`exp(log(${l}) * float(-${a}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${s};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${s}; j <= ${s}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${o};\n        setOutput(result);\n      }\n    `}},R1=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r,u=We().getBool("WEBGL_PACK_NORMALIZATION")?new $1(a.shape,s,i,o,l):new A1(a.shape,s,i,o,l);return n.runWebGLProgram(u,[a],a.dtype)},F1={kernelName:_n,backendName:"webgl",kernelFunc:R1},D1=class{constructor(e,t,n,r,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=a,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${a})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${a});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}},M1=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:p}=r,c=new D1(a.shape,o,l,u,p);return n.runWebGLProgram(c,[a,s,i],a.dtype)},O1={kernelName:Cn,backendName:"webgl",kernelFunc:M1};function P1(e,t,n,r){let a=Sa.sizeFromShape(t),s=Sa.sizeFromShape(e.shape)/a,i=iJ({inputs:{x:e},attrs:{shape:[s,a]},backend:r}),o=cJ(i,e.dtype,"max",r),l=iJ({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(o),l}function L1(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:s,keepDims:i}=r,o=a.shape.length,l=Sa.parseAxisParam(s,a.shape),u=l,p=Qx.getAxesPermutation(u,o),c=null!=p,d=n.shouldExecuteOnCPU([a]),h=a;if(c){if(d){let e=n.texData.get(h.dataId).values,t=new Array(o);for(let n=0;n<t.length;n++)t[n]=a.shape[p[n]];let r=VK(e,a.shape,a.dtype,p,t);h=n.makeTensorInfo(t,a.dtype);let s=n.texData.get(h.dataId);s.values=r}else h=mJ(a,p,n);u=Qx.getInnerMostAxes(u.length,o)}Qx.assertAxesAreInnerMostDims("max",u,o);let f,[m,g]=Qx.computeOutAndReduceShapes(h.shape,u),y=m;if(i&&(y=Qx.expandShapeToKeepDim(m,l)),d){let e=n.texData.get(h.dataId).values,t=mK(e,Sa.sizeFromShape(g),y,a.dtype);f=n.makeTensorInfo(y,a.dtype);let r=n.texData.get(f.dataId);r.values=t}else f=P1(h,g,y,n);return c&&n.disposeIntermediateTensorInfo(h),f}var z1={kernelName:An,backendName:"webgl",kernelFunc:L1},B1=FX+"\n  return max(a, b);\n",W1="\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+MX+"\n  return result;\n",U1=YX({opSnippet:B1,packedOpSnippet:W1,cpuKernelImpl:gK}),V1={kernelName:$n,backendName:"webgl",kernelFunc:U1};function G1(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;cj(a,"maxPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r,u=1;Sa.assert(Qx.eitherStridesOrDilationsAreOne(i,u),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`));let p=Qx.computePool2DInfo(a.shape,s,i,u,o,l);if(1===p.filterWidth&&1===p.filterHeight&&Sa.arraysEqual(p.inShape,p.outShape))return PX({inputs:{x:a},backend:n});let c=new gY(p,"max",!1);return n.runWebGLProgram(c,[a],a.dtype)}var H1={kernelName:Rn,backendName:"webgl",kernelFunc:G1};function j1(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dataFormat:l,dimRoundingMode:u}=r,p=[1,1,1],c=Qx.computePool3DInfo(a.shape,s,i,p,o,u,l),d=new yY(c,"max",!1);return n.runWebGLProgram(d,[a],a.dtype)}var q1={kernelName:Dn,backendName:"webgl",kernelFunc:j1},K1=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,a=e.effectiveFilterHeight,s=e.effectiveFilterWidth,i=a-1-e.padInfo.top,o=s-1-e.padInfo.left,l=a*s-1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${a};\n          wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${s}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${s} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},X1=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.dilationDepth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterDepth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,p=o-1-e.padInfo.front,c=l-1-e.padInfo.top,d=u-1-e.padInfo.left,h=o*l*u-1;this.userCode=`\n      const ivec3 pads = ivec3(${p}, ${c}, ${d});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${o};\n           wD += ${a}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${l};\n              wR += ${s}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${u};\n                wC += ${i}) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${h} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${l} * ${u} +\n                  wR * ${u} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};function J1(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s,{filterSize:o,strides:l,pad:u,dimRoundingMode:p}=r,c=[1,1,1],d=Qx.computePool3DInfo(i.shape,o,l,c,u,p),h=new yY(d,"max",!0),f=n.runWebGLProgram(h,[i],i.dtype),m=new X1(d),g=n.runWebGLProgram(m,[a,f],i.dtype);return n.disposeIntermediateTensorInfo(f),g}var Y1={kernelName:Mn,backendName:"webgl",kernelFunc:J1};function Z1(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s,output:i}=t,o=s;cj([s,i],"maxPoolGrad");let{filterSize:l,strides:u,pad:p,dimRoundingMode:c}=r,d=Qx.computePool2DInfo(o.shape,l,u,1,p,c),h=!0,f=new gY(d,"max",h),m=n.runWebGLProgram(f,[o],o.dtype),g=new K1(d),y=n.runWebGLProgram(g,[a,m],o.dtype);return n.disposeIntermediateTensorInfo(m),y}var Q1={kernelName:Fn,backendName:"webgl",kernelFunc:Z1};function e2(e,t,n,r){let a=new gY(n,"max",!1),s=r.runWebGLProgram(a,[e],"float32");a=new gY(n,"max",!0,!0,t);let i=r.runWebGLProgram(a,[e],"float32");return[s,i]}var t2={kernelName:On,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{filterSize:a,strides:s,pad:i,includeBatchInIndex:o}=t,l=n;Sa.assert(4===r.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`));let u=[1,1];Sa.assert(Qx.eitherStridesOrDilationsAreOne(s,u),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${u}'`));let p=Qx.computePool2DInfo(r.shape,a,s,u,i),[c,d]=e2(r,o,p,l);return[c,d]}};function n2(e,t,n,r){let a=Sa.sizeFromShape(t),s=Sa.sizeFromShape(e.shape)/a,i=iJ({inputs:{x:e},attrs:{shape:[s,a]},backend:r}),o=cJ(i,"float32","mean",r),l=iJ({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(o),l}var r2={kernelName:Pn,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{keepDims:a,axis:s}=t,i=n,o=r.shape.length,l=Sa.parseAxisParam(s,r.shape),u=l,p=Qx.getAxesPermutation(u,o),c=null!=p,d=i.shouldExecuteOnCPU([r]),h=[],f=r;if(c){if(d){let e=i.texData.get(f.dataId).values,t=new Array(o);for(let s=0;s<t.length;s++)t[s]=r.shape[p[s]];let n=VK(e,r.shape,r.dtype,p,t);f=i.makeTensorInfo(t,r.dtype);let a=i.texData.get(f.dataId);a.values=n}else f=mJ(r,p,i);h.push(f),u=Qx.getInnerMostAxes(u.length,o)}Qx.assertAxesAreInnerMostDims("sum",u,o);let[m,g]=Qx.computeOutAndReduceShapes(f.shape,u),y=m;a&&(y=Qx.expandShapeToKeepDim(m,l));let b=n2(f,g,y,i);for(let x of h)i.disposeIntermediateTensorInfo(x);return b}};function a2(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=Sa.parseAxisParam(s,a.shape),u=l,p=Qx.getAxesPermutation(u,o),c=a;null!=p&&(c=xJ({inputs:{x:a},backend:n,attrs:{perm:p}}),u=Qx.getInnerMostAxes(u.length,a.shape.length)),Qx.assertAxesAreInnerMostDims("min",u,o);let d,[h,f]=Qx.computeOutAndReduceShapes(c.shape,u),m=Sa.sizeFromShape(f),g=iJ({inputs:{x:c},backend:n,attrs:{shape:[-1,m]}}),y=cJ(g,g.dtype,"min",n);if(i){let e=Qx.expandShapeToKeepDim(h,l);d=iJ({inputs:{x:y},backend:n,attrs:{shape:e}})}else d=iJ({inputs:{x:y},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),null!=p&&n.disposeIntermediateTensorInfo(c),d}var s2={kernelName:Ln,backendName:"webgl",kernelFunc:a2},i2=FX+"\n  return min(a, b);\n",o2="\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+MX+"\n  return result;\n",l2=YX({opSnippet:i2,packedOpSnippet:o2,cpuKernelImpl:yK}),u2={kernelName:zn,backendName:"webgl",kernelFunc:l2},p2=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));let r=e.length,a=uq(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l="reflect"===n?0:1;this.userCode=1!==r?`\n      ${a} start = ${a}(${s});\n      ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${l};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};\n          }\n        }\n        ${a} coords = outC - start;\n        setOutput(getX(${o}));\n      }\n    `:`\n        int start = ${s};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${l};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${l};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}},c2=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));let r=e.length,a=uq(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=jK("rc",r),l=jK("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,p=1===r?"source":`vec2(${l.slice(-2).join()})`,c="reflect"===n?0:1,d="";if(1===r){let e=`\n        ${a} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${c};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${c};\n        }\n        source -= start;\n      `;d=`\n        ${a} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${p});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${p});\n        }\n      `}else{let e=`\n        ${a} source = rc;\n        ${a} lt = ${a}(lessThan(source, start));\n        ${a} gte = ${a}(greaterThanEqual(source, end));\n        ${a} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${c}) +\n                gte * ((end - 1) * 2 - source + ${c});\n        source -= start;\n      `;d=`\n        ${a} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${p});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${p});\n        }\n        rc = outputLoc;\n        ${o[r-2]} += 1;\n        if(${o[r-2]} < ${this.outputShape[r-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${l.join()}), ${p});\n          ${o[r-1]} += 1;\n          if(${u}) {\n            ${e}\n            result[3] = getChannel(getX(${l.join()}), ${p});\n          }\n        }\n      `}this.userCode=`\n      const ${a} start = ${a}(${s});\n      const ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${d}\n        setOutput(result);\n      }\n    `}},d2=({inputs:e,backend:t,attrs:n})=>{let{x:r}=e,{paddings:a,mode:s}=n,i=We().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new c2(r.shape,a,s):new p2(r.shape,a,s);return t.runWebGLProgram(i,[r],r.dtype)},h2={kernelName:Bn,backendName:"webgl",kernelFunc:d2},f2="if (b == 0.0) return NAN;\n  return mod(a, b);",m2="\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+MX+"\n  return result;\n",g2=YX({opSnippet:f2,packedOpSnippet:m2}),y2={kernelName:Wn,backendName:"webgl",kernelFunc:g2},b2=class{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}},x2="\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",v2="\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",w2=YX({opSnippet:x2,packedOpSnippet:v2,checkOutOfBounds:!0}),k2={kernelName:Vt,backendName:"webgl",kernelFunc:w2},I2="return a - b;",S2=YX({opSnippet:I2,packedOpSnippet:I2,supportsComplex:!0,cpuKernelImpl:BK}),N2={kernelName:qr,backendName:"webgl",kernelFunc:S2};function T2(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:s}=r,i=Sa.parseAxisParam([s],a.shape),o=L1({inputs:{x:a},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),l=Qx.expandShapeToKeepDim(o.shape,i),u=iJ({inputs:{x:o},backend:n,attrs:{shape:l}}),p=S2({inputs:{a:a,b:u},backend:n}),c=YQ({inputs:{x:p},backend:n}),d=yJ({inputs:{x:c},backend:n,attrs:{axis:i,keepDims:!1}}),h=iJ({inputs:{x:d},backend:n,attrs:{shape:l}}),f=w2({inputs:{a:c,b:h},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),f}var _2={kernelName:Dr,backendName:"webgl",kernelFunc:T2};function C2(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=r,l=o?a:T2({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),u=l.shape[0],p=l.shape[1],c=new b2(u,p,s),d=[[i]],h=n.runWebGLProgram(c,[l],"int32",d);return o||n.disposeIntermediateTensorInfo(l),h}var E2={kernelName:Un,backendName:"webgl",kernelFunc:C2},A2=sX+"\n  return -x;\n",$2="\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n";function R2(e){let t,{inputs:n,backend:r}=e,{x:a}=n;if(r.shouldExecuteOnCPU([a])){let e=r.texData.get(a.dataId),[t,n]=xK(e.values,a.shape,a.dtype);return r.makeTensorInfo(n,a.dtype,t)}return t=We().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new bX(a.shape,$2):new aX(a.shape,A2),r.runWebGLProgram(t,[a],a.dtype)}var F2={kernelName:Gn,backendName:"webgl",kernelFunc:R2},D2=sw.nonMaxSuppressionV3Impl;function M2(e){Qx.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r,u=n.readSync(a.dataId),p=n.readSync(s.dataId),{selectedIndices:c}=D2(u,p,i,o,l);return n.makeTensorInfo([c.length],"int32",new Int32Array(c))}var O2={kernelName:jn,backendName:"webgl",kernelFunc:M2},P2=sw.nonMaxSuppressionV4Impl;function L2(e){Qx.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r,p=n.readSync(a.dataId),c=n.readSync(s.dataId),{selectedIndices:d,validOutputs:h}=P2(p,c,i,o,l,u);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([h]))]}var z2={kernelName:qn,backendName:"webgl",kernelFunc:L2},B2=sw.nonMaxSuppressionV5Impl;function W2(e){Qx.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r,p=n.readSync(a.dataId),c=n.readSync(s.dataId),d=i,h=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=B2(p,c,d,h,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}var U2={kernelName:Kn,backendName:"webgl",kernelFunc:W2},V2=class{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}},G2=e=>{let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:i,onValue:o,offValue:l}=r,u=Sa.sizeFromShape(a.shape),p=new V2(u,i,o,l),c=iJ({inputs:{x:a},backend:n,attrs:{shape:[u]}}),d=n.runWebGLProgram(p,[c],s);n.disposeIntermediateTensorInfo(c);let h=[...a.shape,i],f=iJ({inputs:{x:d},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(d),f},H2={kernelName:Jn,backendName:"webgl",kernelFunc:G2};function j2(e){let{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){let e=JY({inputs:{input:r},backend:n}),t=j2({inputs:{x:e},backend:n}),a=gZ({inputs:{input:r},backend:n}),s=j2({inputs:{x:a},backend:n}),i=zX({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),i}return u0({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}var q2={kernelName:aa,backendName:"webgl",kernelFunc:j2};function K2(e){let{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){let e=JY({inputs:{input:r},backend:n}),t=K2({inputs:{x:e},backend:n}),a=gZ({inputs:{input:r},backend:n}),s=j2({inputs:{x:a},backend:n}),i=zX({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),i}return u0({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:n})}var X2={kernelName:Xn,backendName:"webgl",kernelFunc:K2};function J2(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return QQ({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let s=t[0].shape,i=t[0].dtype;t.forEach((e=>{Sa.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),Sa.assert(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));let o=[],l=t.map((e=>{let t=QQ({inputs:{input:e},backend:n,attrs:{dim:a}});return o.push(t),t})),u=vZ({inputs:l,backend:n,attrs:{axis:a}});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}var Y2={kernelName:Yn,backendName:"webgl",kernelFunc:J2},Z2=class{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));let r=e.length,a=uq(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${a} start = ${a}(${s});\n      ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${a} coords = outC - start;\n          setOutput(getX(${o}));\n        }\n      }\n    `:`\n        int start = ${s};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}},Q2=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));let r=e.length,a=uq(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=jK("rc",r),l=jK("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,p=1===r?"source":`vec2(${l.slice(-2).join()})`,c=[`${a} rc = outputLoc;`,`${o[r-1]} += 1;\n       if(${u}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${o[r-2]} += 1;\n       if(${o[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${o[r-1]} += 1;\n         if(${u}) {`],d=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",h="";for(let f=0,m=1===r?2:4;f<m;f++)h+=`\n        ${c[f]}\n        if (${d}) {\n          result[${f}] = float(value);\n        } else {\n          ${a} source = rc - start;\n          result[${f}] = getChannel(getX(${l.join()}), ${p});\n        }\n      `;h+=1===r?"} ":"}}",this.userCode=`\n      const ${a} start = ${a}(${s});\n      const ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${h}\n        setOutput(result);\n      }\n    `}},e3=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,constantValue:i}=r;if(0===Sa.sizeFromShape(a.shape)){let e=s.map(((e,t)=>e[0]+a.shape[t]+e[1]));return u0({backend:n,attrs:{shape:e,value:i,dtype:a.dtype}})}let o=We().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Q2(a.shape,s,i):new Z2(a.shape,s,i),l=[[i]];return n.runWebGLProgram(o,[a],a.dtype,l)},t3={kernelName:Zn,backendName:"webgl",kernelFunc:e3},n3="\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",r3="\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+MX+"\n  return result;\n",a3=YX({opSnippet:n3,packedOpSnippet:r3}),s3={kernelName:er,backendName:"webgl",kernelFunc:a3};function i3(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{axis:i,keepDims:o}=a,l=s.shape.length,u=[],p=Sa.parseAxisParam(i,s.shape),c=p,d=Qx.getAxesPermutation(c,l),h=s;if(null!=d&&(h=xJ({inputs:{x:s},backend:r,attrs:{perm:d}}),c=Qx.getInnerMostAxes(c.length,l),u.push(h)),Qx.assertAxesAreInnerMostDims("prod",c,l),r.shouldExecuteOnCPU([h])){let e=r.texData.get(h.dataId).values,{outVals:n,outShape:a,outDtype:s}=wK(h.shape,h.dtype,e,c);t=r.makeTensorInfo(a,s,n)}else{let[e,n]=Qx.computeOutAndReduceShapes(h.shape,c),a=Sa.sizeFromShape(n),i=iJ({inputs:{x:h},backend:r,attrs:{shape:[-1,a]}}),o=Es(s.dtype),l=cJ(i,o,"prod",r);t=iJ({inputs:{x:l},backend:r,attrs:{shape:e}}),u.push(i),u.push(l)}if(o){u.push(t);let e=Qx.expandShapeToKeepDim(t.shape,p);t=iJ({inputs:{x:t},backend:r,attrs:{shape:e}})}return u.forEach((e=>r.disposeIntermediateTensorInfo(e))),t}var o3={kernelName:nr,backendName:"webgl",kernelFunc:i3};function l3(e){let{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:a,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=r,l=a.map((e=>n.readSync(e.dataId))),u=a.map((e=>e.shape)),p=n.readSync(s.dataId),c=n.readSync(i.dataId),[d,h,f]=kK(l,u,p,s.shape,s.dtype,c,i.shape,o),m=d.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,s.dtype,h);return m.concat([g])}var u3={kernelName:rr,backendName:"webgl",kernelFunc:l3};function p3(e){let{inputs:t,backend:n}=e,{starts:r,limits:a,deltas:s}=t,i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[u,p]=IK(i,r.shape,r.dtype,o,a.shape,l,s.shape),c=n.makeTensorInfo([u.length],"int32",u),d=n.makeTensorInfo([p.length],r.dtype,p);return[c,d]}var c3={kernelName:ar,backendName:"webgl",kernelFunc:p3};function d3(e){let{inputs:t,backend:n,attrs:r}=e,{shape:a,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.readSync(a.dataId),p=n.readSync(s.dataId),c=n.readSync(i.dataId),d=o.map((e=>n.readSync(e.dataId))),h=o.map((e=>e.shape)),[f,m]=SK(u,a.shape,p,s.shape,s.dtype,c,i.shape,d,h,l);return n.makeTensorInfo(f,s.dtype,m)}var h3={kernelName:sr,backendName:"webgl",kernelFunc:d3},f3=e=>{let{backend:t,attrs:n}=e,{start:r,stop:a,step:s,dtype:i}=n,o=NK(r,a,s,i);return t.makeTensorInfo([o.length],i,o)},m3={kernelName:ir,backendName:"webgl",kernelFunc:f3},g3="return 1.0 / x;",y3=JX({opSnippet:g3}),b3={kernelName:lr,backendName:"webgl",kernelFunc:y3},x3=sX+"\n  return (x < 0.0) ? 0.0 : x;\n",v3="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",w3=JX({opSnippet:x3,packedOpSnippet:v3}),k3={kernelName:ur,backendName:"webgl",kernelFunc:w3},I3=sX+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",S3="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",N3=JX({opSnippet:I3,packedOpSnippet:S3}),T3={kernelName:mr,backendName:"webgl",kernelFunc:N3},_3=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u,p=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];u=a?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${p[0]/c[0]},\n          ${p[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${u};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}},C3=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u,p=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];u=a?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${p[0]/c[0]},\n          ${p[1]/c[1]},\n          ${p[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${u};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}};function E3(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,u]=o,p=We().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new C3(a.shape,l,u,s,i):new _3(a.shape,l,u,s,i);return n.runWebGLProgram(p,[a],"float32")}var A3={kernelName:hr,backendName:"webgl",kernelFunc:E3},$3=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,r,a]=t,[,s,i]=e,o=[n&&s>1?r-1:r,n&&i>1?a-1:a],l=[n&&s>1?s-1:s,n&&i>1?i-1:i],u=o[0]/l[0],p=o[1]/l[1],c=1/u,d=1/p,h=2*Math.ceil(c)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${p});\n\n        const float invHeightScale = float(${c});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${h});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${a-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}};function R3(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r,o=new $3(s.shape,a.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}var F3={kernelName:fr,backendName:"webgl",kernelFunc:R3},D3=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u,p=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?"0.5":"0.0";u=a?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${p[0]/c[0]},\n          ${p[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${u};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}},M3=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u,p=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?"0.5":"0.0";u=a?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${p[0]/c[0]},\n          ${p[1]/c[1]},\n          ${p[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${u};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}};function O3(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,u]=o,p=We().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new M3(a.shape,l,u,s,i):new D3(a.shape,l,u,s,i);return n.runWebGLProgram(p,[a],a.dtype)}var P3={kernelName:cr,backendName:"webgl",kernelFunc:O3},L3=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,r,a]=t,[,s,i]=e,o=[n&&s>1?r-1:r,n&&i>1?a-1:a],l=[n&&s>1?s-1:s,n&&i>1?i-1:i],u=o[0]/l[0],p=o[1]/l[1],c=1/u,d=1/p,h=2*Math.ceil(c)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${p});\n\n        const float invHeightScale = float(${c});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${h});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${o[0]}) *\n                (float(dyR) / float(${l[0]}));\n\n            float sourceFracCol =\n                float(${o[1]}) *\n                  (float(dyC) / float(${l[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${a}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}};function z3(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r,o=new L3(s.shape,a.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}var B3={kernelName:dr,backendName:"webgl",kernelFunc:z3},W3=class{constructor(e,t){this.variableNames=["x"];let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);let r=n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`,a=e.map(((e,t)=>r(t))).join(","),s=uq(n);this.userCode=`\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}},U3=class{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;let r=jK("rc",n),a=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,s=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,i=uq(n);function o(e){return c(e)}function l(e){return e[n-1]="("+e[n-1]+" + 1)",c(e)}function u(e){return e[n-2]="("+e[n-2]+" + 1)",c(e)}function p(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",c(e)}function c(t){let n=e.map(((e,n)=>d(n,t))),r=n.join(","),a=n.slice(-2).join(",");return`getChannel(getX(${r}), vec2(${a}))`}function d(n,r){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${r[n]} - 1`:`${r[n]}`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${a}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${i} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${o(r.slice())};\n          if(${a}){\n            result.g = ${l(r.slice())};\n          }\n          if(${s}) {\n            result.b = ${u(r.slice())};\n            if(${a}) {\n              result.a = ${p(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}};function V3(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r,i=a.shape.length,o=Sa.parseAxisParam(s,a.shape);if(0===i)return PX({inputs:{x:a},backend:n});let l=We().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new U3(a.shape,o):new W3(a.shape,o);return n.runWebGLProgram(l,[a],a.dtype)}var G3={kernelName:gr,backendName:"webgl",kernelFunc:V3},H3=class{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let n=e[1],r=e[2];this.outputShape=e;let a="";a="number"==typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${a}\n          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}},j3={kernelName:oa,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,{radians:a,fillValue:s,center:i}=t,o=n,l=new H3(r.shape,s),[u,p]=Qx.getImageCenter(i,r.shape[1],r.shape[2]),c=[[u,p,Math.sin(a),Math.cos(a)]];return o.runWebGLProgram(l,[r],r.dtype,c)}},q3="\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n",K3=JX({opSnippet:q3}),X3={kernelName:yr,backendName:"webgl",kernelFunc:K3},J3="return inversesqrt(x);",Y3=JX({opSnippet:J3,cpuKernelImpl:TK}),Z3={kernelName:br,backendName:"webgl",kernelFunc:Y3},Q3=class{constructor(e,t,n,r,a,s,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;let l=uq(a.length),u=uq(s.length),p="";1===n?p="i":2===n&&(p="i, j");let c=`getIndices(${p})`,d="";1===r?d="i":2===r&&(d="i, coords[1]");let h=`getUpdates(${d})`,f="";o&&(f="coords[0], coords[1]");let m=`getDefaultValue(${f})`,g=t>1?"strides[j]":"strides";this.userCode=`\n        ${l} strides = ${l}(${a});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${c});\n              flattenedIndex += index * ${g};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${h};\n              found = true;\n            }\n          }\n          setOutput(mix(${m}, sum, float(found)));\n        }\n      `}},e4=class{constructor(e,t,n,r,a,s,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s;let l=uq(a.length),u=uq(s.length),p="";1===n?p="i":2===n&&(p="i, j");let c=`getIndices(${p})`,d="";1===r?d="i":2===r&&(d="i, coords[1]");let h=`getUpdates(${d})`,f="";o&&(f="coords[0], coords[1]");let m=`getDefaultValue(${f})`,g=t>1?"strides[j]":"strides",y=t>1?"strides[j + 1]":"strides";this.userCode=`\n        ${l} strides = ${l}(${a});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${e}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${t}; j+=2) {\n              ivec4 index = round(${c});\n              flattenedIndex += index.xz * ${g};\n              if (j + 1 < ${t}) {\n                flattenedIndex += index.yw * ${y};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ${h};\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(${m}, sum, found));\n        }\n      `}};function t4(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:s}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:p,outputSize:c}=Qx.calculateShapes(s,a,i),d=[c/u,u];if(0===c)return n.makeTensorInfo(i,a.dtype);let h,f=iJ({inputs:{x:a},backend:n,attrs:{shape:[l,o]}}),m=iJ({inputs:{x:s},backend:n,attrs:{shape:[l,u]}}),g=n.makeTensorInfo([],"float32",new Float32Array([0]));h=We().getBool("WEBGL_PACK")?new e4(l,o,f.shape.length,m.shape.length,p,d):new Q3(l,o,f.shape.length,m.shape.length,p,d);let y=n.runWebGLProgram(h,[m,f,g],m.dtype),b=iJ({inputs:{x:y},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(g),b}var n4={kernelName:xr,backendName:"webgl",kernelFunc:t4},r4=class{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];let a="while (left < right) {",s=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,i=2===We().getNumber("WEBGL_VERSION")?a:s,o="left"===r?"<":"<=";this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${i}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${o} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}};function a4(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:i}=r,o=new r4(a.shape[0],a.shape[1],s.shape[1],i),l=[[a.shape[1]]];return n.runWebGLProgram(o,[a,s],"int32",l)}var s4={kernelName:wr,backendName:"webgl",kernelFunc:a4},i4=class{constructor(e,t,n){let r,a;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)a="resRC",r="resRC";else{let n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[],i=[];for(let r=0;r<t.length;r++)i.push(`${n[r]}`),r<e&&s.push(`${n[r]}`);r=s.join(),a=i.join()}let s=uq(n);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${a}));\n        } else {\n          setOutput(getB(${a}));\n        }\n      }\n    `}};function o4(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t,i=new i4(r.shape.length,a.shape,a.shape.length);return n.runWebGLProgram(i,[r,a,s],Cs(a.dtype,s.dtype))}var l4={kernelName:kr,backendName:"webgl",kernelFunc:o4},u4=`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${Qx.SELU_SCALEALPHA};\n  float scale = ${Qx.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`,p4=JX({opSnippet:u4}),c4={kernelName:Ir,backendName:"webgl",kernelFunc:p4},d4=XX+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",h4="\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",f4=JX({opSnippet:d4,packedOpSnippet:h4,cpuKernelImpl:CK}),m4={kernelName:Cr,backendName:"webgl",kernelFunc:f4},g4="\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n",y4=JX({opSnippet:g4}),b4={kernelName:_r,backendName:"webgl",kernelFunc:y4},x4=XX+"\n  return sin(x);\n",v4=`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${MX}\n  return result;\n`,w4=JX({opSnippet:x4,packedOpSnippet:v4}),k4={kernelName:Nr,backendName:"webgl",kernelFunc:w4},I4="\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n",S4=JX({opSnippet:I4}),N4={kernelName:Tr,backendName:"webgl",kernelFunc:S4},T4="\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n",_4=JX({opSnippet:T4}),C4={kernelName:Er,backendName:"webgl",kernelFunc:_4},E4=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r;Sa.assert(a.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));let o=s.reduce(((e,t)=>e*t)),l=[[0,0]];l.push(...i);for(let y=1+s.length;y<a.shape.length;++y)l.push([0,0]);let u=[],p=e3({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),c=Qx.getReshaped(p.shape,s,o,!1),d=Qx.getPermuted(c.length,s.length,!1),h=Qx.getReshapedPermuted(p.shape,s,o,!1),f=iJ({inputs:{x:p},backend:n,attrs:{shape:c}}),m=xJ({inputs:{x:f},backend:n,attrs:{perm:d}}),g=iJ({inputs:{x:m},backend:n,attrs:{shape:h}});return u.push(p),u.push(f),u.push(m),u.forEach((e=>n.disposeIntermediateTensorInfo(e))),g},A4={kernelName:Rr,backendName:"webgl",kernelFunc:E4};function $4(e){let{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:s,defaultValue:i}=t;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${s.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==a.shape.length)throw new Error(`Values must be a vector, saw:\n         ${a.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);let o=n.readSync(r.dataId),l=n.readSync(a.dataId),u=n.readSync(s.dataId),p=n.readSync(i.dataId)[0],[c,d,h,f,m]=$K(o,r.shape,r.dtype,l,a.dtype,u,p);return[n.makeTensorInfo(d,r.dtype,c),n.makeTensorInfo([d[0]],a.dtype,h),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}var R4={kernelName:Mr,backendName:"webgl",kernelFunc:$4};function F4(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:s}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape ${a.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(n.readSync(a.dataId)),o=n.readSync(r.dataId),l=Array.from(n.readSync(s.dataId)),[u,p,c]=RK(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(p,r.dtype,u),n.makeTensorInfo([c.length],s.dtype,new Int32Array(c))]}var D4={kernelName:Or,backendName:"webgl",kernelFunc:F4};function M4(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${s.shape}`);let i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[u,p]=FK(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(p,r.dtype,u)}var O4={kernelName:Pr,backendName:"webgl",kernelFunc:M4};function P4(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${s.shape}`);let i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[u,p]=FK(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(p,r.dtype,u)}var L4={kernelName:Lr,backendName:"webgl",kernelFunc:P4};function z4(e){let{inputs:t,backend:n,attrs:r}=e,{sparseIndices:a,sparseValues:s,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:p,strides:c,outputSize:d}=Qx.calculateShapes(s,a,o),h=!1;if("string"===s.dtype){let e=n.bufferSync(a),t=n.bufferSync(s),r=Sa.decodeString(n.readSync(i.dataId)[0]),f=_K(e,t,o,d,p,u,l,c,r,h);return n.makeTensorInfo(o,f.dtype,f.values)}let f=new Q3(u,l,a.shape.length,s.shape.length,c,[d,1],h),m=n.runWebGLProgram(f,[s,a,i],s.dtype),g=iJ({inputs:{x:m},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(m),g}var B4={kernelName:zr,backendName:"webgl",kernelFunc:z4};function W4(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=r,o=Sa.parseAxisParam(i,a.shape)[0],l=Qx.prepareSplitSize(a,s,o),u=a.shape.length,p=new Array(u).fill(0),c=a.shape.slice();return l.map((e=>{let t=[...c];t[o]=e;let r=zY({inputs:{x:a},backend:n,attrs:{begin:p,size:t}});return p[o]+=e,r}))}var U4={kernelName:Fr,backendName:"webgl",kernelFunc:W4},V4="return sqrt(x);",G4=JX({opSnippet:V4,packedOpSnippet:V4,cpuKernelImpl:DK}),H4={kernelName:Ar,backendName:"webgl",kernelFunc:G4},j4="return x * x;",q4=JX({opSnippet:j4}),K4={kernelName:Wr,backendName:"webgl",kernelFunc:q4},X4="return (a - b) * (a - b);",J4=YX({opSnippet:X4,packedOpSnippet:X4}),Y4={kernelName:Br,backendName:"webgl",kernelFunc:J4};function Z4(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");let s=n.readSync(a.dataId),i=Qx.fromUint8ToStringArray(s),o=MK(i,"string",r);return n.makeTensorInfo(a.shape,"string",o)}var Q4={kernelName:Ur,backendName:"webgl",kernelFunc:Z4};function e6({inputs:e,attrs:t,backend:n}){let{x:r}=e,a=sX+`\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `,s=new aX(r.shape,a);return n.runWebGLProgram(s,[r],r.dtype)}var t6={kernelName:sa,backendName:"webgl",kernelFunc:e6},n6=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;let r=n.length,a=uq(n.length),s=uq(n.length),i="";if(1===r)i="coords * strides + begin";else{let e=0;i=n.map(((t,r)=>(e++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${e-1}] * strides[${r}] + begin[${r}]`))).join(",")}this.userCode=`\n      ${a} begin = ${a}(${e});\n      ${a} strides = ${a}(${t});\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${i}));\n      }\n    `}};function r6(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{begin:i,end:o,strides:l,beginMask:u,endMask:p,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=a,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:y,isSimpleSlice:b,begin:x,end:v,strides:w}=Tx.sliceInfo(s.shape,i,o,l,u,p,c,d,h);if(g)t=iJ({inputs:{x:s},backend:r,attrs:{shape:m}});else if(y||b){Sa.assert(s.shape.length>=1,(()=>`Input must have rank at least 1, got: ${s.shape.length}`));let e=Tx.computeOutShape(x,v,w),n=zY({inputs:{x:s},backend:r,attrs:{begin:x,size:e}});t=iJ({inputs:{x:n},backend:r,attrs:{shape:m}}),r.disposeIntermediateTensorInfo(n)}else if(r.shouldExecuteOnCPU([s])){let e=r.readSync(s.dataId),n=xo(s.shape,s.dtype,e),a=OK(f,n,w,x);t=r.makeTensorInfo(m,s.dtype,a.values)}else{let e=new n6(x,w,f);t=r.runWebGLProgram(e,[s],s.dtype)}let k=iJ({inputs:{x:t},backend:r,attrs:{shape:m}});return r.disposeIntermediateTensorInfo(t),k}var a6={kernelName:Vr,backendName:"webgl",kernelFunc:r6};function s6(e){let{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:p,dataSplits:c}=t,d=n.readSync(p.dataId),h=n.readSync(c.dataId),[f,m]=PK(d,h,a,s,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(c.shape,"int32",m)]}var i6={kernelName:Gr,backendName:"webgl",kernelFunc:s6};function o6(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:s,delimiter:i}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=n.readSync(s.dataId),l=n.readSync(i.dataId)[0],[u,p,c]=LK(o,l,a),d=p.length;return[n.makeTensorInfo([d,2],"int32",u),n.makeTensorInfo([d],"string",p),n.makeTensorInfo([2],"int32",new Int32Array(c))]}var l6={kernelName:Hr,backendName:"webgl",kernelFunc:o6};function u6(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");let i=n.readSync(s.dataId),o=zK(i,a);return n.makeTensorInfo(s.shape,"int32",o)}var p6={kernelName:jr,backendName:"webgl",kernelFunc:u6},c6="return tan(x);",d6=JX({opSnippet:c6}),h6={kernelName:Kr,backendName:"webgl",kernelFunc:d6},f6="\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n",m6=JX({opSnippet:f6}),g6={kernelName:Xr,backendName:"webgl",kernelFunc:m6};function y6(e){let{inputs:t,backend:n,attrs:r}=e,{tensor:a,indices:s,updates:i}=t,{}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:p,outputSize:c}=Qx.calculateShapes(i,s,a.shape),d=[c/u,u];if(0===c)return n.makeTensorInfo(a.shape,s.dtype);let h=iJ({inputs:{x:s},backend:n,attrs:{shape:[l,o]}}),f=iJ({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),m=iJ({inputs:{x:a},backend:n,attrs:{shape:d}}),g=new Q3(l,o,h.shape.length,f.shape.length,p,d,!1,!0),y=n.runWebGLProgram(g,[f,h,m],m.dtype),b=iJ({inputs:{x:y},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),b}var b6={kernelName:vr,backendName:"webgl",kernelFunc:y6},x6=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[s]*t[s];this.outputShape=n,this.rank=n.length;let r=uq(this.rank),a=v6(e);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${a}));\n      }\n    `}};function v6(e){let t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let a=0;a<e.length;a++)r.push(`imod(${n[a]}, ${e[a]})`);return r.join()}function w6(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:s}=r;if("string"===a.dtype||a.shape.length>5){let e=n.readSync(a.dataId),t="string"===a.dtype?e.map((e=>Sa.decodeString(e))):e,r=xo(a.shape,a.dtype,t),i=WK(r,s);return n.makeTensorInfo(i.shape,i.dtype,i.values)}let i=new x6(a.shape,s);return n.runWebGLProgram(i,[a],a.dtype)}var k6={kernelName:Jr,backendName:"webgl",kernelFunc:w6},I6=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}},S6=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}};function N6(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function T6(e){let t=1;for(;t<e;)t*=2;return t}function _6(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:i}=r,o=We().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=We().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=a.shape,p=u[u.length-1];if(n.shouldExecuteOnCPU([a])||p<o||s>l){let e=n.readSync(a.dataId),[t,r]=UK(e,u,a.dtype,s,i);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===s)return u[u.length-1]=0,[n.makeTensorInfo(u,a.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(1===p)return[a,u0({attrs:{shape:u,dtype:"int32",value:0},backend:n})];let c=n.texData.get(a.dataId),d=null!==c&&c.isPacked,h=d?n.unpackTensor(a):a,f=Sa.sizeFromShape(u)/p,m=iJ({inputs:{x:h},attrs:{shape:[f,p]},backend:n});d&&N6(n,h);let g=T6(s),y=T6(p),b=null,x=()=>null===b?[m,m]:[m,b],v=(e,t,r)=>{let a=x(),s=new I6(r),i=[[p],[null===b?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],o=b;b=n.runWebGLProgram(s,a,"int32",i),N6(n,o)};for(let N=1;N<g;N*=2){let e=2*N;for(let t=N;t>=1;t/=2)v(e,t,[f,y])}for(let N=y;N>g;N/=2){let e=x(),t=new S6([f,N/2]),r=[[p],[null===b?1:0],[g]],a=b;b=n.runWebGLProgram(t,e,"int32",r),N6(n,a);let s=g/2,i=2*s;for(let n=s;n>=1;n/=2)v(i,n,b.shape)}let w=b;b=zY({inputs:{x:b},backend:n,attrs:{begin:0,size:[f,s]}}),N6(n,w);let k=M0({inputs:{x:m,indices:b},backend:n,attrs:{axis:1,batchDims:1}});N6(n,m);let I=u.slice(0,-1);I.push(s),w=b,b=iJ({inputs:{x:b},attrs:{shape:I},backend:n}),N6(n,w);let S=k;return k=iJ({inputs:{x:k},attrs:{shape:I},backend:n}),N6(n,S),[k,b]}var C6={kernelName:Yr,backendName:"webgl",kernelFunc:_6},E6=class{constructor(e,t,n,r,a,s){this.variableNames=["Image","Transforms"],this.outputShape=s;let i,o="nearest"===n?1:2;switch(r){case"constant":i=1;break;case"reflect":i=2;break;case"wrap":i=3;break;case"nearest":i=4;break;default:i=1;break}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${i} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${i} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${i} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${a});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${a});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${o} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}};function A6(e){let{inputs:t,backend:n,attrs:r}=e,{image:a,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=r,[p,c,d,h]=a.shape,[f,m]=null!=u?u:[c,d],g=[p,f,m,h],y=new E6(c,d,i,o,l,g);return n.runWebGLProgram(y,[a,s],"float32")}var $6={kernelName:Zr,backendName:"webgl",kernelFunc:A6};function R6(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t;cj(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let i=r.readSync(s.dataId),{outputValues:o,outputShape:l,indices:u}=GK(i,a,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}var F6={kernelName:ea,backendName:"webgl",kernelFunc:R6};function D6(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:s}=r;s<0&&(s+=a.shape.length);let i=a,o=i.shape.length,l=a.shape[s],u=new Array(o-1),p=0;for(let m=0;m<o;m++)m!==s&&(u[p++]=i.shape[m]);let c=[],d=new Array(o).fill(0),h=i.shape.slice();h[s]=1;let f=new Array(l);for(let m=0;m<f.length;m++){d[s]=m;let e=zY({inputs:{x:i},backend:n,attrs:{begin:d,size:h}}),t=iJ({inputs:{x:e},backend:n,attrs:{shape:u}});f[m]=t,c.push(e)}return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}var M6={kernelName:ta,backendName:"webgl",kernelFunc:D6},O6=class{constructor(e,t){this.variableNames=["x","segmentIds"];let n=e.windowSize,r=e.batchSize,a=e.inSize,s=e.numSegments,i=s*Math.ceil(a/n);this.outputShape=[r,i];let o="0.0",l="sumValue",u=4*Math.floor(n/4),p=n%4,c="\n        sumValue += dot(values, segFilter);\n    ",d="";a%n>0&&(d=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `);let h="";a%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${o};\n\n      float getValue(int batch, int inIdx) {\n        ${d}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${h}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${s})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${s})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${c}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===p}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${c}\n        } else if (${2===p}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${c}\n        } else if (${3===p}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${c}\n        }\n        setOutput(${l});\n      }\n    `}};function P6(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:s}=t,{numSegments:i}=r,o=a.shape.length,l=[],u=0,p=Qx.getAxesPermutation([u],o),c=a;null!=p&&(c=xJ({inputs:{x:a},backend:n,attrs:{perm:p}}),l.push(c),u=Qx.getInnerMostAxes(1,o)[0]);let d=Qx.segment_util.computeOutShape(c.shape,u,i),h=Sa.sizeFromShape([c.shape[u]]),f=iJ({inputs:{x:c},backend:n,attrs:{shape:[-1,h]}});l.push(f);let m=Es(a.dtype),g=(e,t,r,a,s)=>{let i=e.shape[0],o=e.shape[1],u=Qx.segment_util.segOpComputeOptimalWindowSize(o,s),p={windowSize:u,inSize:o,batchSize:i,numSegments:s},c=new O6(p,t),d=n.compileAndRun(c,[e,r],a);if(l.push(d),d.shape[1]===s)return d;let h=f3({backend:n,attrs:{start:0,stop:s,step:1,dtype:"float32"}}),f=w6({inputs:{x:h},backend:n,attrs:{reps:[o/u]}});return l.push(h),l.push(f),g(d,t,f,a,s)},y=g(f,"unsortedSegmentSum",s,m,i),b=iJ({inputs:{x:y},backend:n,attrs:{shape:d}}),x=b;if(null!=p){l.push(b);let e=Qx.getUndoAxesPermutation(p);x=xJ({inputs:{x:x},backend:n,attrs:{perm:e}})}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),x}var L6,z6,B6,W6={kernelName:na,backendName:"webgl",kernelFunc:P6},U6=[SJ,_J,AJ,FJ,OJ,BJ,UJ,GJ,YJ,QJ,nY,sY,lY,dY,mY,xY,wY,NY,_Y,EY,FY,UY,GY,jY,tZ,aZ,lZ,BX,dZ,wZ,AZ,OZ,zZ,WZ,VZ,jZ,JZ,QZ,nQ,lQ,pQ,dQ,mQ,xQ,IQ,NQ,CQ,$Q,FQ,PQ,WQ,HQ,KQ,ZQ,e0,r0,o0,c0,h0,g0,v0,I0,_0,E0,R0,O0,B0,G0,LX,j0,yZ,X0,Z0,t1,GX,s1,u1,c1,m1,b1,k1,N1,E1,F1,O1,z1,V1,H1,q1,Y1,Q1,t2,r2,s2,u2,h2,y2,E2,aJ,F2,O2,z2,U2,XY,H2,X2,Y2,t3,s3,KX,o3,u3,c3,h3,m3,YY,k2,b3,k3,T3,oJ,A3,F3,P3,B3,G3,j3,X3,Z3,n4,s4,l4,c4,m4,b4,k4,N4,BY,_2,C4,A4,R4,D4,O4,L4,B4,U4,H4,K4,Y4,Q4,t6,a6,i6,l6,p6,N2,bJ,h6,g6,b6,k6,C6,$6,vJ,F6,M6,W6,q2];for(let cle of U6)ba(cle);function V6(e){B6=e.wasm.cwrap(la,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])}function G6(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:s,bias:i,preluActivationWeights:o}=t;if("float32"!==a.dtype||"float32"!==s.dtype)throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");let{transposeA:l,transposeB:u,activation:p,leakyreluAlpha:c}=r,d=n.dataIdMap.get(a.dataId).id,h=n.dataIdMap.get(s.dataId).id,f=0;if(null!=i){let e=n.dataIdMap.get(i.dataId);if(1!==e.shape.length)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${e.shape.length}.`);f=e.id}let m=null==o?0:n.dataIdMap.get(o.dataId).id,g=z6[p];if(null==g)throw new Error(`${p} activation not yet supported for FusedConv2D in the wasm backend.`);let y=l?a.shape[2]:a.shape[1],b=u?s.shape[1]:s.shape[2],x=bp.assertAndGetBroadcastShape(a.shape.slice(0,-2),s.shape.slice(0,-2)),v=n.makeOutput([...x,y,b],a.dtype),w=n.dataIdMap.get(v.dataId).id,k=new Uint8Array(new Int32Array(a.shape).buffer),I=new Uint8Array(new Int32Array(s.shape).buffer);return B6(d,k,a.shape.length,h,I,s.shape.length,l,u,g,f,m,c||0,w),v}(function(e){e[e.float32=0]="float32",e[e.int32=1]="int32",e[e.bool=2]="bool",e[e.string=3]="string",e[e.complex64=4]="complex64"})(L6||(L6={})),function(e){e[e.linear=0]="linear",e[e.relu=1]="relu",e[e.relu6=2]="relu6",e[e.prelu=3]="prelu",e[e.leakyrelu=4]="leakyrelu",e[e.sigmoid=5]="sigmoid",e[e.elu=6]="elu"}(z6||(z6={}));var H6={kernelName:la,backendName:"wasm",setupFunc:V6,kernelFunc:G6};function j6(e,t){let n;function r(t){n=t.wasm.cwrap(e,null,["number","number","number"])}function a(e){let{backend:r,inputs:{x:a}}=e,s=r.dataIdMap.get(a.dataId).id,i=r.makeOutput(a.shape,t||a.dtype),o=r.dataIdMap.get(i.dataId).id;return 0===Sa.sizeFromShape(i.shape)||n(s,L6[a.dtype],o),i}return{kernelName:e,backendName:"wasm",setupFunc:r,kernelFunc:a}}var q6=j6(Ke),K6=j6(Xe),X6=j6(Je);function J6(e,t,n){let r;function a(t){r=t.wasm.cwrap(e,null,["number","array","number","number","array","number","number","number"])}function s(e){let{backend:t,inputs:a}=e,{a:s,b:i}=a,o=t.dataIdMap.get(s.dataId).id,l=t.dataIdMap.get(i.dataId).id,u=null!=n?n:s.dtype,p=Qx.assertAndGetBroadcastShape(s.shape,i.shape),c=t.makeOutput(p,u);if(0===Sa.sizeFromShape(p))return c;let d=new Uint8Array(new Int32Array(s.shape).buffer),h=new Uint8Array(new Int32Array(i.shape).buffer),f=t.dataIdMap.get(c.dataId).id;return r(o,d,s.shape.length,l,h,i.shape.length,L6[s.dtype],f),c}return{kernelName:e,backendName:"wasm",setupFunc:a,kernelFunc:s}}var Y6,Z6=!0,Q6=J6(Ye,Z6);function e5(e){Y6=e.wasm.cwrap(Ze,null,["array","number","number","number"])}function t5(e){let{inputs:t,backend:n}=e,r=n.makeOutput(t[0].shape,t[0].dtype);if(0===Sa.sizeFromShape(r.shape))return r;let a=t.map((e=>n.dataIdMap.get(e.dataId).id)),s=new Uint8Array(new Int32Array(a).buffer),i=n.dataIdMap.get(r.dataId).id;return Y6(s,a.length,L6[r.dtype],i),r}var n5={kernelName:Ze,backendName:"wasm",setupFunc:e5,kernelFunc:t5};function r5(e){let{inputs:{x:t},backend:n}=e;if("string"===t.dtype)return li(n.readSync(t.dataId),t.shape,t.dtype);let r=n.makeOutput(t.shape,t.dtype),a=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(r).set(a),r}var a5,s5={kernelName:un,backendName:"wasm",kernelFunc:r5};function i5(e){a5=e.wasm.cwrap(Qr,null,["number","array","number","number","number","array","number"])}function o5(e){let{inputs:t,backend:n,attrs:r}=e,[a,s]=u5(t.x.shape,r.perm),i=!0;for(let f=0;f<s.length;f++)s[f]!==f&&(i=!1);let o=l5(t.x.shape,r.perm),l={dataId:t.x.dataId,shape:a,dtype:t.x.dtype};if(i){let e=r5({inputs:t,backend:n});return e.shape=o,e}let u=n.makeOutput(o,l.dtype),p=n.dataIdMap.get(l.dataId).id,c=n.dataIdMap.get(u.dataId).id,d=new Uint8Array(new Int32Array(s).buffer),h=new Uint8Array(new Int32Array(l.shape).buffer);return a5(p,h,l.shape.length,L6[l.dtype],c,d,s.length),u}function l5(e,t){let n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];return n}function u5(e,t){let n=[],r=[];for(let a=0;a<e.length;++a)1!==e[a]&&n.push(e[a]),1!==e[t[a]]&&r.push(t[a]);for(let a=0;a<r.length;++a){let e=-1;for(let t=0;t<r.length;++t)r[t]>=a&&(-1===e||r[e]>r[t])&&(e=t);r[e]=a}return[n,r]}var p5,c5={kernelName:Qr,backendName:"wasm",kernelFunc:o5,setupFunc:i5};function d5(e,t,n){let r=e.shape,a=e.shape.length,s=Sa.parseAxisParam(t,r),i=s,o=Qx.getAxesPermutation(i,a),l=null,u=!1;if(null!=o){let t=new Array(a);for(let e=0;e<t.length;e++)t[e]=r[o[e]];i=Qx.getInnerMostAxes(i.length,a),l=o5({inputs:{x:e},attrs:{perm:o},backend:n});let s=n.dataIdMap.get(e.dataId).id;n.dataIdMap.get(l.dataId).id!==s&&(u=!0)}return{transposed:l,originalAxes:s,axes:i,inputWasTransposed:u}}function h5(e){p5=e.wasm.cwrap(Qe,null,["number, number, number"])}function f5(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:u,axes:p,originalAxes:c,inputWasTransposed:d}=d5(i,a,t);if(d){let e=t.dataIdMap.get(u.dataId).id;l=u,o=e}let h=l.shape.length;Qx.assertAxesAreInnerMostDims("all",p,h);let[f,m]=Qx.computeOutAndReduceShapes(l.shape,p),g=Sa.sizeFromShape(m),y=t.makeOutput(f,i.dtype);if(0!==Sa.sizeFromShape(l.shape)){let e=t.dataIdMap.get(y.dataId).id;p5(o,g,e)}if(d&&t.disposeData(u.dataId),s){let e=Qx.expandShapeToKeepDim(y.shape,c);y.shape=e}return y}var m5,g5={kernelName:Qe,backendName:"wasm",setupFunc:h5,kernelFunc:f5};function y5(e){m5=e.wasm.cwrap(et,null,["number, number, number"])}function b5(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:u,axes:p,originalAxes:c,inputWasTransposed:d}=d5(i,a,t);if(d){let e=t.dataIdMap.get(u.dataId).id;l=u,o=e}let h=l.shape.length;Qx.assertAxesAreInnerMostDims("any",p,h);let[f,m]=Qx.computeOutAndReduceShapes(l.shape,p),g=Sa.sizeFromShape(m),y=t.makeOutput(f,i.dtype);if(0!==Sa.sizeFromShape(l.shape)){let e=t.dataIdMap.get(y.dataId).id;m5(o,g,e)}if(d&&t.disposeData(u.dataId),s){let e=Qx.expandShapeToKeepDim(y.shape,c);y.shape=e}return y}var x5={kernelName:et,backendName:"wasm",setupFunc:y5,kernelFunc:b5};function v5(e){let t;function n(n){t=n.wasm.cwrap(e,null,["number","number","number","number","number"])}function r(e){let{backend:n,inputs:r,attrs:a}=e,{axis:s}=a,{x:i}=r,o=n.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:p,axes:c,inputWasTransposed:d}=d5(i,s,n);if(d){let e=n.dataIdMap.get(p.dataId).id;e!==o&&(u=p,l=e)}let h=u.shape.slice(0,-1),f=n.makeOutput(h,"int32"),m=n.dataIdMap.get(f.dataId).id,g=Sa.sizeFromShape(f.shape),y=u.shape[c[0]];return t(l,L6[u.dtype],g,y,m),d&&n.disposeData(p.dataId),f}return{kernelName:e,backendName:"wasm",setupFunc:n,kernelFunc:r}}var w5,k5=v5(tt),I5=v5(nt),S5=j6(rt),N5=j6(at),T5=j6(st),_5=J6(ot,!1),C5=j6(it);function E5(e){w5=e.wasm.cwrap(lt,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function A5(e){let{inputs:t,attrs:n,backend:r}=e,a=t.x,s=r.dataIdMap.get(a.dataId).id,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=n,p=Qx.computePool2DInfo(a.shape,i,o,1,l,u),c=p.filterHeight,d=p.filterWidth,h=p.padInfo.top,f=p.padInfo.right,m=p.padInfo.bottom,g=p.padInfo.left,y=p.strideHeight,b=p.strideWidth,x=p.inChannels;if("channelsLast"!==p.dataFormat)throw new Error(`wasm backend does not support dataFormat:'${p.dataFormat}'. Please use 'channelsLast'.`);if(1!==p.dilationWidth||1!==p.dilationHeight)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${p.dilationHeight}, ${p.dilationWidth}].`);let v=r.makeOutput(p.outShape,"float32"),w=r.dataIdMap.get(v.dataId).id;return w5(s,a.shape[0],a.shape[1],a.shape[2],c,d,h,f,m,g,y,b,x,w),v}var $5,R5={kernelName:lt,backendName:"wasm",setupFunc:E5,kernelFunc:A5};function F5(e){$5=e.wasm.cwrap("AvgPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function D5(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,p=Qx.computePool3DInfo(a.shape,s,i,1,o,l,u),c=n.makeOutput(p.outShape,a.dtype);return $5(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(c.dataId).id,p.batchSize,p.inChannels,p.inDepth,p.inHeight,p.inWidth,p.outDepth,p.outHeight,p.outWidth,p.strideDepth,p.strideHeight,p.strideWidth,p.dilationDepth,p.dilationHeight,p.dilationWidth,p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth,p.padInfo.front,p.padInfo.top,p.padInfo.left),c}var M5,O5={kernelName:pt,backendName:"wasm",setupFunc:F5,kernelFunc:D5};function P5(e){M5=e.wasm.cwrap("AvgPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function L5(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r,p=Qx.computePool3DInfo(s.shape,i,o,1,l,u),c=n.makeOutput(s.shape,s.dtype);return M5(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(c.dataId).id,p.batchSize,p.inChannels,p.inDepth,p.inHeight,p.inWidth,p.outDepth,p.outHeight,p.outWidth,p.strideDepth,p.strideHeight,p.strideWidth,p.dilationDepth,p.dilationHeight,p.dilationWidth,p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth,p.padInfo.front,p.padInfo.top,p.padInfo.left,p.filterDepth,p.filterHeight,p.filterWidth),c}var z5={kernelName:ct,backendName:"wasm",setupFunc:P5,kernelFunc:L5};function B5(e){let{inputs:t,attrs:n}=e,{x:r}=t,{shape:a}=n,s=Sa.sizeFromShape(r.shape),i=Sa.inferFromImplicitShape(a,s);return Sa.assert(s===Sa.sizeFromShape(i),(()=>`new shape: ${i}, old shape: ${r.shape}. New shape and old shape must have the same number of elements.`)),e.backend.incRef(r.dataId),{dataId:r.dataId,shape:i,dtype:r.dtype}}var W5,U5={kernelName:pr,backendName:"wasm",kernelFunc:B5};function V5(e){W5=e.wasm.cwrap(dt,null,["number","array","number","number","array","number","number","number","number"])}function G5(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:s}=t,{transposeA:i,transposeB:o}=r;if("float32"!==a.dtype||"float32"!==s.dtype)throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");let l=a.shape.length,u=s.shape.length,p=i?a.shape[l-2]:a.shape[l-1],c=o?s.shape[u-1]:s.shape[u-2],d=i?a.shape[l-1]:a.shape[l-2],h=o?s.shape[u-2]:s.shape[u-1],f=a.shape.slice(0,-2),m=s.shape.slice(0,-2),g=Sa.sizeFromShape(f),y=Sa.sizeFromShape(m),b=bp.assertAndGetBroadcastShape(a.shape.slice(0,-2),s.shape.slice(0,-2)).concat([d,h]);Sa.assert(p===c,(()=>`Error in matMul: inner shapes (${p}) and (${c}) of Tensors with shapes ${a.shape} and ${s.shape} and transposeA=${i} and transposeB=${o} must match.`));let x=i?[g,p,d]:[g,d,p],v=o?[y,h,c]:[y,c,h],w=B5({inputs:{x:a},backend:n,attrs:{shape:x}}),k=B5({inputs:{x:s},backend:n,attrs:{shape:v}}),I=n.dataIdMap.get(w.dataId).id,S=n.dataIdMap.get(k.dataId).id,N=i?w.shape[2]:w.shape[1],T=o?k.shape[1]:k.shape[2],_=Math.max(g,y),C=n.makeOutput([_,N,T],w.dtype),E=n.dataIdMap.get(C.dataId).id,A=new Uint8Array(new Int32Array(w.shape).buffer),$=new Uint8Array(new Int32Array(k.shape).buffer);return W5(I,A,w.shape.length,S,$,k.shape.length,i,o,E),n.disposeData(w.dataId),n.disposeData(k.dataId),C.shape=b,C}var H5={kernelName:dt,backendName:"wasm",setupFunc:V5,kernelFunc:G5};function j5(e){let{inputs:{x:t},attrs:{begin:n,size:r},backend:a}=e,[s,i]=Tx.parseSliceParams(t,n,r),o=Tx.isSliceContinous(t.shape,s,i),l=a.readSync(t.dataId),u=a.makeOutput(i,t.dtype),p=Sa.computeStrides(t.shape),c=a.dataIdMap.get(u.dataId);if(o){let e=Tx.computeFlatOffset(s,p);return"string"===t.dtype?c.stringBytes=l.slice(e,e+Sa.sizeFromShape(i)):a.typedArrayFromHeap(u).set(l.subarray(e,e+Sa.sizeFromShape(i))),u}if("string"===t.dtype){let e=_L(l,s,i,t.shape,t.dtype);return c.stringBytes=e,u}let d=a.typedArrayFromHeap(u),h=t.shape.length;if(2===h)q5(l,p[0],d,s,i);else if(3===h)K5(l,p[0],p[1],d,s,i);else if(4===h)X5(l,p[0],p[1],p[2],d,s,i);else{let e=_L(l,s,i,t.shape,t.dtype);d.set(e)}return u}function q5(e,t,n,r,a){let s=0,i=r[0],o=r[1],l=i+a[0];for(let u=i;u<l;u++){let r=u*t+o;n.set(e.subarray(r,r+a[1]),s),s+=a[1]}}function K5(e,t,n,r,a,s){let i=0,o=a[0],l=a[1],u=a[2],p=o+s[0],c=l+s[1];for(let d=o;d<p;d++)for(let a=l;a<c;a++){let o=d*t+a*n+u;r.set(e.subarray(o,o+s[2]),i),i+=s[2]}}function X5(e,t,n,r,a,s,i){let o=0,l=s[0],u=s[1],p=s[2],c=l+i[0],d=u+i[1],h=p+i[2],f=s[3];for(let m=l;m<c;m++)for(let s=u;s<d;s++)for(let l=p;l<h;l++){let u=m*t+s*n+l*r+f;a.set(e.subarray(u,u+i[3]),o),o+=i[3]}}var J5={kernelName:Sr,backendName:"wasm",kernelFunc:j5};function Y5(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r,o=s.reduce(((e,t)=>e*t)),l=Qx.getReshaped(a.shape,s,o),u=Qx.getPermuted(l.length,s.length),p=Qx.getReshapedPermuted(a.shape,s,o),c=Qx.getSliceBeginCoords(i,s.length),d=Qx.getSliceSize(p,i,s.length),h=B5({inputs:{x:a},backend:n,attrs:{shape:l}}),f=o5({inputs:{x:h},backend:n,attrs:{perm:u}}),m=B5({inputs:{x:f},backend:n,attrs:{shape:p}}),g=j5({inputs:{x:m},backend:n,attrs:{begin:c,size:d}});return n.disposeData(h.dataId),n.disposeData(f.dataId),n.disposeData(h.dataId),g}var Z5,Q5={kernelName:ht,backendName:"wasm",kernelFunc:Y5};function e8(e){Z5=e.wasm.cwrap(ft,null,["number","number","boolean","number","number","number"])}function t8(e){let{backend:t,inputs:n,attrs:r}=e,{x:a,weights:s}=n,{size:i}=r,o=0!==s.shape.reduce(((e,t)=>e*t),1),l=1===a.shape.length?[i]:[a.shape[0],i],u=t.makeOutput(l,s.dtype);function p(e){return t.dataIdMap.get(e.dataId).id}return Z5(p(a),i,o,p(s),L6[s.dtype],p(u)),u}var n8={kernelName:ft,backendName:"wasm",setupFunc:e8,kernelFunc:t8};function r8(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.typedArrayFromHeap(r),i=n.typedArrayFromHeap(a),o=Qx.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeOutput([o.length],"int32",void 0,new Int32Array(o))}var a8={kernelName:gt,backendName:"wasm",kernelFunc:r8};function s8(e){let{inputs:{x:t},attrs:{dtype:n},backend:r}=e,a=r.makeOutput(t.shape,n),s=r.typedArrayFromHeap(t);return r.typedArrayFromHeap(a).set(s),a}var i8,o8={kernelName:yt,backendName:"wasm",kernelFunc:s8},l8=j6(bt);function u8(e){i8=e.wasm.cwrap(xt,null,["number","number","number","number"])}function p8(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{clipValueMin:s,clipValueMax:i}=r,o=n.dataIdMap.get(a.dataId).id,l=n.makeOutput(a.shape,a.dtype),u=n.dataIdMap.get(l.dataId).id;return i8(o,s,i,u),l}var c8={kernelName:xt,backendName:"wasm",setupFunc:u8,kernelFunc:p8};function d8(e){let{inputs:t,backend:n}=e,r=Sa.parseAxisParam(e.attrs.axis,t[0].shape)[0],a=t.map((e=>e.shape));Qx.assertParamsConsistent(a,r);let s=Qx.computeOutShape(t.map((e=>e.shape)),r),i=t.filter((e=>Sa.sizeFromShape(e.shape)>0));if(1===i.length)return r5({inputs:{x:i[0]},backend:n});let o=n.makeOutput(s,t[0].dtype);if(0===Sa.sizeFromShape(s))return o;if("string"===i[0].dtype){let e=i.map((e=>{let t=[-1,Sa.sizeFromShape(e.shape.slice(r))];return B5({inputs:{x:e},backend:n,attrs:{shape:t}})})),a=e.map((e=>({vals:n.readSync(e.dataId),shape:e.shape})));s=Qx.computeOutShape(e.map((e=>e.shape)),1);let l=1===e[0].shape[0],u=tP(a,s,t[0].dtype,l),p=Qx.computeOutShape(i.map((e=>e.shape)),r);o.shape=p;let c=n.dataIdMap.get(o.dataId);return c.stringBytes=Qx.fromStringArrayToUint8(u),e.forEach((e=>n.disposeData(e.dataId))),o}let l=Sa.sizeFromShape(i[0].shape.slice(0,r)),u=0,p=i.map((e=>{let t=Sa.sizeFromShape(e.shape.slice(r));return u+=t,t})),c=i.map((e=>n.typedArrayFromHeap(e))),d=n.typedArrayFromHeap(o);for(let h=0;h<l;h++){let e=h*u;for(let t=0;t<c.length;t++){let n=p[t],r=h*n,a=c[t].subarray(r,r+n);d.set(a,e),e+=n}}return o}var h8,f8={kernelName:kt,backendName:"wasm",kernelFunc:d8};function m8(e){h8=e.wasm.cwrap(It,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function g8(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s}=t,i=r.dataIdMap.get(a.dataId).id,o=r.dataIdMap.get(s.dataId).id,{strides:l,dilations:u,pad:p,dimRoundingMode:c,dataFormat:d}=n,h=Qx.convertConv2DDataFormat(d),f=Qx.computeConv2DInfo(a.shape,s.shape,l,u,p,c,!1,h),m=f.filterHeight,g=f.filterWidth,y=f.padInfo.top,b=f.padInfo.right,x=f.padInfo.bottom,v=f.padInfo.left,w=f.dilationHeight,k=f.dilationWidth,I=f.strideHeight,S=f.strideWidth,N=f.inChannels,T=f.outChannels,_="SAME"===f.padInfo.type?1:0;if("channelsLast"!==f.dataFormat)throw new Error(`wasm backend Conv2D does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);let C=r.makeOutput(f.outShape,"float32"),E=r.dataIdMap.get(C.dataId).id;return h8(i,a.shape[0],a.shape[1],a.shape[2],o,m,g,y,b,x,v,_,w,k,I,S,N,T,E),C}var y8,b8={kernelName:It,backendName:"wasm",setupFunc:m8,kernelFunc:g8};function x8(e){y8=e.wasm.cwrap(Nt,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function v8(e){let{backend:t,inputs:n,attrs:r}=e,{dy:a,filter:s}=n,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,inputShape:p}=r,c=1,d=Qx.convertConv2DDataFormat(l),h=Qx.computeConv2DInfo(p,s.shape,i,c,o,u,!1,d),{batchSize:f,filterHeight:m,filterWidth:g,inChannels:y,inHeight:b,inWidth:x,outChannels:v,outHeight:w,outWidth:k,strideHeight:I,strideWidth:S}=h,N=m-1-h.padInfo.top,T=g-1-h.padInfo.left,_="channelsLast"===h.dataFormat,C=Sa.computeStrides(h.inShape),E=Sa.computeStrides(a.shape),[A,$,R]=Sa.computeStrides(s.shape),F=C[0],D=_?C[1]:C[2],M=_?C[2]:1,O=_?1:C[1],P=E[0],L=_?E[1]:E[2],z=_?E[2]:1,B=_?1:E[1],W=t.makeOutput(h.inShape,"float32"),U=t.dataIdMap.get(W.dataId).id,V=t.dataIdMap.get(a.dataId).id,G=t.dataIdMap.get(s.dataId).id;return y8(V,G,f,m,g,b,x,y,w,k,v,I,S,N,T,A,$,R,F,D,M,O,P,L,z,B,U),W}var w8,k8={kernelName:Nt,backendName:"wasm",setupFunc:x8,kernelFunc:v8};function I8(e){w8=e.wasm.cwrap(Tt,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function S8(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r;if("float32"!==a.dtype)throw new Error(`Tensor x must have dtype float32, got ${a.dtype}`);if("float32"!==s.dtype)throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let u=Qx.computeConv3DInfo(a.shape,s.shape,i,l,o),p=n.makeOutput(u.outShape,a.dtype);return w8(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(p.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),p}var N8,T8={kernelName:Tt,backendName:"wasm",setupFunc:I8,kernelFunc:S8};function _8(e){N8=e.wasm.cwrap(_t,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function C8(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=r;if("float32"!==a.dtype)throw new Error(`Tensor dy must have dtype float32, got ${a.dtype}`);if("float32"!==s.dtype)throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let u=Qx.computeConv3DInfo(a.shape,l,i,1,o),p=n.makeOutput(u.filterShape,s.dtype);return N8(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(p.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),p}var E8,A8={kernelName:_t,backendName:"wasm",setupFunc:_8,kernelFunc:C8};function $8(e){E8=e.wasm.cwrap(Ct,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function R8(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=r;if("float32"!==a.dtype)throw new Error(`Tensor dy must have dtype float32, got ${a.dtype}`);if("float32"!==s.dtype)throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let u=Qx.computeConv3DInfo(l,s.shape,o,1,i),p=n.makeOutput(u.inShape,a.dtype);return E8(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(p.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),p}var F8,D8,M8={kernelName:Ct,backendName:"wasm",setupFunc:$8,kernelFunc:R8},O8=j6(Et),P8=j6(At);function L8(e){D8=e.wasm.cwrap(Ft,null,["number","number","number","number","array","number","number","number","number","number"])}function z8(e){let t,{backend:n,inputs:r,attrs:a}=e,{method:s,extrapolationValue:i,cropSize:o}=a,{image:l,boxes:u,boxInd:p}=r,c=u.shape[0],[d,h]=o,f=[c,d,h,l.shape[3]],m=n.dataIdMap.get(l.dataId);"float32"!==l.dtype&&(t=s8({backend:n,inputs:{x:l},attrs:{dtype:"float32"}}),m=n.dataIdMap.get(t.dataId));let g=m.id,y=n.dataIdMap.get(u.dataId).id,b=n.dataIdMap.get(p.dataId).id,x=n.makeOutput(f,"float32"),v=n.dataIdMap.get(x.dataId).id,w=new Uint8Array(new Int32Array(l.shape).buffer);return D8(g,y,b,c,w,d,h,F8[s],i,v),null!=t&&n.disposeData(t.dataId),x}(function(e){e[e.bilinear=0]="bilinear",e[e.nearest=1]="nearest"})(F8||(F8={}));var B8,W8={kernelName:Ft,backendName:"wasm",setupFunc:L8,kernelFunc:z8};function U8(e){B8=e.wasm.cwrap($t,null,["number","number","number","number","number","number"])}function V8(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r,l=a.shape.length;Sa.assert("float32"===a.dtype||"int32"===a.dtype,(()=>`cumprod does not support ${a.dtype} tensors in the WASM backend`));let u=Qx.getAxesPermutation([s],l),p=a;null!==u&&(p=o5({inputs:{x:a},attrs:{perm:u},backend:n}));let c=Qx.getInnerMostAxes(1,l)[0];Qx.assertAxesAreInnerMostDims("cumprod",[c],l);let d=n.makeOutput(p.shape,p.dtype),h=p.shape[c],f=n.dataIdMap.get(p.dataId).id,m=n.dataIdMap.get(d.dataId).id;B8(f,i?1:0,o?1:0,h,m,L6[a.dtype]);let g=d;if(null!==u){let e=Qx.getUndoAxesPermutation(u);g=o5({inputs:{x:d},attrs:{perm:e},backend:n}),n.disposeData(p.dataId),n.disposeData(d.dataId)}return g}var G8,H8={kernelName:$t,backendName:"wasm",setupFunc:U8,kernelFunc:V8};function j8(e){G8=e.wasm.cwrap(Rt,null,["number","number","number","number","number","number"])}function q8(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r,l=a.shape.length;Sa.assert("float32"===a.dtype||"int32"===a.dtype,(()=>`cumsum does not support ${a.dtype} tensors in the WASM backend`));let u=Qx.getAxesPermutation([s],l),p=a;null!==u&&(p=o5({inputs:{x:a},attrs:{perm:u},backend:n}));let c=Qx.getInnerMostAxes(1,l)[0];Qx.assertAxesAreInnerMostDims("cumsum",[c],l);let d=n.makeOutput(p.shape,p.dtype),h=p.shape[c],f=n.dataIdMap.get(p.dataId).id,m=n.dataIdMap.get(d.dataId).id;G8(f,i?1:0,o?1:0,h,m,L6[a.dtype]);let g=d;if(null!==u){let e=Qx.getUndoAxesPermutation(u);g=o5({inputs:{x:d},attrs:{perm:e},backend:n}),n.disposeData(p.dataId),n.disposeData(d.dataId)}return g}var K8,X8={kernelName:Rt,backendName:"wasm",setupFunc:j8,kernelFunc:q8};function J8(e){K8=e.wasm.cwrap("DenseBincount",null,["number","array","number","number","boolean","number","number","boolean","number"])}function Y8(e){let{backend:t,inputs:n,attrs:r}=e,{x:a,weights:s}=n,{size:i,binaryOutput:o}=r,l=0!==s.shape.reduce(((e,t)=>e*t),1),u=1===a.shape.length?[i]:[a.shape[0],i],p=t.makeOutput(u,s.dtype);function c(e){return t.dataIdMap.get(e.dataId).id}return K8(c(a),new Uint8Array(new Int32Array(a.shape).buffer),a.shape.length,i,l,c(s),L6[s.dtype],o,c(p)),p}var Z8,Q8={kernelName:Dt,backendName:"wasm",setupFunc:J8,kernelFunc:Y8};function e7(e){Z8=e.wasm.cwrap(Mt,null,["number","number","number","array","number","array","array","number","number"])}function t7(e){let{backend:t,inputs:n,attrs:r}=e,{x:a}=n,{blockSize:s,dataFormat:i}=r,o=a.shape[0],l="NHWC"===i?a.shape[1]:a.shape[2],u="NHWC"===i?a.shape[2]:a.shape[3],p="NHWC"===i?a.shape[3]:a.shape[1],c=l*s,d=u*s,h=p/(s*s),f="NHWC"===i?[o,c,d,h]:[o,h,c,d],m=t.makeOutput(f,"float32"),g=t.dataIdMap.get(a.dataId).id,y=new Uint8Array(new Int32Array(Sa.computeStrides(a.shape)).buffer),b=new Uint8Array(new Int32Array(f).buffer),x=new Uint8Array(new Int32Array(Sa.computeStrides(f)).buffer),v=t.dataIdMap.get(m.dataId).id;return Z8(g,s,"NHWC"===i?1:0,y,a.shape.length-1,b,x,f.length,v),m}var n7,r7={kernelName:Mt,backendName:"wasm",setupFunc:e7,kernelFunc:t7};function a7(e){n7=e.wasm.cwrap(Ot,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function s7(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s}=t,i=r.dataIdMap.get(a.dataId).id,o=r.dataIdMap.get(s.dataId).id,{strides:l,dilations:u,pad:p,dimRoundingMode:c}=n,d=null==u?[1,1]:u,h=Qx.computeConv2DInfo(a.shape,s.shape,l,d,p,c,!0),f=h.filterHeight,m=h.filterWidth,g=h.padInfo.top,y=h.padInfo.right,b=h.padInfo.bottom,x=h.padInfo.left,v=h.dilationHeight,w=h.dilationWidth,k=h.strideHeight,I=h.strideWidth,S=h.inChannels,N=h.outChannels,T="SAME"===h.padInfo.type?1:0;if("channelsLast"!==h.dataFormat)throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${h.dataFormat}'. Please use 'channelsLast'.`);let _=r.makeOutput(h.outShape,"float32"),C=r.dataIdMap.get(_.dataId).id;return n7(i,a.shape[0],a.shape[1],a.shape[2],o,f,m,g,y,b,x,T,v,w,k,I,S,N,C),_}var i7,o7={kernelName:Ot,backendName:"wasm",setupFunc:a7,kernelFunc:s7};function l7(e){i7=e.wasm.cwrap("Diag",null,["number","number","number","number"])}function u7(e){let{inputs:t,backend:n}=e,{x:r}=t,a=Sa.sizeFromShape(r.shape),s=n.makeOutput([...r.shape,...r.shape],r.dtype);return i7(n.dataIdMap.get(r.dataId).id,L6[r.dtype],a,n.dataIdMap.get(s.dataId).id),s}var p7,c7={kernelName:zt,backendName:"wasm",setupFunc:l7,kernelFunc:u7};function d7(e){p7=e.wasm.cwrap(Bt,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function h7(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r;if(a.dtype!==s.dtype)throw new Error(`Dilation2D error: x must have the same dtype as filter. Got ${a.dtype} and ${s.dtype}`);let u=Qx.computeDilation2DInfo(a.shape,s.shape,i,o,"NHWC",l),p=n.makeOutput(u.outShape,a.dtype);return p7(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(p.dataId).id,L6[a.dtype],u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.filterHeight,u.filterWidth,u.padInfo.top,u.padInfo.left),p}var f7,m7={kernelName:Bt,backendName:"wasm",setupFunc:d7,kernelFunc:h7};function g7(e){f7=e.wasm.cwrap(Ut,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function y7(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,dy:i}=t,{strides:o,pad:l,dilations:u}=r;if(a.dtype!==s.dtype||a.dtype!==i.dtype)throw new Error(`Dilation2DBackpropFilter error: x must have the same dtype as filter and dy. Got ${a.dtype}, ${s.dtype}, and ${i.dtype}`);let p=Qx.computeDilation2DInfo(a.shape,s.shape,o,l,"NHWC",u),c=n.makeOutput(s.shape,s.dtype);return f7(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(c.dataId).id,L6[a.dtype],p.batchSize,p.inChannels,p.inHeight,p.inWidth,p.outHeight,p.outWidth,p.strideHeight,p.strideWidth,p.dilationHeight,p.dilationWidth,p.filterHeight,p.filterWidth,p.padInfo.top,p.padInfo.left),c}var b7,x7={kernelName:Ut,backendName:"wasm",setupFunc:g7,kernelFunc:y7};function v7(e){b7=e.wasm.cwrap(Wt,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function w7(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,dy:i}=t,{strides:o,pad:l,dilations:u}=r;if(a.dtype!==s.dtype||a.dtype!==i.dtype)throw new Error(`Dilation2DBackpropInput error: x must have the same dtype as filter and dy. Got ${a.dtype}, ${s.dtype}, and ${i.dtype}`);let p=Qx.computeDilation2DInfo(a.shape,s.shape,o,l,"NHWC",u),c=n.makeOutput(a.shape,a.dtype);return b7(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(c.dataId).id,L6[a.dtype],p.batchSize,p.inChannels,p.inHeight,p.inWidth,p.outHeight,p.outWidth,p.strideHeight,p.strideWidth,p.dilationHeight,p.dilationWidth,p.filterHeight,p.filterWidth,p.padInfo.top,p.padInfo.left),c}var k7,I7={kernelName:Wt,backendName:"wasm",setupFunc:v7,kernelFunc:w7},S7=j6(Ht);function N7(e){k7=e.wasm.cwrap(jt,null,["number","number","number"])}function T7(e){let{inputs:t,backend:n}=e,{dy:r,y:a}=t,s=n.makeOutput(a.shape,"float32"),i=e=>n.dataIdMap.get(e.dataId).id;return k7(i(a),i(r),i(s)),s}var _7={kernelName:jt,backendName:"wasm",setupFunc:N7,kernelFunc:T7},C7=!1,E7=J6(Kt,C7,"bool"),A7=j6(Xt,"float32");function $7(e){let{inputs:t,attrs:n,backend:r}=e,{input:a}=t,{dim:s}=n,i=a.shape.length,o=a.shape.slice(),l=s;return s<0&&(Sa.assert(-(i+1)<=s,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),l=i+s+1),o.splice(l,0,1),B5({inputs:{x:a},backend:r,attrs:{shape:o}})}var R7={kernelName:Jt,backendName:"wasm",kernelFunc:$7},F7=j6(Yt,"float32");function D7(e){let{attrs:{shape:t,value:n,dtype:r},backend:a}=e,s=a.makeOutput(t,r);return a.typedArrayFromHeap(s).fill(n),s}var M7,O7={kernelName:Qt,backendName:"wasm",kernelFunc:D7};function P7(e){M7=e.wasm.cwrap(en,null,["number","number","number","number","number","number"])}function L7(e){let{inputs:t,backend:n}=e,{image:r}=t,a=n.makeOutput(r.shape,r.dtype),s=n.dataIdMap.get(r.dataId).id,i=n.dataIdMap.get(a.dataId).id,[o,l,u,p]=r.shape;return M7(s,o,l,u,p,i),a}var z7,B7={kernelName:en,backendName:"wasm",kernelFunc:L7,setupFunc:P7},W7=j6(tn),U7=!1,V7=J6(nn,U7);function G7(e){z7=e.wasm.cwrap(rn,null,["number","number","number","number","number","number","number"])}function H7(e){let{backend:t,inputs:n,attrs:r}=e,{varianceEpsilon:a}=r,{x:s,mean:i,variance:o,offset:l,scale:u}=n,p=t.dataIdMap.get(s.dataId).id,c=t.dataIdMap.get(i.dataId).id,d=t.dataIdMap.get(o.dataId).id,h=null!=l?t.dataIdMap.get(l.dataId).id:0,f=null!=u?t.dataIdMap.get(u.dataId).id:0,m=t.makeOutput(s.shape,s.dtype);if(0===Sa.sizeFromShape(s.shape))return m;let g=t.dataIdMap.get(m.dataId).id;return z7(p,c,d,h,f,a,g),m}var j7,q7={kernelName:rn,backendName:"wasm",setupFunc:G7,kernelFunc:H7};function K7(e){j7=e.wasm.cwrap(ua,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function X7(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:p,dataFormat:c,dimRoundingMode:d,activation:h,leakyreluAlpha:f}=n,m=Qx.computeConv2DInfo(a.shape,s.shape,l,p,u,d),g=z6[h];if(null==g)throw new Error(`${h} activation not yet supported for FusedConv2D in the wasm backend.`);let y=r.dataIdMap.get(a.dataId).id,b=r.dataIdMap.get(s.dataId).id,x=m.outChannels,v=0;if(null!=i){let e=r.dataIdMap.get(i.dataId);if(1!==e.shape.length)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${e.shape.length}.`);if(e.shape[0]!==x)throw new Error(`FusedConv2D bias shape (${e.shape}) does not match the number of output channels (${x})`);v=e.id}let w=m.filterHeight,k=m.filterWidth,I=m.padInfo.top,S=m.padInfo.right,N=m.padInfo.bottom,T=m.padInfo.left,_=m.dilationHeight,C=m.dilationWidth,E=m.strideHeight,A=m.strideWidth,$=m.inChannels,R="SAME"===m.padInfo.type?1:0,F=m.batchSize,D=m.inHeight,M=m.inWidth;if("NHWC"!==c)throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${c}'. Please use 'NHWC'.`);let O=r.makeOutput(m.outShape,"float32"),P=r.dataIdMap.get(O.dataId).id,L=null==o?0:r.dataIdMap.get(o.dataId).id;return j7(y,F,D,M,b,w,k,v,I,S,N,T,R,_,C,E,A,$,x,g,L,f||0,P),O}var J7,Y7={kernelName:ua,backendName:"wasm",setupFunc:K7,kernelFunc:X7};function Z7(e){J7=e.wasm.cwrap(pa,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Q7(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:p,dataFormat:c,dimRoundingMode:d,activation:h,leakyreluAlpha:f}=n,m=Qx.computeConv2DInfo(a.shape,s.shape,l,p,u,d,!0),g=z6[h];if(null==g)throw new Error(`${h} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);let y=r.dataIdMap.get(a.dataId).id,b=r.dataIdMap.get(s.dataId).id,x=m.outChannels,v=0;if(null!=i){let e=r.dataIdMap.get(i.dataId);if(1!==e.shape.length)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${e.shape.length}.`);if(e.shape[0]!==x)throw new Error(`FusedDepthwiseConv2D bias shape (${e.shape}) does not match the number of output channels (${x})`);v=e.id}let w=m.filterHeight,k=m.filterWidth,I=m.padInfo.top,S=m.padInfo.right,N=m.padInfo.bottom,T=m.padInfo.left,_=m.dilationHeight,C=m.dilationWidth,E=m.strideHeight,A=m.strideWidth,$=m.inChannels,R="SAME"===m.padInfo.type?1:0,F=m.batchSize,D=m.inHeight,M=m.inWidth;if("NHWC"!==c)throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${c}'. Please use 'NHWC'.`);let O=r.makeOutput(m.outShape,"float32"),P=r.dataIdMap.get(O.dataId).id,L=null==o?0:r.dataIdMap.get(o.dataId).id;return J7(y,F,D,M,b,w,k,v,I,S,N,T,R,_,C,E,A,$,x,g,L,f||0,P),O}var e9,t9={kernelName:pa,backendName:"wasm",setupFunc:Z7,kernelFunc:Q7};function n9(e){e9=e.wasm.cwrap(sn,null,["number","number","number","number","number","number","array","number"])}function r9(e){let{backend:t,inputs:n}=e,{params:r,indices:a}=n,[s,i,o,l]=Sx.prepareAndValidate(r,a),u=t.makeOutput(s,r.dtype);if(0===i)return u;let p=a.shape,c=p[p.length-1],d=t.dataIdMap.get(r.dataId).id,h=t.dataIdMap.get(a.dataId).id,f=new Uint8Array(new Int32Array(l).buffer),m=t.dataIdMap.get(u.dataId).id;return e9(d,L6[r.dtype],h,i,c,o,f,m),u}var a9,s9={kernelName:sn,backendName:"wasm",setupFunc:n9,kernelFunc:r9};function i9(e){a9=e.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])}function o9(e){let{backend:t,inputs:n,attrs:r}=e,{x:a,indices:s}=n,{axis:i,batchDims:o}=r,l=Sa.parseAxisParam(i,a.shape)[0],u=t.readSync(s.dataId),p=a.shape[l];for(let I=0;I<u.length;++I){let e=u[I];Sa.assert(e<=p-1&&e>=0,(()=>`GatherV2: the index value ${e} is not in [0, ${p-1}]`))}let c=Qx.segment_util.collectGatherOpShapeInfo(a,s,l,o),d=B5({inputs:{x:a},attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]},backend:t}),h=Sa.sizeFromShape(s.shape),f=B5({inputs:{x:s},attrs:{shape:[c.batchSize,h/c.batchSize]},backend:t}),m=[c.batchSize,c.outerSize,h/c.batchSize,c.sliceSize],g=t.makeOutput(m,a.dtype);if(0===Sa.sizeFromShape(a.shape))return g;let y=d.shape.length-1,b=t.dataIdMap.get(d.dataId).id,x=t.dataIdMap.get(f.dataId).id,v=t.dataIdMap.get(g.dataId).id,w=new Uint8Array(new Int32Array(Sa.computeStrides(d.shape)).buffer),k=new Uint8Array(new Int32Array(Sa.computeStrides(m)).buffer);return a9(b,L6[a.dtype],w,y,x,c.batchSize,k,v),t.disposeData(d.dataId),t.disposeData(f.dataId),g.shape=c.outputShape,g}var l9,u9={kernelName:an,backendName:"wasm",setupFunc:i9,kernelFunc:o9},p9=!1,c9=J6(on,p9,"bool"),d9=!1,h9=J6(ln,d9,"bool"),f9=j6(dn,"bool"),m9=j6(hn,"bool"),g9=j6(fn,"bool");function y9(e){l9=e.wasm.cwrap(mn,null,["number","number","number","number"])}function b9(e){let{inputs:{x:t},attrs:{alpha:n},backend:r}=e,a=r.dataIdMap.get(t.dataId).id,s=r.makeOutput(t.shape,"float32");if(0!==Sa.sizeFromShape(t.shape)){let e=r.dataIdMap.get(s.dataId).id;l9(a,L6[t.dtype],n,e)}return s}var x9,v9={kernelName:mn,backendName:"wasm",setupFunc:y9,kernelFunc:b9},w9=!1,k9=J6(gn,w9,"bool"),I9=!1,S9=J6(yn,I9,"bool");function N9(e){x9=e.wasm.cwrap(bn,null,["number","number","number","number"])}function T9(e){let{attrs:t,backend:n}=e,{start:r,stop:a,num:s}=t,i=Math.floor(s),o=n.makeOutput([i],"float32");return x9(n.dataIdMap.get(o.dataId).id,r,a,i),o}var _9,C9={kernelName:bn,backendName:"wasm",setupFunc:N9,kernelFunc:T9},E9=j6(xn),A9=j6(vn),$9=!1,R9=J6(wn,$9,"bool"),F9=j6(kn),D9=!1,M9=J6(In,D9,"bool"),O9=!1,P9=J6(Sn,O9,"bool");function L9(e){_9=e.wasm.cwrap(_n,null,["number","number","number","number","number","number","number"])}function z9(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r;if("float32"!==a.dtype)throw new Error("LRN error: x must have dtype float32");let u=n.makeOutput(a.shape,a.dtype);return _9(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(u.dataId).id,a.shape[3],s,i,o,l),u}var B9,W9={kernelName:_n,backendName:"wasm",setupFunc:L9,kernelFunc:z9};function U9(e){B9=e.wasm.cwrap(Cn,null,["number","number","number","number","number","number","number","number","number"])}function V9(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:p}=r;if("float32"!==a.dtype||"float32"!==s.dtype||"float32"!==i.dtype)throw new Error("LRNGrad error: x, y, and dy must have dtype float32");let c=n.makeOutput(a.shape,a.dtype);return B9(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(c.dataId).id,i.shape[3],o,l,u,p),c}var G9,H9={kernelName:Cn,backendName:"wasm",setupFunc:U9,kernelFunc:V9};function j9(e){G9=e.wasm.cwrap(An,null,["number","number","number","number"])}function q9(e){let{backend:t,inputs:n,attrs:r}=e,{reductionIndices:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:u,axes:p,originalAxes:c,inputWasTransposed:d}=d5(i,a,t);if(d){let e=t.dataIdMap.get(u.dataId).id;l=u,o=e}let h=l.shape.length;Qx.assertAxesAreInnerMostDims("max",p,h);let[f,m]=Qx.computeOutAndReduceShapes(l.shape,p),g=Sa.sizeFromShape(m),y=t.makeOutput(f,i.dtype);if(0!==Sa.sizeFromShape(l.shape)){let e=t.dataIdMap.get(y.dataId).id;G9(o,L6[i.dtype],g,e)}if(d&&t.disposeData(u.dataId),s){let e=Qx.expandShapeToKeepDim(y.shape,c);y.shape=e}return y}var K9,X9={kernelName:An,backendName:"wasm",setupFunc:j9,kernelFunc:q9},J9=!1,Y9=J6($n,J9);function Z9(e){K9=e.wasm.cwrap(Rn,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Q9(e){let{inputs:t,attrs:n,backend:r}=e,a=t.x,s=r.dataIdMap.get(a.dataId).id;Sa.assert("float32"===a.dtype,(()=>`Error in MaxPool: only float32 input is supported. Got ${a.dtype}.`));let{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=n,p=Qx.computePool2DInfo(a.shape,i,o,1,l,u),c=p.filterHeight,d=p.filterWidth,h=p.padInfo.top,f=p.padInfo.right,m=p.padInfo.bottom,g=p.padInfo.left,y=p.dilationHeight,b=p.dilationWidth,x=p.strideHeight,v=p.strideWidth,w=p.inChannels,k=p.outChannels;if("channelsLast"!==p.dataFormat)throw new Error(`wasm backend does not support dataFormat:'${p.dataFormat}'. Please use 'channelsLast'.`);let I=r.makeOutput(p.outShape,"float32"),S=r.dataIdMap.get(I.dataId).id;return K9(s,a.shape[0],a.shape[1],a.shape[2],c,d,h,f,m,g,y,b,x,v,w,k,S),I}var eee,tee={kernelName:Rn,backendName:"wasm",setupFunc:Z9,kernelFunc:Q9};function nee(e){eee=e.wasm.cwrap("MaxPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function ree(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,p=Qx.computePool3DInfo(a.shape,s,i,1,o,l,u),c=n.makeOutput(p.outShape,a.dtype);return eee(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(c.dataId).id,p.batchSize,p.inChannels,p.inDepth,p.inHeight,p.inWidth,p.outDepth,p.outHeight,p.outWidth,p.strideDepth,p.strideHeight,p.strideWidth,p.dilationDepth,p.dilationHeight,p.dilationWidth,p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth,p.padInfo.front,p.padInfo.top,p.padInfo.left),c}var aee,see={kernelName:Dn,backendName:"wasm",setupFunc:nee,kernelFunc:ree};function iee(e){aee=e.wasm.cwrap("MaxPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function oee(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r,p=Qx.computePool3DInfo(s.shape,i,o,1,l,u),c=n.makeOutput(s.shape,s.dtype);return aee(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(c.dataId).id,p.batchSize,p.inChannels,p.inDepth,p.inHeight,p.inWidth,p.outDepth,p.outHeight,p.outWidth,p.strideDepth,p.strideHeight,p.strideWidth,p.dilationDepth,p.dilationHeight,p.dilationWidth,p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth,p.padInfo.front,p.padInfo.top,p.padInfo.left),c}var lee,uee={kernelName:Mn,backendName:"wasm",setupFunc:iee,kernelFunc:oee};function pee(e){lee=e.wasm.cwrap(Pn,null,["number, number, number"])}function cee(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:p,axes:c,originalAxes:d,inputWasTransposed:h}=d5(i,a,t),f=c;if(h){let e=t.dataIdMap.get(p.dataId).id;e!==o&&(u=p,l=e,f=Qx.getInnerMostAxes(f.length,u.shape.length))}Qx.assertAxesAreInnerMostDims("mean",f,u.shape.length);let[m,g]=Qx.computeOutAndReduceShapes(u.shape,f),y=Sa.sizeFromShape(g),b=u;"float32"!==u.dtype&&(b=s8({backend:t,inputs:{x:u},attrs:{dtype:"float32"}}),l=t.dataIdMap.get(b.dataId).id);let x=t.makeOutput(m,"float32");if(0!==Sa.sizeFromShape(u.shape)){let e=t.dataIdMap.get(x.dataId).id;lee(l,y,e)}if(h&&t.disposeData(p.dataId),s){let e=Qx.expandShapeToKeepDim(x.shape,d);x.shape=e}return"float32"!==u.dtype&&t.disposeData(b.dataId),x}var dee,hee={kernelName:Pn,backendName:"wasm",setupFunc:pee,kernelFunc:cee};function fee(e){dee=e.wasm.cwrap(Ln,null,["number","number","number","number"])}function mee(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:p,axes:c,originalAxes:d,inputWasTransposed:h}=d5(i,a,t);if(h){let e=t.dataIdMap.get(p.dataId).id;e!==o&&(u=p,l=e)}let f=u.shape.length;Qx.assertAxesAreInnerMostDims("min",c,f);let[m,g]=Qx.computeOutAndReduceShapes(u.shape,c),y=Sa.sizeFromShape(g),b=t.makeOutput(m,u.dtype);if(0!==Sa.sizeFromShape(u.shape)){let e=t.dataIdMap.get(b.dataId).id;dee(l,L6[i.dtype],y,e)}if(h&&t.disposeData(p.dataId),s){let e=Qx.expandShapeToKeepDim(b.shape,d);b.shape=e}return b}var gee,yee,bee={kernelName:Ln,backendName:"wasm",setupFunc:fee,kernelFunc:mee},xee=!1,vee=J6(zn,xee);function wee(e){yee=e.wasm.cwrap(Bn,null,["number","array","number","number","array","array","number","number"])}function kee(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,mode:a}}=e,s=r.map(((e,n)=>e[0]+t.shape[n]+e[1])),i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(s,t.dtype),l=n.dataIdMap.get(o.dataId).id,u=new Uint8Array(new Int32Array(t.shape).buffer),p=r.map((e=>e[0])),c=r.map((e=>e[1])),d=new Uint8Array(new Int32Array(p).buffer),h=new Uint8Array(new Int32Array(c).buffer);return yee(i,u,t.shape.length,L6[t.dtype],d,h,gee[a],l),o}(function(e){e[e.reflect=0]="reflect",e[e.symmetric=1]="symmetric"})(gee||(gee={}));var Iee,See={kernelName:Bn,backendName:"wasm",kernelFunc:kee,setupFunc:wee};function Nee(e){Iee=e.wasm.cwrap(Dr,null,["number","number","number","number"])}function Tee(e){let{backend:t,inputs:{logits:n},attrs:{dim:r}}=e,a=t.dataIdMap.get(n.dataId).id,s=t.makeOutput(n.shape,n.dtype),i=t.dataIdMap.get(s.dataId).id,o=n.shape[r],l=Sa.sizeFromShape(n.shape)/o;return 0===Sa.sizeFromShape(s.shape)||Iee(a,i,o,l),s}var _ee,Cee={kernelName:Dr,backendName:"wasm",setupFunc:Nee,kernelFunc:Tee};function Eee(e){_ee=e.wasm.cwrap(Un,null,["number","number","number","number","number","number"])}function Aee(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=r;if("float32"!==a.dtype)throw new Error(`Tensor logits must have dtype float32, got ${a.dtype}`);let l=o?a:Tee({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),[u,p]=l.shape,c=n.makeOutput([u,s],"int32");return _ee(n.dataIdMap.get(l.dataId).id,u,p,s,i,n.dataIdMap.get(c.dataId).id),o||n.disposeData(l.dataId),c}var $ee,Ree={kernelName:Un,backendName:"wasm",setupFunc:Eee,kernelFunc:Aee},Fee=!0,Dee=J6(Vn,Fee),Mee=j6(Gn);function Oee(e,t){let n=new Int32Array(e.wasm.HEAPU8.buffer,t,4),r=n[0],a=n[1],s=n[2],i=n[3];return e.wasm._free(t),{pSelectedIndices:r,selectedSize:a,pSelectedScores:s,pValidOutputs:i}}function Pee(e){$ee=e.wasm.cwrap(jn,"number",["number","number","number","number","number"])}function Lee(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:s,scoreThreshold:i}=r,{boxes:o,scores:l}=n,u=t.dataIdMap.get(o.dataId).id,p=t.dataIdMap.get(l.dataId).id,c=$ee(u,p,s,a,i),{pSelectedIndices:d,selectedSize:h,pSelectedScores:f,pValidOutputs:m}=Oee(t,c);return t.wasm._free(f),t.wasm._free(m),t.makeOutput([h],"int32",d)}var zee,Bee={kernelName:jn,backendName:"wasm",setupFunc:Pee,kernelFunc:Lee};function Wee(e){zee=e.wasm.cwrap(qn,"number",["number","number","number","number","number","bool"])}function Uee(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:s,scoreThreshold:i,padToMaxOutputSize:o}=r,{boxes:l,scores:u}=n,p=t.dataIdMap.get(l.dataId).id,c=t.dataIdMap.get(u.dataId).id,d=zee(p,c,s,a,i,o),{pSelectedIndices:h,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=Oee(t,d);t.wasm._free(m);let y=t.makeOutput([f],"int32",h),b=t.makeOutput([],"int32",g);return[y,b]}var Vee,Gee={kernelName:qn,backendName:"wasm",setupFunc:Wee,kernelFunc:Uee};function Hee(e){Vee=e.wasm.cwrap(Kn,"number",["number","number","number","number","number","number"])}function jee(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:s,scoreThreshold:i,softNmsSigma:o}=r,{boxes:l,scores:u}=n,p=t.dataIdMap.get(l.dataId).id,c=t.dataIdMap.get(u.dataId).id,d=Vee(p,c,s,a,i,o),{pSelectedIndices:h,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=Oee(t,d);t.wasm._free(g);let y=t.makeOutput([f],"int32",h),b=t.makeOutput([f],"float32",m);return[y,b]}var qee,Kee={kernelName:Kn,backendName:"wasm",setupFunc:Hee,kernelFunc:jee},Xee=!1,Jee=J6(Hn,Xee,"bool");function Yee(e){qee=e.wasm.cwrap(Jn,null,["number","number","number","number","number"])}function Zee(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:i,onValue:o,offValue:l}=r,u=n.makeOutput([...a.shape,i],s),p=n.dataIdMap.get(u.dataId).id,c=n.dataIdMap.get(a.dataId).id;return qee(c,i,o,l,p),u}var Qee={kernelName:Jn,backendName:"wasm",setupFunc:Yee,kernelFunc:Zee};function ete(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(1),r}var tte={kernelName:Xn,backendName:"wasm",kernelFunc:ete};function nte(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return $7({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let s=t[0].shape,i=t[0].dtype;t.forEach((e=>{Sa.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),Sa.assert(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));let o=[],l=t.map((e=>{let t=$7({inputs:{input:e},backend:n,attrs:{dim:a}});return o.push(t),t})),u=d8({inputs:l,backend:n,attrs:{axis:a}});return o.forEach((e=>n.disposeData(e.dataId))),u}var rte,ate={kernelName:Yn,backendName:"wasm",kernelFunc:nte};function ste(e){rte=e.wasm.cwrap(Zn,null,["number","array","number","number","array","array","number","number"])}function ite(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,constantValue:a}}=e,s=r.map(((e,n)=>e[0]+t.shape[n]+e[1]));if(0===Sa.sizeFromShape(t.shape))return D7({backend:n,attrs:{shape:s,value:a,dtype:t.dtype}});let i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(s,t.dtype),l=n.dataIdMap.get(o.dataId).id,u=new Uint8Array(new Int32Array(t.shape).buffer),p=r.map((e=>e[0])),c=r.map((e=>e[1])),d=new Uint8Array(new Int32Array(p).buffer),h=new Uint8Array(new Int32Array(c).buffer);return rte(i,u,t.shape.length,L6[t.dtype],d,h,a,l),o}var ote,lte={kernelName:Zn,backendName:"wasm",kernelFunc:ite,setupFunc:ste},ute=!1,pte=J6(er,ute);function cte(e){ote=e.wasm.cwrap(tr,null,["number","number","number"])}function dte(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t,s=n.dataIdMap.get(r.dataId).id,i=n.dataIdMap.get(a.dataId).id,o=s,l=r,u=l;"float32"!==l.dtype&&(u=s8({backend:n,inputs:{x:r},attrs:{dtype:"float32"}}),o=n.dataIdMap.get(u.dataId).id);let p=n.makeOutput(r.shape,"float32"),c=n.dataIdMap.get(p.dataId).id;return ote(o,i,c),"float32"!==l.dtype&&n.disposeData(u.dataId),p}var hte,fte={kernelName:tr,backendName:"wasm",setupFunc:cte,kernelFunc:dte};function mte(e){hte=e.wasm.cwrap(nr,null,["number","number","number","number"])}function gte(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:p,axes:c,originalAxes:d,inputWasTransposed:h}=d5(i,a,t),f=c;if(h){let e=t.dataIdMap.get(p.dataId).id;e!==o&&(u=p,l=e,f=Qx.getInnerMostAxes(f.length,u.shape.length))}Qx.assertAxesAreInnerMostDims("prod",f,u.shape.length);let[m,g]=Qx.computeOutAndReduceShapes(u.shape,f),y=Sa.sizeFromShape(g),b=t.makeOutput(m,u.dtype);if(0!==Sa.sizeFromShape(u.shape)){let e=t.dataIdMap.get(b.dataId).id;hte(l,y,L6[b.dtype],e)}if(h&&t.disposeData(p.dataId),s){let e=Qx.expandShapeToKeepDim(b.shape,d);b.shape=e}return b}var yte,bte={kernelName:nr,backendName:"wasm",setupFunc:mte,kernelFunc:gte},xte=e=>{let{backend:t,attrs:n}=e,{start:r,stop:a,step:s,dtype:i}=n,o=xL(r,a,s,i),l=t.makeOutput([o.length],i);return t.typedArrayFromHeap(l).set(o),l},vte={kernelName:ir,backendName:"wasm",kernelFunc:xte},wte=!0,kte=J6(Vt,wte),Ite=j6(lr),Ste=j6(ur),Nte=j6(mr);function Tte(e){yte=e.wasm.cwrap(hr,null,["number","number","number","number","number","number","number","number","number","number"])}function _te(e){let t,{backend:n,inputs:r,attrs:a}=e,{images:s}=r,{alignCorners:i,halfPixelCenters:o,size:l}=a,[u,p]=l,[c,d,h,f]=s.shape,m=[c,u,p,f],g=n.dataIdMap.get(s.dataId);"float32"!==g.dtype&&(t=s8({backend:n,inputs:{x:s},attrs:{dtype:"float32"}}),g=n.dataIdMap.get(t.dataId));let y=g.id,b=n.makeOutput(m,"float32");if(0===Sa.sizeFromShape(s.shape))return b;let x=n.dataIdMap.get(b.dataId).id;return yte(y,c,d,h,f,u,p,i?1:0,o?1:0,x),null!=t&&n.disposeData(t.dataId),b}var Cte,Ete={kernelName:hr,backendName:"wasm",setupFunc:Tte,kernelFunc:_te};function Ate(e){Cte=e.wasm.cwrap(fr,null,["number","number","number","array","array","boolean"])}function $te(e){let t,{inputs:n,backend:r,attrs:a}=e,{images:s,dy:i}=n,{alignCorners:o}=a,l=r.makeOutput(s.shape,"float32"),u=r.dataIdMap.get(s.dataId);return"float32"!==u.dtype&&(t=s8({backend:r,inputs:{x:s},attrs:{dtype:"float32"}}),u=r.dataIdMap.get(t.dataId)),Cte(r.dataIdMap.get(s.dataId).id,r.dataIdMap.get(i.dataId).id,r.dataIdMap.get(l.dataId).id,new Uint8Array(new Int32Array(s.shape).buffer),new Uint8Array(new Int32Array(i.shape).buffer),o),null!=t&&r.disposeData(t.dataId),l}var Rte,Fte={kernelName:fr,backendName:"wasm",setupFunc:Ate,kernelFunc:$te};function Dte(e){Rte=e.wasm.cwrap(cr,null,["number","number","number","number","number","number","number","number","number","number"])}function Mte(e){let{backend:t,inputs:n,attrs:r}=e,{images:a}=n,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,u]=o,[p,c,d,h]=a.shape,f=[p,l,u,h],m=t.makeOutput(f,"float32");if(0===Sa.sizeFromShape(a.shape))return m;let g,y=t.dataIdMap.get(a.dataId);"float32"!==y.dtype&&(g=s8({backend:t,inputs:{x:a},attrs:{dtype:"float32"}}),y=t.dataIdMap.get(g.dataId));let b=y.id,x=t.dataIdMap.get(m.dataId).id;return Rte(b,p,c,d,h,l,u,s?1:0,i?1:0,x),null!=g&&t.disposeData(g.dataId),m}var Ote,Pte={kernelName:cr,backendName:"wasm",setupFunc:Dte,kernelFunc:Mte};function Lte(e){Ote=e.wasm.cwrap(dr,null,["number","number","number","array","array","boolean"])}function zte(e){let t,{inputs:n,backend:r,attrs:a}=e,{images:s,dy:i}=n,{alignCorners:o}=a,l=r.makeOutput(s.shape,"float32"),u=r.dataIdMap.get(s.dataId);return"float32"!==u.dtype&&(t=s8({backend:r,inputs:{x:s},attrs:{dtype:"float32"}}),u=r.dataIdMap.get(t.dataId)),Ote(r.dataIdMap.get(s.dataId).id,r.dataIdMap.get(i.dataId).id,r.dataIdMap.get(l.dataId).id,new Uint8Array(new Int32Array(s.shape).buffer),new Uint8Array(new Int32Array(i.shape).buffer),o),null!=t&&r.disposeData(t.dataId),l}var Bte,Wte={kernelName:dr,backendName:"wasm",setupFunc:Lte,kernelFunc:zte};function Ute(e){Bte=e.wasm.cwrap(gr,null,["number","array","number","array","number","number"])}function Vte(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r,i=Sa.parseAxisParam(s,a.shape);if(0===a.shape.length)return r5({inputs:{x:a},backend:n});let o=n.makeOutput(a.shape,a.dtype),l=n.dataIdMap.get(a.dataId).id,u=n.dataIdMap.get(o.dataId).id,p=new Uint8Array(new Int32Array(i).buffer),c=new Uint8Array(new Int32Array(a.shape).buffer);Bte(l,p,i.length,c,a.shape.length,u);let d=B5({inputs:{x:o},attrs:{shape:a.shape},backend:n});return n.disposeData(o.dataId),d}var Gte,Hte={kernelName:gr,backendName:"wasm",kernelFunc:Vte,setupFunc:Ute};function jte(e){Gte=e.wasm.cwrap(oa,null,["number","number","number","number","number","number","number","number","array","number","number"])}function qte(e){let{inputs:t,backend:n,attrs:r}=e,{image:a}=t,{radians:s,fillValue:i,center:o}=r,l=n.makeOutput(a.shape,a.dtype),u=n.dataIdMap.get(a.dataId).id,p=n.dataIdMap.get(l.dataId).id,[c,d,h,f]=a.shape,[m,g]=Qx.getImageCenter(o,d,h),y=0===i,b=255,x="number"==typeof i?[i,i,i,y?0:b]:[...i,b],v=new Uint8Array(new Int32Array(x).buffer);return Gte(u,c,d,h,f,s,m,g,v,x.length,p),l}var Kte,Xte={kernelName:oa,backendName:"wasm",kernelFunc:qte,setupFunc:jte},Jte=j6(yr),Yte=j6(br);function Zte(e){Kte=e.wasm.cwrap(xr,null,["number","number","number","number","number","number","array","number","number"])}function Qte(e){let{backend:t,inputs:n,attrs:r}=e,{indices:a,updates:s}=n,{shape:i}=r,o=t.makeOutput(i,s.dtype);if(0===Sa.sizeFromShape(i))return o;let{sliceRank:l,numUpdates:u,sliceSize:p,strides:c,outputSize:d}=Tm.calculateShapes(s,a,i),h=t.dataIdMap.get(a.dataId).id,f=t.dataIdMap.get(s.dataId).id,m=new Uint8Array(new Int32Array(c).buffer),g=t.dataIdMap.get(o.dataId).id;return Kte(h,f,L6[s.dtype],l,u,p,m,d,g),o}var ene,tne={kernelName:xr,backendName:"wasm",setupFunc:Zte,kernelFunc:Qte};function nne(e){ene=e.wasm.cwrap(wr,null,["number","number","number","number","number","number","bool","number"])}function rne(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:i}=r;if(a.dtype!==s.dtype)throw new Error(`SearchSorted error: sorted_sequence must have the same dtype as values. Got ${a.dtype} and ${s.dtype}`);let o=n.makeOutput(s.shape,"int32");function l(e){return n.dataIdMap.get(e.dataId).id}return ene(l(a),l(s),a.shape[0],a.shape[1],s.shape[1],L6[a.dtype],"left"===i,l(o)),o}var ane,sne={kernelName:wr,backendName:"wasm",setupFunc:nne,kernelFunc:rne};function ine(e){ane=e.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}function one(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t,i=n.dataIdMap.get(r.dataId).id,o=n.dataIdMap.get(a.dataId).id,l=n.dataIdMap.get(s.dataId).id,u=n.makeOutput(a.shape,a.dtype),p=n.dataIdMap.get(u.dataId).id,c=r.shape.length,d=a.shape.length,h=0===c||c>1||1===d?1:Sa.sizeFromShape(a.shape.slice(1));return ane(i,o,l,h,p),u}var lne,une={kernelName:kr,backendName:"wasm",kernelFunc:one,setupFunc:ine},pne=j6(Ir);function cne(e){lne=e.wasm.cwrap(Cr,null,["number","number"])}function dne(e){let{backend:t,inputs:{x:n}}=e,r=t.dataIdMap.get(n.dataId).id,a=t.makeOutput(n.shape,n.dtype),s=t.dataIdMap.get(a.dataId).id;return 0===Sa.sizeFromShape(a.shape)||lne(r,s),a}var hne={kernelName:"Sigmoid",backendName:"wasm",setupFunc:cne,kernelFunc:dne},fne=j6(_r),mne=j6(Nr),gne=j6(Er);function yne(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r,o=Sa.sizeFromShape(s),l=[[0,0]];l.push(...i);for(let g=1+s.length;g<a.shape.length;++g)l.push([0,0]);let u=lte.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),p=Qx.getReshaped(u.shape,s,o,!1),c=Qx.getPermuted(p.length,s.length,!1),d=Qx.getReshapedPermuted(u.shape,s,o,!1),h=B5({inputs:{x:u},backend:n,attrs:{shape:p}}),f=o5({inputs:{x:h},backend:n,attrs:{perm:c}}),m=B5({inputs:{x:f},backend:n,attrs:{shape:d}});return n.disposeData(u.dataId),n.disposeData(h.dataId),n.disposeData(f.dataId),m}var bne,xne={kernelName:Rr,backendName:"wasm",kernelFunc:yne};function vne(e){bne=e.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])}function wne(e){let t,{backend:n,inputs:r}=e,{indices:a,values:s,denseShape:i,defaultValue:o}=r,l=a.shape[0],u=a.shape[1],p=n.readSync(i.dataId)[0],c=[l+p,u],d=n.dataIdMap.get(a.dataId).id,h=n.dataIdMap.get(s.dataId).id,f=n.dataIdMap.get(o.dataId).id,m=n.makeOutput(c,a.dtype),g=n.dataIdMap.get(m.dataId).id,y=n.makeOutput(c.slice(0,1),s.dtype),b=n.dataIdMap.get(y.dataId).id,x=n.makeOutput([p],"bool"),v=n.dataIdMap.get(x.dataId).id,w=n.makeOutput([l],a.dtype),k=n.dataIdMap.get(w.dataId).id,I=n.makeOutput([4],"int32"),S=n.dataIdMap.get(I.dataId).id,N=bne(d,h,L6[s.dtype],l,p,u,f,g,b,v,k,S),T=n.readSync(I.dataId);switch(T[0]){case 1:t=Qx.getSparseFillEmptyRowsIndicesDenseShapeMismatch(T[1]);break;case 2:t=Qx.getSparseFillEmptyRowsNegativeIndexErrorMessage(T[1],T[2]);break;case 3:t=Qx.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(T[1],T[2],T[3]);break;default:t=""}if(n.disposeData(I.dataId),t)throw n.disposeData(m.dataId),n.disposeData(y.dataId),n.disposeData(x.dataId),n.disposeData(w.dataId),new Error(t);let _=m,C=y;return N!==c[0]&&(_=j5({inputs:{x:m},attrs:{begin:0,size:[N,u]},backend:n}),C=j5({inputs:{x:y},attrs:{begin:0,size:N},backend:n}),n.disposeData(m.dataId),n.disposeData(y.dataId)),[_,C,x,w]}var kne,Ine={kernelName:Mr,backendName:"wasm",setupFunc:vne,kernelFunc:wne};function Sne(e){kne=e.wasm.cwrap(Or,null,["number","number","number","number","number","number","number"])}function Nne(e){let{backend:t,inputs:n}=e,{inputIndices:r,inputShape:a,newShape:s}=n;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${a.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=t.dataIdMap.get(r.dataId).id,o=t.dataIdMap.get(a.dataId).id,l=t.dataIdMap.get(s.dataId).id,u=r.shape[0],p=Sa.sizeFromShape(s.shape),c=t.makeOutput([u,p],r.dtype),d=t.dataIdMap.get(c.dataId).id,h=t.makeOutput([p],s.dtype),f=t.dataIdMap.get(h.dataId).id,m=t.makeOutput([3],"int32"),g=t.dataIdMap.get(m.dataId).id;kne(i,o,l,u,d,f,g);let y,b=t.readSync(m.dataId);switch(b[0]){case 0:y=Qx.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(b[1],b[2]);break;case 1:y=Qx.getSparseReshapeNegativeOutputDimErrorMessage(b[1],b[2]);break;case 2:y=Qx.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{let e=Array.from(t.readSync(a.dataId)),n=Array.from(t.readSync(h.dataId));y=Qx.getSparseReshapeInputOutputMultipleErrorMessage(e,n);break}case 4:{let e=Array.from(t.readSync(a.dataId)),n=Array.from(t.readSync(h.dataId));y=Qx.getSparseReshapeInputOutputMismatchErrorMessage(e,n);break}default:y=""}if(t.disposeData(m.dataId),y)throw t.disposeData(c.dataId),t.disposeData(h.dataId),new Error(y);return[c,h]}var Tne,_ne={kernelName:Or,backendName:"wasm",setupFunc:Sne,kernelFunc:Nne};function Cne(e){Tne=e.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function Ene(e,t){let{backend:n,inputs:r}=e,{data:a,indices:s,segmentIds:i}=r,o=s.shape[0],l=n.readSync(i.dataId,o-1,o)[0],u=o>0?l+1:0;if(u<0)throw new Error(Qx.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let p=a.shape.slice();p[0]=u;let c=n.dataIdMap.get(a.dataId).id,d=n.dataIdMap.get(s.dataId).id,h=n.dataIdMap.get(i.dataId).id,f=n.makeOutput(p,a.dtype),m=n.dataIdMap.get(f.dataId).id,g=n.makeOutput([4],"int32"),y=n.dataIdMap.get(g.dataId).id;Tne(c,L6[a.dtype],a.shape[0],d,h,m,y,t,0);let b,x=n.readSync(g.dataId);switch(x[0]){case 0:b=Qx.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break;case 1:b=Qx.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break;case 2:b=Qx.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(x[1],x[2]);break;case 3:b=Qx.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(x[1],x[2],x[3]);break;default:b=""}if(n.disposeData(g.dataId),b)throw n.disposeData(f.dataId),new Error(b);return f}function Ane(e){return Ene(e,!0)}var $ne={kernelName:Pr,backendName:"wasm",setupFunc:Cne,kernelFunc:Ane};function Rne(e){return Ene(e,!1)}var Fne,Dne={kernelName:Lr,backendName:"wasm",setupFunc:Cne,kernelFunc:Rne};function Mne(e){Fne=e.wasm.cwrap(zr,null,["number","number","number","number","number","number","number","number","array","number","number"])}function One(e){let{backend:t,inputs:n,attrs:r}=e,{sparseIndices:a,sparseValues:s,defaultValue:i}=n,{outputShape:o}=r,l=t.makeOutput(o,i.dtype);if(0===Sa.sizeFromShape(o))return l;let{sliceRank:u,numUpdates:p,sliceSize:c,strides:d,outputSize:h}=Qx.calculateShapes(s,a,o),f=t.dataIdMap.get(a.dataId).id,m=t.dataIdMap.get(s.dataId).id,g=t.dataIdMap.get(i.dataId).id,y=new Uint8Array(new Int32Array(d).buffer),b=t.dataIdMap.get(l.dataId).id;return Fne(f,m,s.shape.length,g,L6[i.dtype],u,p,c,y,h,b),l}var Pne={kernelName:zr,backendName:"wasm",setupFunc:Mne,kernelFunc:One};function Lne(e){let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=n,o=Sa.parseAxisParam(i,a.shape)[0],l=Qx.prepareSplitSize(a,s,o),u=new Array(a.shape.length).fill(0),p=a.shape.slice();return l.map((e=>{let t=[...p];t[o]=e;let n=j5({inputs:{x:a},attrs:{begin:u,size:t},backend:r});return u[o]+=e,n}))}var zne,Bne={kernelName:Fr,backendName:"wasm",kernelFunc:Lne},Wne=j6(Ar),Une=j6(Wr),Vne=!0,Gne=J6(Br,Vne);function Hne(e){zne=e.wasm.cwrap(sa,null,["number","number","number","number"])}function jne(e){let{backend:t,inputs:n,attrs:r}=e,{alpha:a}=r,{x:s}=n,i=t.dataIdMap.get(s.dataId).id,o=t.makeOutput(s.shape,s.dtype),l=t.dataIdMap.get(o.dataId).id;return zne(i,a,L6[s.dtype],l),o}var qne,Kne={kernelName:sa,backendName:"wasm",setupFunc:Hne,kernelFunc:jne};function Xne(e){qne=e.wasm.cwrap(Vr,null,["number","array","number","array","array","array","array","array","number","number"])}function Jne(e){let t,{backend:n,inputs:r,attrs:a}=e,{x:s}=r,{begin:i,end:o,strides:l,beginMask:u,endMask:p,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=a,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:y,isSimpleSlice:b,begin:x,end:v,strides:w}=Tx.sliceInfo(s.shape,i,o,l,u,p,c,d,h);if(g)t=B5({inputs:{x:s},backend:n,attrs:{shape:m}});else if(y||b){Sa.assert(s.shape.length>=1,(()=>`Input must have rank at least 1, got: ${s.shape.length}`));let e=Tx.computeOutShape(x,v,w),r=j5({inputs:{x:s},backend:n,attrs:{begin:x,size:e}});t=B5({inputs:{x:r},backend:n,attrs:{shape:m}}),n.disposeData(r.dataId)}else{let e=n.makeOutput(f,"float32"),r=n.dataIdMap.get(s.dataId).id,a=new Uint8Array(new Int32Array(Sa.computeStrides(s.shape)).buffer),i=new Uint8Array(new Int32Array(x).buffer),o=new Uint8Array(new Int32Array(v).buffer),l=new Uint8Array(new Int32Array(w).buffer),u=new Uint8Array(new Int32Array(f).buffer),p=new Uint8Array(new Int32Array(Sa.computeStrides(f)).buffer),c=n.dataIdMap.get(e.dataId).id;qne(r,a,s.shape.length,i,o,l,u,p,f.length,c),t=B5({inputs:{x:e},backend:n,attrs:{shape:m}}),n.disposeData(e.dataId)}return t}var Yne={kernelName:Vr,backendName:"wasm",setupFunc:Xne,kernelFunc:Jne};function Zne(e){let{backend:t,inputs:n,attrs:r}=e,{data:a,dataSplits:s}=n,{separator:i,nGramWidths:o,leftPad:l,rightPad:u,padWidth:p,preserveShortSequences:c}=r,d=t.readSync(a.dataId),h=t.readSync(s.dataId),[f,m]=GL(d,h,i,o,l,u,p,c),g=t.makeOutput([f.length],"string"),y=t.dataIdMap.get(g.dataId);y.stringBytes=f;let b=t.makeOutput(s.shape,"int32");return t.typedArrayFromHeap(b).set(m),[g,b]}var Qne={kernelName:Gr,backendName:"wasm",kernelFunc:Zne};function ere(e){let{backend:t,inputs:n,attrs:r}=e,{input:a,delimiter:s}=n,{skipEmpty:i}=r,o=t.readSync(a.dataId),l=t.readSync(s.dataId),[u,p,c]=jL(o,l[0],i),d=p.length,h=t.makeOutput([d,2],"int32");t.typedArrayFromHeap(h).set(u);let f=t.makeOutput([d],"string"),m=t.dataIdMap.get(f.dataId);m.stringBytes=p;let g=t.makeOutput([2],"int32");return t.typedArrayFromHeap(g).set(c),[h,f,g]}var tre={kernelName:Hr,backendName:"wasm",kernelFunc:ere};function nre(e){let{backend:t,inputs:n,attrs:r}=e,{input:a}=n,{numBuckets:s}=r,i=t.readSync(a.dataId),o=qL(i,s),l=t.makeOutput(a.shape,"int32");return t.typedArrayFromHeap(l).set(o),l}var rre,are={kernelName:jr,backendName:"wasm",kernelFunc:nre},sre=!0,ire=J6(qr,sre);function ore(e){rre=e.wasm.cwrap($r,null,["number","number","number","number"])}function lre(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:p,axes:c,originalAxes:d,inputWasTransposed:h}=d5(i,a,t),f=c;if(h){let e=t.dataIdMap.get(p.dataId).id;e!==o&&(u=p,l=e,f=Qx.getInnerMostAxes(f.length,u.shape.length))}Qx.assertAxesAreInnerMostDims("sum",f,u.shape.length);let[m,g]=Qx.computeOutAndReduceShapes(u.shape,f),y=Sa.sizeFromShape(g),b=t.makeOutput(m,u.dtype);if(0!==Sa.sizeFromShape(u.shape)){let e=t.dataIdMap.get(b.dataId).id;rre(l,y,L6[b.dtype],e)}if(h&&t.disposeData(p.dataId),s){let e=Qx.expandShapeToKeepDim(b.shape,d);b.shape=e}return b}var ure,pre={kernelName:$r,backendName:"wasm",setupFunc:ore,kernelFunc:lre},cre=j6(Kr),dre=j6(Xr);function hre(e){ure=e.wasm.cwrap(vr,null,["number","number","number","number","number","number","array","number","number","number"])}function fre(e){let{backend:t,inputs:n,attrs:r}=e,{tensor:a,indices:s,updates:i}=n,{}=r,o=t.makeOutput(a.shape,a.dtype);if(0===Sa.sizeFromShape(a.shape))return o;let{sliceRank:l,numUpdates:u,sliceSize:p,strides:c,outputSize:d}=Tm.calculateShapes(i,s,a.shape),h=t.dataIdMap.get(s.dataId).id,f=t.dataIdMap.get(i.dataId).id,m=t.dataIdMap.get(a.dataId).id,g=new Uint8Array(new Int32Array(c).buffer),y=t.dataIdMap.get(o.dataId).id;return ure(h,f,L6[i.dtype],l,u,p,g,d,y,m),o}var mre,gre={kernelName:vr,backendName:"wasm",setupFunc:hre,kernelFunc:fre};function yre(e){mre=e.wasm.cwrap(Jr,null,["number","array","number","array","number","number"])}function bre(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,s=n.dataIdMap.get(a.dataId).id,{reps:i}=r,o=new Array(a.shape.length);for(let d=0;d<o.length;d++)o[d]=a.shape[d]*i[d];let l=new Uint8Array(new Int32Array(a.shape).buffer),u=new Uint8Array(new Int32Array(o).buffer),p=n.makeOutput(o,a.dtype),c=n.dataIdMap.get(p.dataId).id;return mre(s,l,a.shape.length,u,o.length,L6[p.dtype],c),p}var xre,vre={kernelName:Jr,backendName:"wasm",setupFunc:yre,kernelFunc:bre};function wre(e){xre=e.wasm.cwrap(Yr,null,["number","array","number","number","number","bool","number","number"])}var kre,Ire=({inputs:e,backend:t,attrs:n})=>{let{x:r}=e,{k:a,sorted:s}=n,i=t.dataIdMap.get(r.dataId).id,o=new Uint8Array(new Int32Array(r.shape).buffer),l=r.shape.slice();l[l.length-1]=a;let u=t.makeOutput(l,r.dtype),p=t.dataIdMap.get(u.dataId).id,c=t.makeOutput(l,"int32"),d=t.dataIdMap.get(c.dataId).id;return xre(i,o,r.shape.length,L6[r.dtype],a,s,p,d),[u,c]},Sre={kernelName:Yr,backendName:"wasm",setupFunc:wre,kernelFunc:Ire};function Nre(e){kre=e.wasm.cwrap(Zr,null,["number","number","bool","number","number","number","number","number","number","array","number","array","number","number","number","number","number"])}function Tre(e){let t,{backend:n,inputs:r,attrs:a}=e,{image:s,transforms:i}=r,{interpolation:o,fillMode:l,fillValue:u,outputShape:p}=a,[c,d,h,f]=s.shape,[m,g]=null!=p?p:[d,h],y=[c,m,g,f],b=new Uint8Array(new Int32Array(Sa.computeStrides(s.shape)).buffer),x=new Uint8Array(new Int32Array(Sa.computeStrides(y)).buffer),v=n.makeOutput(y,s.dtype),w=n.dataIdMap.get(v.dataId).id,k=n.dataIdMap.get(s.dataId).id,I=n.dataIdMap.get(i.dataId).id,S="nearest"===o?1:2;switch(l){case"constant":t=1;break;case"reflect":t=2;break;case"wrap":t=3;break;case"nearest":t=4;break;default:t=1;break}return kre(k,I,i.shape[0]>1,c,m,g,f,h,d,b,s.shape.length-1,x,y.length-1,S,t,u,w),v}var _re={kernelName:Zr,backendName:"wasm",setupFunc:Nre,kernelFunc:Tre};function Cre(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t,{outputValues:i,outputShape:o,indices:l}=nz(r.readSync(s.dataId),a,s.shape,s.dtype);return[r.makeOutput(o,s.dtype,void 0,i),r.makeOutput([l.length],"int32",void 0,l)]}var Ere={kernelName:ea,backendName:"wasm",kernelFunc:Cre};function Are(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:s}=r;s<0&&(s+=a.shape.length);let i=a.shape[s],o=a.shape.length,l=new Array(o-1),u=0;for(let h=0;h<o;h++)h!==s&&(l[u++]=a.shape[h]);let p=new Array(i),c=new Array(o).fill(0),d=a.shape.slice();d[s]=1;for(let h=0;h<p.length;h++)c[s]=h,p[h]=j5({inputs:{x:a},attrs:{begin:c,size:d},backend:n});return p.map((({dataId:e,dtype:t})=>({dataId:e,dtype:t,shape:l})))}var $re={kernelName:ta,backendName:"wasm",kernelFunc:Are};function Rre(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(0),r}var Fre={kernelName:aa,backendName:"wasm",kernelFunc:Rre},Dre=[H6,q6,K6,X6,Q6,n5,g5,x5,k5,I5,S5,N5,T5,_5,C5,R5,O5,z5,H5,Q5,n8,a8,o8,l8,c8,f8,b8,k8,T8,A8,M8,O8,P8,W8,H8,X8,Q8,r7,o7,c7,m7,x7,I7,S7,_7,E7,A7,R7,F7,O7,B7,W7,V7,q7,Y7,t9,s9,u9,c9,h9,s5,f9,m9,g9,v9,k9,S9,C9,A9,E9,R9,F9,M9,P9,W9,H9,X9,Y9,tee,see,uee,hee,bee,vee,See,Ree,Dee,Mee,Bee,Gee,Kee,Jee,Qee,tte,ate,lte,pte,fte,bte,vte,kte,Ite,Ste,Nte,U5,Ete,Fte,Pte,Wte,Hte,Xte,Jte,Yte,tne,sne,une,pne,hne,fne,mne,J5,Cee,gne,xne,Ine,_ne,$ne,Dne,Pne,Bne,Wne,Une,Gne,Kne,Yne,Qne,tre,are,ire,pre,cre,dre,gre,vre,Sre,_re,c5,Ere,$re,Fre];for(let cle of Dre)ba(cle);var Mre=We();Mre.registerFlag("WASM_HAS_SIMD_SUPPORT",(async()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))}catch(ple){return!1}})),Mre.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",(async()=>{if(Mre.get("IS_NODE"))return!1;try{return(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch(ple){return!1}}));var Ore=b(P()),Pre=b(L()),Lre=b(z()),zre=Ore.default||Ore,Bre=Lre.default||Lre,Wre=class extends W{constructor(e){super(),this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(eae),tae=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new B(this,$o())}write(e,t,n){let r={id:this.dataIdNextNumber++};return this.move(r,e,t,n,1),r}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){let t=Sa.now();return e(),{kernelMs:Sa.now()-t}}move(e,t,n,r,a){let s=this.dataIdNextNumber++;if("string"===r){let i=t;return void this.dataIdMap.set(e,{id:s,stringBytes:i,shape:n,dtype:r,memoryOffset:null,refCount:a})}let i=Sa.sizeFromShape(n),o=i*Sa.bytesPerElement(r),l=this.wasm._malloc(o);this.dataIdMap.set(e,{id:s,memoryOffset:l,shape:n,dtype:r,refCount:a}),this.wasm.tfjs.registerTensor(s,i,l),null!=t&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,o),l)}async read(e){return this.readSync(e)}readSync(e,t,n){let{memoryOffset:r,dtype:a,shape:s,stringBytes:i}=this.dataIdMap.get(e);if("string"===a)return null!=t&&0!==t||!(null==n||n>=i.length)?i.slice(t,n):i;t=t||0,n=n||Sa.sizeFromShape(s);let o=Sa.bytesPerElement(a),l=this.wasm.HEAPU8.slice(r+t*o,r+n*o);return Hre(l.buffer,a)}disposeData(e,t=!1){if(this.dataIdMap.has(e)){let n=this.dataIdMap.get(e);if(n.refCount--,!t&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(e)}return!0}refCount(e){return this.dataIdMap.has(e)?this.dataIdMap.get(e).refCount:0}incRef(e){let t=this.dataIdMap.get(e);null!=t&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,n,r){let a;if(null==n)a=this.write(null!=r?r:null,e,t);else{let r=this.dataIdNextNumber++;a={id:r},this.dataIdMap.set(a,{id:r,memoryOffset:n,shape:e,dtype:t,refCount:1});let s=Sa.sizeFromShape(e);this.wasm.tfjs.registerTensor(r,s,n)}return{dataId:a,shape:e,dtype:t}}typedArrayFromHeap({shape:e,dtype:t,dataId:n}){let r=this.wasm.HEAPU8.buffer,{memoryOffset:a}=this.dataIdMap.get(n),s=Sa.sizeFromShape(e);switch(t){case"float32":return new Float32Array(r,a,s);case"int32":return new Int32Array(r,a,s);case"bool":return new Uint8Array(r,a,s);default:throw new Error(`Unknown dtype ${t}`)}}};function Ure(e){return(t,n)=>(Sa.fetch(e,{credentials:"same-origin"}).then((r=>{r.ok||t.env.a(`failed to load wasm binary file at '${e}'`),r.arrayBuffer().then((e=>{WebAssembly.instantiate(e,t).then((e=>{n(e.instance,e.module)}))}))})),{})}function Vre(e,t,n){if(null!=qre)return qre;let r="tfjs-backend-wasm.wasm";return e&&t?r="tfjs-backend-wasm-threaded-simd.wasm":e&&(r="tfjs-backend-wasm-simd.wasm"),null!=Xre&&null!=Xre[r]?Xre[r]:n+r}async function Gre(){let[e,t]=await Promise.all([We().getAsync("WASM_HAS_SIMD_SUPPORT"),We().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise(((n,r)=>{let a={locateFile:(n,r)=>{if(n.endsWith(".worker.js")){let e=Pre.wasmWorkerContents.replace(/\n/g,"\\n"),t=new Blob([e],{type:"application/javascript"});return URL.createObjectURL(t)}return n.endsWith(".wasm")?Vre(e,t,null!=Kre?Kre:r):r+n}};Yre&&(a.instantiateWasm=Ure(Vre(e,t,null!=Kre?Kre:"")));let s,i=!1;a.onAbort=()=>{i||Jre||(Jre=!0,r({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"}))},t&&e&&null==qre?(a.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+zre.toString()],{type:"text/javascript"}),s=zre(a)):s=Bre(a),s.then((e=>{i=!0,Jre=!1;let t=null;e.tfjs={init:e.cwrap("init",null,[]),initWithThreadsCount:e.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:e.cwrap("get_threads_count","number",[]),registerTensor:e.cwrap("register_tensor",null,["number","number","number"]),disposeData:e.cwrap("dispose_data",t,["number"]),dispose:e.cwrap("dispose",t,[])},n({wasm:e})})).catch(r)}))}function Hre(e,t){switch(t){case"float32":return new Float32Array(e);case"int32":return new Int32Array(e);case"bool":return new Uint8Array(e);default:throw new Error(`Unknown dtype ${t}`)}}var jre=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],qre=null,Kre=null,Xre={},Jre=!1,Yre=!1;function Zre(e,t=!1){if(Eo("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),Jre)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");qre=e,Yre=t}function Qre(e,t=!1){if(Jre)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if("string"==typeof e)Kre=e;else{Xre=e;let t=jre.filter((e=>null==Xre[e]));if(t.length>0)throw new Error(`There were no entries found for the following binaries: ${t.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}Yre=t}var eae=-1,tae=-1;function nae(e){eae=e}function rae(){if(-1===tae)throw new Error("WASM backend not initialized.");return tae}var aae="4.3.0",sae=2;Go("wasm",(async()=>{let{wasm:e}=await Gre();return new Wre(e)}),sae);var iae="4.3.0",oae="4.3.0",lae="4.3.0",uae="4.3.0",pae="4.3.0",cae={tfjs:iae,"tfjs-core":iae,"tfjs-converter":oae,"tfjs-backend-cpu":lae,"tfjs-backend-webgl":uae,"tfjs-backend-wasm":pae},dae={};function hae(e,t,n=!1){if(e.beginPath(),t.slice(1).forEach((({x:n,y:r},a)=>{let s=t[a];e.moveTo(s.x,s.y),e.lineTo(n,r)})),n){let n=t[t.length-1],r=t[0];if(!n||!r)return;e.moveTo(n.x,n.y),e.lineTo(r.x,r.y)}e.stroke()}o(dae,{AnchorPosition:()=>pse,DrawBox:()=>fse,DrawBoxOptions:()=>hse,DrawFaceLandmarks:()=>die,DrawFaceLandmarksOptions:()=>cie,DrawTextField:()=>dse,DrawTextFieldOptions:()=>cse,drawContour:()=>hae,drawDetections:()=>mse,drawFaceExpressions:()=>oie,drawFaceLandmarks:()=>hie});var fae={};o(fae,{computeReshapedDimensions:()=>Nae,getCenterPoint:()=>Tae,isDimensions:()=>Sae,isEven:()=>kae,isFloat:()=>wae,isTensor:()=>gae,isTensor1D:()=>yae,isTensor2D:()=>bae,isTensor3D:()=>xae,isTensor4D:()=>vae,isValidNumber:()=>Cae,isValidProbablitiy:()=>Eae,range:()=>_ae,round:()=>Iae});var mae=class{constructor(e,t){if(!Cae(e)||!Cae(t))throw new Error(`Dimensions.constructor - expected width and height to be valid numbers, instead have ${JSON.stringify({width:e,height:t})}`);this._width=e,this._height=t}get width(){return this._width}get height(){return this._height}reverse(){return new mae(1/this.width,1/this.height)}};function gae(e,t){return e instanceof bs&&e.shape.length===t}function yae(e){return gae(e,1)}function bae(e){return gae(e,2)}function xae(e){return gae(e,3)}function vae(e){return gae(e,4)}function wae(e){return e%1!==0}function kae(e){return e%2===0}function Iae(e,t=2){let n=10**t;return Math.floor(e*n)/n}function Sae(e){return e&&e.width&&e.height}function Nae({width:e,height:t},n){let r=n/Math.max(t,e);return new mae(Math.round(e*r),Math.round(t*r))}function Tae(e){return e.reduce(((e,t)=>e.add(t)),new Aae(0,0)).div(new Aae(e.length,e.length))}function _ae(e,t,n){return Array(e).fill(0).map(((e,r)=>t+r*n))}function Cae(e){return!!e&&e!==1/0&&e!==-1/0&&!Number.isNaN(e)||0===e}function Eae(e){return Cae(e)&&e>=0&&e<=1}var Aae=class{constructor(e,t){this._x=e,this._y=t}get x(){return this._x}get y(){return this._y}add(e){return new Aae(this.x+e.x,this.y+e.y)}sub(e){return new Aae(this.x-e.x,this.y-e.y)}mul(e){return new Aae(this.x*e.x,this.y*e.y)}div(e){return new Aae(this.x/e.x,this.y/e.y)}abs(){return new Aae(Math.abs(this.x),Math.abs(this.y))}magnitude(){return Math.sqrt(this.x**2+this.y**2)}floor(){return new Aae(Math.floor(this.x),Math.floor(this.y))}},$ae=class{static isRect(e){return!!e&&[e.x,e.y,e.width,e.height].every(Cae)}static assertIsValidBox(e,t,n=!1){if(!$ae.isRect(e))throw new Error(`${t} - invalid box: ${JSON.stringify(e)}, expected object with properties x, y, width, height`);if(!n&&(e.width<0||e.height<0))throw new Error(`${t} - width (${e.width}) and height (${e.height}) must be positive numbers`)}constructor(e,t=!0){let n=e||{},r=[n.left,n.top,n.right,n.bottom].every(Cae),a=[n.x,n.y,n.width,n.height].every(Cae);if(!a&&!r)throw new Error(`Box.constructor - expected box to be IBoundingBox | IRect, instead have ${JSON.stringify(n)}`);let[s,i,o,l]=a?[n.x,n.y,n.width,n.height]:[n.left,n.top,n.right-n.left,n.bottom-n.top];$ae.assertIsValidBox({x:s,y:i,width:o,height:l},"Box.constructor",t),this._x=s,this._y=i,this._width=o,this._height=l}get x(){return this._x}get y(){return this._y}get width(){return this._width}get height(){return this._height}get left(){return this.x}get top(){return this.y}get right(){return this.x+this.width}get bottom(){return this.y+this.height}get area(){return this.width*this.height}get topLeft(){return new Aae(this.left,this.top)}get topRight(){return new Aae(this.right,this.top)}get bottomLeft(){return new Aae(this.left,this.bottom)}get bottomRight(){return new Aae(this.right,this.bottom)}round(){let[e,t,n,r]=[this.x,this.y,this.width,this.height].map((e=>Math.round(e)));return new $ae({x:e,y:t,width:n,height:r})}floor(){let[e,t,n,r]=[this.x,this.y,this.width,this.height].map((e=>Math.floor(e)));return new $ae({x:e,y:t,width:n,height:r})}toSquare(){let{x:e,y:t,width:n,height:r}=this,a=Math.abs(n-r);return n<r&&(e-=a/2,n+=a),r<n&&(t-=a/2,r+=a),new $ae({x:e,y:t,width:n,height:r})}rescale(e){let t=Sae(e)?e.width:e,n=Sae(e)?e.height:e;return new $ae({x:this.x*t,y:this.y*n,width:this.width*t,height:this.height*n})}pad(e,t){let[n,r,a,s]=[this.x-e/2,this.y-t/2,this.width+e,this.height+t];return new $ae({x:n,y:r,width:a,height:s})}clipAtImageBorders(e,t){let{x:n,y:r,right:a,bottom:s}=this,i=Math.max(n,0),o=Math.max(r,0),l=a-i,u=s-o,p=Math.min(l,e-i),c=Math.min(u,t-o);return new $ae({x:i,y:o,width:p,height:c}).floor()}shift(e,t){let{width:n,height:r}=this,a=this.x+e,s=this.y+t;return new $ae({x:a,y:s,width:n,height:r})}padAtBorders(e,t){let n=this.width+1,r=this.height+1,a=1,s=1,i=n,o=r,l=this.left,u=this.top,p=this.right,c=this.bottom;return p>t&&(i=-p+t+n,p=t),c>e&&(o=-c+e+r,c=e),l<1&&(o=2-l,l=1),u<1&&(o=2-u,u=1),{dy:s,edy:o,dx:a,edx:i,y:u,ey:c,x:l,ex:p,w:n,h:r}}calibrate(e){return new $ae({left:this.left+e.left*this.width,top:this.top+e.top*this.height,right:this.right+e.right*this.width,bottom:this.bottom+e.bottom*this.height}).toSquare().round()}},Rae=class extends $ae{constructor(e,t,n,r,a=!1){super({left:e,top:t,right:n,bottom:r},a)}},Fae=class{constructor(e,t,n,r,a){this._imageDims=new mae(a.width,a.height),this._score=e,this._classScore=t,this._className=n,this._box=new $ae(r).rescale(this._imageDims)}get score(){return this._score}get classScore(){return this._classScore}get className(){return this._className}get box(){return this._box}get imageDims(){return this._imageDims}get imageWidth(){return this.imageDims.width}get imageHeight(){return this.imageDims.height}get relativeBox(){return new $ae(this._box).rescale(this.imageDims.reverse())}forSize(e,t){return new Fae(this.score,this.classScore,this.className,this.relativeBox,{width:e,height:t})}},Dae=class extends Fae{constructor(e,t,n){super(e,e,"",t,n)}forSize(e,t){let{score:n,relativeBox:r,imageDims:a}=super.forSize(e,t);return new Dae(n,r,a)}};function Mae(e,t,n=!0){let r=Math.max(0,Math.min(e.right,t.right)-Math.max(e.left,t.left)),a=Math.max(0,Math.min(e.bottom,t.bottom)-Math.max(e.top,t.top)),s=r*a;return n?s/(e.area+t.area-s):s/Math.min(e.area,t.area)}function Oae(e){let t=e.map((e=>e.x)),n=e.map((e=>e.y)),r=t.reduce(((e,t)=>t<e?t:e),1/0),a=n.reduce(((e,t)=>t<e?t:e),1/0),s=t.reduce(((e,t)=>e<t?t:e),0),i=n.reduce(((e,t)=>e<t?t:e),0);return new Rae(r,a,s,i)}function Pae(e,t,n,r=!0){let a=t.map(((e,t)=>({score:e,boxIndex:t}))).sort(((e,t)=>e.score-t.score)).map((e=>e.boxIndex)),s=[];for(;a.length>0;){let t=a.pop();s.push(t);let i=a,o=[];for(let n=0;n<i.length;n++){let a=i[n],s=e[t],l=e[a];o.push(Mae(s,l,r))}a=a.filter(((e,t)=>o[t]<=n))}return s}function Lae(e,t){return Do((()=>{let[n,r,a]=t,s=Eu([...e.shape.slice(0,3),1],n,"float32"),i=Eu([...e.shape.slice(0,3),1],r,"float32"),o=Eu([...e.shape.slice(0,3),1],a,"float32"),l=Ql([s,i,o],3);return ud(e,l)}))}function zae(e,t=!1){return Do((()=>{let[n,r]=e.shape.slice(1);if(n===r)return e;let a=Math.abs(n-r),s=Math.round(a*(t?.5:1)),i=n>r?2:1,o=t=>{let n=e.shape.slice();return n[i]=t,Eu(n,0,"float32")},l=o(s),u=a-l.shape[i],p=[t&&u?o(u):null,e,l].filter((e=>!!e)).map((e=>wo(e,"float32")));return Ql(p,i)}))}function Bae(e){return 1/(1+Math.exp(-e))}var Wae,Uae=class extends $ae{constructor(e,t,n,r,a=!1){super({x:e,y:t,width:n,height:r},a)}},Vae=.5,Gae=.43,Hae=.45,jae=class{constructor(e,t,n=new Aae(0,0)){let{width:r,height:a}=t;this._imgDims=new mae(r,a),this._shift=n,this._positions=e.map((e=>e.mul(new Aae(r,a)).add(n)))}get shift(){return new Aae(this._shift.x,this._shift.y)}get imageWidth(){return this._imgDims.width}get imageHeight(){return this._imgDims.height}get positions(){return this._positions}get relativePositions(){return this._positions.map((e=>e.sub(this._shift).div(new Aae(this.imageWidth,this.imageHeight))))}forSize(e,t){return new this.constructor(this.relativePositions,{width:e,height:t})}shiftBy(e,t){return new this.constructor(this.relativePositions,this._imgDims,new Aae(e,t))}shiftByPoint(e){return this.shiftBy(e.x,e.y)}align(e,t={}){if(e){let n=e instanceof Dae?e.box.floor():new $ae(e);return this.shiftBy(n.x,n.y).align(null,t)}let{useDlibAlignment:n,minBoxPadding:r}={useDlibAlignment:!1,minBoxPadding:.2,...t};return n?this.alignDlib():this.alignMinBbox(r)}alignDlib(){let e=this.getRefPointsForAlignment(),[t,n,r]=e,a=e=>r.sub(e).magnitude(),s=(a(t)+a(n))/2,i=Math.floor(s/Hae),o=Tae(e),l=Math.floor(Math.max(0,o.x-Vae*i)),u=Math.floor(Math.max(0,o.y-Gae*i));return new Uae(l,u,Math.min(i,this.imageWidth+l),Math.min(i,this.imageHeight+u))}alignMinBbox(e){let t=Oae(this.positions);return t.pad(t.width*e,t.height*e)}getRefPointsForAlignment(){throw new Error("getRefPointsForAlignment not implemented by base class")}},qae=class extends jae{getJawOutline(){return this.positions.slice(0,17)}getLeftEyeBrow(){return this.positions.slice(17,22)}getRightEyeBrow(){return this.positions.slice(22,27)}getNose(){return this.positions.slice(27,36)}getLeftEye(){return this.positions.slice(36,42)}getRightEye(){return this.positions.slice(42,48)}getMouth(){return this.positions.slice(48,68)}getRefPointsForAlignment(){return[this.getLeftEye(),this.getRightEye(),this.getMouth()].map(Tae)}},Kae=class{constructor(e,t){this._label=e,this._distance=t}get label(){return this._label}get distance(){return this._distance}toString(e=!0){return`${this.label}${e?` (${Iae(this.distance)})`:""}`}},Xae=class{constructor(e,t){if("string"!=typeof e)throw new Error("LabeledFaceDescriptors - constructor expected label to be a string");if(!Array.isArray(t)||t.some((e=>!(e instanceof Float32Array))))throw new Error("LabeledFaceDescriptors - constructor expected descriptors to be an array of Float32Array");this._label=e,this._descriptors=t}get label(){return this._label}get descriptors(){return this._descriptors}toJSON(){return{label:this.label,descriptors:this.descriptors.map((e=>Array.from(e)))}}static fromJSON(e){let t=e.descriptors.map((e=>new Float32Array(e)));return new Xae(e.label,t)}};function Jae(e){return e.detection instanceof Dae}function Yae(e,t){return{...e,detection:t}}function Zae(){let e=window.fetch;if(!e)throw new Error("fetch - missing fetch implementation for browser environment");return{Canvas:HTMLCanvasElement,CanvasRenderingContext2D:CanvasRenderingContext2D,Image:HTMLImageElement,ImageData:ImageData,Video:HTMLVideoElement,createCanvasElement:()=>document.createElement("canvas"),createImageElement:()=>document.createElement("img"),createVideoElement:()=>document.createElement("video"),fetch:e,readFile:()=>{throw new Error("readFile - filesystem not available for browser environment")}}}function Qae(){return"object"==typeof n.g&&"undefined"!=typeof process&&null!=process.versions&&null!=process.versions.node}function ese(e){let t="";if(!e&&Qae())try{e=i("fs")}catch(n){t=n.toString()}return{readFile:e?t=>new Promise(((n,r)=>{e.readFile(t,((e,t)=>e?r(e):n(t)))})):()=>{throw new Error(`readFile - failed to require fs in nodejs environment with error: ${t}`)}}}function tse(){let e=n.g.Canvas||n.g.HTMLCanvasElement,t=n.g.Image||n.g.HTMLImageElement,r=n.g.Video||n.g.HTMLVideoElement,a=()=>{if(e)return new e;throw new Error("createCanvasElement - missing Canvas implementation for nodejs environment")},s=()=>{if(t)return new t;throw new Error("createImageElement - missing Image implementation for nodejs environment")},i=()=>{if(r)return new r;throw new Error("createVideoElement - missing Video implementation for nodejs environment")},o=n.g.fetch,l=ese();return{Canvas:e||class{},CanvasRenderingContext2D:n.g.CanvasRenderingContext2D||class{},Image:t||class{},ImageData:n.g.ImageData||class{},Video:n.g.HTMLVideoElement||class{},createCanvasElement:a,createImageElement:s,createVideoElement:i,fetch:o,...l}}function nse(){return"object"==typeof window&&"undefined"!=typeof document&&"undefined"!=typeof HTMLImageElement&&"undefined"!=typeof HTMLCanvasElement&&"undefined"!=typeof HTMLVideoElement&&"undefined"!=typeof ImageData&&"undefined"!=typeof CanvasRenderingContext2D}function rse(){if(!Wae)throw new Error("getEnv - environment is not defined, check isNodejs() and isBrowser()");return Wae}function ase(e){Wae=e}function sse(){return nse()?ase(Zae()):Qae()?ase(tse()):null}function ise(e){if(Wae||sse(),!Wae)throw new Error("monkeyPatch - environment is not defined, check isNodejs() and isBrowser()");let{Canvas:t=Wae.Canvas,Image:n=Wae.Image}=e;Wae.Canvas=t,Wae.Image=n,Wae.createCanvasElement=e.createCanvasElement||(()=>new t),Wae.createImageElement=e.createImageElement||(()=>new n),Wae.ImageData=e.ImageData||Wae.ImageData,Wae.Video=e.Video||Wae.Video,Wae.fetch=e.fetch||Wae.fetch,Wae.readFile=e.readFile||Wae.readFile}var ose={getEnv:rse,setEnv:ase,initialize:sse,createBrowserEnv:Zae,createFileSystem:ese,createNodejsEnv:tse,monkeyPatch:ise,isBrowser:nse,isNodejs:Qae};function lse(e){return ose.isNodejs()||"string"!=typeof e?e:document.getElementById(e)}function use(e){let{Canvas:t,CanvasRenderingContext2D:n}=ose.getEnv();if(e instanceof n)return e;let r=lse(e);if(!(r instanceof t))throw new Error("resolveContext2d - expected canvas to be of instance of Canvas");let a=r.getContext("2d");if(!a)throw new Error("resolveContext2d - canvas 2d context is null");return a}sse();var pse=(e=>(e.TOP_LEFT="TOP_LEFT",e.TOP_RIGHT="TOP_RIGHT",e.BOTTOM_LEFT="BOTTOM_LEFT",e.BOTTOM_RIGHT="BOTTOM_RIGHT",e))(pse||{}),cse=class{constructor(e={}){let{anchorPosition:t,backgroundColor:n,fontColor:r,fontSize:a,fontStyle:s,padding:i}=e;this.anchorPosition=t||"TOP_LEFT",this.backgroundColor=n||"rgba(0, 0, 0, 0.5)",this.fontColor=r||"rgba(255, 255, 255, 1)",this.fontSize=a||14,this.fontStyle=s||"Georgia",this.padding=i||4}},dse=class{constructor(e,t,n={}){this.text="string"==typeof e?[e]:e instanceof dse?e.text:e,this.anchor=t,this.options=new cse(n)}measureWidth(e){let{padding:t}=this.options;return this.text.map((t=>e.measureText(t).width)).reduce(((e,t)=>e<t?t:e),0)+2*t}measureHeight(){let{fontSize:e,padding:t}=this.options;return this.text.length*e+2*t}getUpperLeft(e,t){let{anchorPosition:n}=this.options,r="BOTTOM_RIGHT"===n||"TOP_RIGHT"===n,a="BOTTOM_LEFT"===n||"BOTTOM_RIGHT"===n,s=this.measureWidth(e),i=this.measureHeight(),o=r?this.anchor.x-s:this.anchor.x,l=a?this.anchor.y-i:this.anchor.y;if(t){let{width:e,height:n}=t,r=Math.max(Math.min(o,e-s),0),a=Math.max(Math.min(l,n-i),0);return{x:r,y:a}}return{x:o,y:l}}draw(e){let t=lse(e),n=use(t),{backgroundColor:r,fontColor:a,fontSize:s,fontStyle:i,padding:o}=this.options;n.font=`${s}px ${i}`;let l=this.measureWidth(n),u=this.measureHeight();n.fillStyle=r;let p=this.getUpperLeft(n,t);n.fillRect(p.x,p.y,l,u),n.fillStyle=a,this.text.forEach(((e,t)=>{let r=o+p.x,a=o+p.y+(t+1)*s;n.fillText(e,r,a)}))}},hse=class{constructor(e={}){let{boxColor:t,lineWidth:n,label:r,drawLabelOptions:a}=e;this.boxColor=t||"rgba(0, 0, 255, 1)",this.lineWidth=n||2,this.label=r;let s={anchorPosition:"BOTTOM_LEFT",backgroundColor:this.boxColor};this.drawLabelOptions=new cse({...s,...a})}},fse=class{constructor(e,t={}){this.box=new $ae(e),this.options=new hse(t)}draw(e){let t=use(e),{boxColor:n,lineWidth:r}=this.options,{x:a,y:s,width:i,height:o}=this.box;t.strokeStyle=n,t.lineWidth=r,t.strokeRect(a,s,i,o);let{label:l}=this.options;l&&new dse([l],{x:a-r/2,y:s},this.options.drawLabelOptions).draw(e)}};function mse(e,t){(Array.isArray(t)?t:[t]).forEach((t=>{let n=t instanceof Dae?t.score:Jae(t)?t.detection.score:void 0,r=t instanceof Dae?t.box:Jae(t)?t.detection.box:new $ae(t),a=n?`${Iae(n)}`:void 0;new fse(r,{label:a}).draw(e)}))}function gse(e){let{Image:t,Video:n}=ose.getEnv();return e instanceof t&&e.complete||e instanceof n&&e.readyState>=3}function yse(e){return new Promise(((t,n)=>{function r(e){e.currentTarget&&(e.currentTarget.removeEventListener("load",a),e.currentTarget.removeEventListener("error",r),n(e))}function a(e){e.currentTarget&&(e.currentTarget.removeEventListener("load",a),e.currentTarget.removeEventListener("error",r),t(e))}(e instanceof ose.getEnv().Canvas||gse(e))&&t(null),e.addEventListener("load",a),e.addEventListener("error",r)}))}function bse(e){let{Image:t,Video:n}=ose.getEnv();return e instanceof t?new mae(e.naturalWidth,e.naturalHeight):e instanceof n?new mae(e.videoWidth,e.videoHeight):new mae(e.width,e.height)}function xse({width:e,height:t}){let{createCanvasElement:n}=ose.getEnv(),r=n();return r.width=e,r.height=t,r}function vse(e,t){let{ImageData:n}=ose.getEnv();if(!(e instanceof n)&&!gse(e))throw new Error("createCanvasFromMedia - media has not finished loading yet");let{width:r,height:a}=t||bse(e),s=xse({width:r,height:a});return e instanceof n?use(s).putImageData(e,0,0):use(s).drawImage(e,0,0,r,a),s}async function wse(e,t){let n=t||ose.getEnv().createCanvasElement(),[r,a,s]=e.shape.slice(vae(e)?1:0),i=Do((()=>e.as3D(r,a,s).toInt()));return await mx.toPixels(i,n),i.dispose(),n}function kse(e){let{Image:t,Canvas:n,Video:r}=ose.getEnv();return e instanceof t||e instanceof n||e instanceof r}function Ise(e,t,n=!1){let{Image:r,Canvas:a}=ose.getEnv();if(!(e instanceof r||e instanceof a))throw new Error("imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement");if(t<=0)return xse({width:1,height:1});let s=bse(e),i=t/Math.max(s.height,s.width),o=i*s.width,l=i*s.height,u=xse({width:t,height:t}),p=e instanceof a?e:vse(e),c=Math.abs(o-l)/2,d=n&&o<l?c:0,h=n&&l<o?c:0;return p.width>0&&p.height>0&&use(u).drawImage(p,d,h,o,l),u}var Sse=class{constructor(e,t=!1){if(this._imageTensors=[],this._canvases=[],this._treatAsBatchInput=!1,this._inputDimensions=[],this._inputSize=0,!Array.isArray(e))throw new Error(`NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have ${e}`);this._treatAsBatchInput=t,this._batchSize=e.length,e.forEach(((e,t)=>{if(xae(e))return this._imageTensors[t]=e,void(this._inputDimensions[t]=e.shape);if(vae(e)){let n=e.shape[0];if(1!==n)throw new Error(`NetInput - tf.Tensor4D with batchSize ${n} passed, but not supported in input array`);return this._imageTensors[t]=e,void(this._inputDimensions[t]=e.shape.slice(1))}let n=e instanceof ose.getEnv().Canvas?e:vse(e);this._canvases[t]=n,this._inputDimensions[t]=[n.height,n.width,3]}))}get imageTensors(){return this._imageTensors}get canvases(){return this._canvases}get isBatchInput(){return this.batchSize>1||this._treatAsBatchInput}get batchSize(){return this._batchSize}get inputDimensions(){return this._inputDimensions}get inputSize(){return this._inputSize}get reshapedInputDimensions(){return _ae(this.batchSize,0,1).map(((e,t)=>this.getReshapedInputDimensions(t)))}getInput(e){return this.canvases[e]||this.imageTensors[e]}getInputDimensions(e){return this._inputDimensions[e]}getInputHeight(e){return this._inputDimensions[e][0]}getInputWidth(e){return this._inputDimensions[e][1]}getReshapedInputDimensions(e){if("number"!=typeof this.inputSize)throw new Error("getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet");let t=this.getInputWidth(e),n=this.getInputHeight(e);return Nae({width:t,height:n},this.inputSize)}toBatchTensor(e,t=!0){return this._inputSize=e,Do((()=>{let n=_ae(this.batchSize,0,1).map((n=>{let r=this.getInput(n);if(r instanceof bs){let n=vae(r)?r:hc(r);return n=zae(n,t),(n.shape[1]!==e||n.shape[2]!==e)&&(n=yb.resizeBilinear(n,[e,e],!1,!1)),n.as3D(e,e,3)}if(r instanceof ose.getEnv().Canvas)return mx.fromPixels(Ise(r,e,t));throw new Error(`toBatchTensor - at batchIdx ${n}, expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have ${r}`)}));return hm(n.map((e=>wo(e,"float32")))).as4D(this.batchSize,e,e,3)}))}};async function Nse(e){if(e instanceof Sse)return e;let t=Array.isArray(e)?e:[e];if(!t.length)throw new Error("toNetInput - empty array passed as input");let n=t=>Array.isArray(e)?` at input index ${t}:`:"",r=t.map(lse);return r.forEach(((e,r)=>{if(!kse(e)&&!xae(e)&&!vae(e))throw"string"==typeof t[r]?new Error(`toNetInput -${n(r)} string passed, but could not resolve HTMLElement for element id ${t[r]}`):new Error(`toNetInput -${n(r)} expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id`);if(vae(e)){let t=e.shape[0];if(1!==t)throw new Error(`toNetInput -${n(r)} tf.Tensor4D with batchSize ${t} passed, but not supported in input array`)}})),await Promise.all(r.map((e=>kse(e)&&yse(e)))),new Sse(r,Array.isArray(e))}async function Tse(e,t){let{Canvas:n}=ose.getEnv(),r=e;if(!(e instanceof n)){let t=await Nse(e);if(t.batchSize>1)throw new Error("extractFaces - batchSize > 1 not supported");let a=t.getInput(0);r=a instanceof n?a:await wse(a)}let a=use(r);return t.map((e=>e instanceof Dae?e.forSize(r.width,r.height).box.floor():e)).map((e=>e.clipAtImageBorders(r.width,r.height))).map((({x:e,y:t,width:n,height:r})=>{let s=xse({width:n,height:r});return n>0&&r>0&&use(s).putImageData(a.getImageData(e,t,n,r),0,0),s}))}async function _se(e,t){if(!xae(e)&&!vae(e))throw new Error("extractFaceTensors - expected image tensor to be 3D or 4D");if(vae(e)&&e.shape[0]>1)throw new Error("extractFaceTensors - batchSize > 1 not supported");return Do((()=>{let[n,r,a]=e.shape.slice(vae(e)?1:0);return t.map((e=>e instanceof Dae?e.forSize(r,n).box:e)).map((e=>e.clipAtImageBorders(r,n))).filter((e=>e.width>0&&e.height>0)).map((({x:t,y:s,width:i,height:o})=>qf(e.as3D(n,r,a),[s,t,0],[o,i,a])))}))}async function Cse(e,t){let{fetch:n}=ose.getEnv(),r=await n(e,t);if(!(r.status<400))throw new Error(`failed to fetch: (${r.status}) ${r.statusText}, from url: ${r.url}`);return r}async function Ese(e){return(await Cse(e)).json()}function Ase(e,t){let n=`${t}-weights_manifest.json`;if(!e)return{modelBaseUri:"",manifestUri:n};if("/"===e)return{modelBaseUri:"/",manifestUri:`/${n}`};let r=e.startsWith("http://")?"http://":e.startsWith("https://")?"https://":"";e=e.replace(r,"");let a=e.split("/").filter((e=>e)),s=e.endsWith(".json")?a[a.length-1]:n,i=r+(e.endsWith(".json")?a.slice(0,a.length-1):a).join("/");return i=e.startsWith("/")?`/${i}`:i,{modelBaseUri:i,manifestUri:"/"===i?`/${s}`:`${i}/${s}`}}async function $se(e,t){let{manifestUri:n,modelBaseUri:r}=Ase(e,t),a=await Ese(n);return Ob.loadWeights(a,r)}var Rse=class{constructor(e){this._params=void 0,this._paramMappings=[],this._name=e}get params(){return this._params}get paramMappings(){return this._paramMappings}get isLoaded(){return!!this.params}getParamFromPath(e){let{obj:t,objProp:n}=this.traversePropertyPath(e);return t[n]}reassignParamFromPath(e,t){let{obj:n,objProp:r}=this.traversePropertyPath(e);n[r].dispose(),n[r]=t}getParamList(){return this._paramMappings.map((({paramPath:e})=>({path:e,tensor:this.getParamFromPath(e)})))}getTrainableParams(){return this.getParamList().filter((e=>e.tensor instanceof vs))}getFrozenParams(){return this.getParamList().filter((e=>!(e.tensor instanceof vs)))}variable(){this.getFrozenParams().forEach((({path:e,tensor:t})=>{this.reassignParamFromPath(e,t.variable())}))}freeze(){this.getTrainableParams().forEach((({path:e,tensor:t})=>{let n=li(t.dataSync());t.dispose(),this.reassignParamFromPath(e,n)}))}dispose(e=!0){this.getParamList().forEach((t=>{if(e&&t.tensor.isDisposed)throw new Error(`param tensor has already been disposed for path ${t.path}`);t.tensor.dispose()})),this._params=void 0}serializeParams(){return new Float32Array(this.getParamList().map((({tensor:e})=>Array.from(e.dataSync()))).reduce(((e,t)=>e.concat(t))))}async load(e){e instanceof Float32Array?this.extractWeights(e):await this.loadFromUri(e)}async loadFromUri(e){if(e&&"string"!=typeof e)throw new Error(`${this._name}.loadFromUri - expected model uri`);let t=await $se(e,this.getDefaultModelName());this.loadFromWeightMap(t)}async loadFromDisk(e){if(e&&"string"!=typeof e)throw new Error(`${this._name}.loadFromDisk - expected model file path`);let{readFile:t}=ose.getEnv(),{manifestUri:n,modelBaseUri:r}=Ase(e,this.getDefaultModelName()),a=e=>Promise.all(e.map((e=>t(e).then((e=>e.buffer))))),s=Ob.weightsLoaderFactory(a),i=JSON.parse((await t(n)).toString()),o=await s(i,r);this.loadFromWeightMap(o)}loadFromWeightMap(e){let{paramMappings:t,params:n}=this.extractParamsFromWeightMap(e);this._paramMappings=t,this._params=n}extractWeights(e){let{paramMappings:t,params:n}=this.extractParams(e);this._paramMappings=t,this._params=n}traversePropertyPath(e){if(!this.params)throw new Error("traversePropertyPath - model has no loaded params");let t=e.split("/").reduce(((t,n)=>{if(!t.nextObj.hasOwnProperty(n))throw new Error(`traversePropertyPath - object does not have property ${n}, for path ${e}`);return{obj:t.nextObj,objProp:n,nextObj:t.nextObj[n]}}),{nextObj:this.params}),{obj:n,objProp:r}=t;if(!n||!r||!(n[r]instanceof bs))throw new Error(`traversePropertyPath - parameter is not a tensor, for path ${e}`);return{obj:n,objProp:r}}};function Fse(e,t,n){return Do((()=>{let r=Ff(e,t.depthwise_filter,t.pointwise_filter,n,"same");return r=Ko(r,t.bias),r}))}function Dse(e,t,n=!1){return Do((()=>{let r=hf(n?Ko(Wu(e,t.conv0.filters,[2,2],"same"),t.conv0.bias):Fse(e,t.conv0,[2,2])),a=Fse(r,t.conv1,[1,1]),s=hf(Ko(r,a)),i=Fse(s,t.conv2,[1,1]);return hf(Ko(r,Ko(a,i)))}))}function Mse(e,t,n=!1,r=!0){return Do((()=>{let a=hf(n?Ko(Wu(e,t.conv0.filters,r?[2,2]:[1,1],"same"),t.conv0.bias):Fse(e,t.conv0,r?[2,2]:[1,1])),s=Fse(a,t.conv1,[1,1]),i=hf(Ko(a,s)),o=Fse(i,t.conv2,[1,1]),l=hf(Ko(a,Ko(s,o))),u=Fse(l,t.conv3,[1,1]);return hf(Ko(a,Ko(s,Ko(o,u))))}))}function Ose(e,t,n="same",r=!1){return Do((()=>{let a=Ko(Wu(e,t.filters,[1,1],n),t.bias);return r?hf(a):a}))}function Pse(e,t){Object.keys(e).forEach((n=>{t.some((e=>e.originalPath===n))||e[n].dispose()}))}function Lse(e,t){return(n,r,a,s)=>{let i=Im(e(n*r*a*a),[a,a,n,r]),o=vm(e(r));return t.push({paramPath:`${s}/filters`},{paramPath:`${s}/bias`}),{filters:i,bias:o}}}function zse(e,t){return(n,r,a)=>{let s=wm(e(n*r),[n,r]),i=vm(e(r));return t.push({paramPath:`${a}/weights`},{paramPath:`${a}/bias`}),{weights:s,bias:i}}}var Bse=class{constructor(e,t,n){this.depthwise_filter=e,this.pointwise_filter=t,this.bias=n}};function Wse(e,t){return(n,r,a)=>{let s=Im(e(9*n),[3,3,n,1]),i=Im(e(n*r),[1,1,n,r]),o=vm(e(r));return t.push({paramPath:`${a}/depthwise_filter`},{paramPath:`${a}/pointwise_filter`},{paramPath:`${a}/bias`}),new Bse(s,i,o)}}function Use(e){return t=>{let n=e(`${t}/depthwise_filter`,4),r=e(`${t}/pointwise_filter`,4),a=e(`${t}/bias`,1);return new Bse(n,r,a)}}function Vse(e,t){return(n,r,a)=>{let s=e[n];if(!gae(s,r))throw new Error(`expected weightMap[${n}] to be a Tensor${r}D, instead have ${s}`);return t.push({originalPath:n,paramPath:a||n}),s}}function Gse(e){let t=e;function n(e){let n=t.slice(0,e);return t=t.slice(e),n}function r(){return t}return{extractWeights:n,getRemainingWeights:r}}function Hse(e,t){let n=Lse(e,t),r=Wse(e,t);function a(e,t,a,s=!1){let i=s?n(e,t,3,`${a}/conv0`):r(e,t,`${a}/conv0`),o=r(t,t,`${a}/conv1`),l=r(t,t,`${a}/conv2`);return{conv0:i,conv1:o,conv2:l}}function s(e,t,n,s=!1){let{conv0:i,conv1:o,conv2:l}=a(e,t,n,s),u=r(t,t,`${n}/conv3`);return{conv0:i,conv1:o,conv2:l,conv3:u}}return{extractDenseBlock3Params:a,extractDenseBlock4Params:s}}function jse(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Gse(e),{extractDenseBlock4Params:a}=Hse(n,t),s=a(3,32,"dense0",!0),i=a(32,64,"dense1"),o=a(64,128,"dense2"),l=a(128,256,"dense3");if(0!==r().length)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{dense0:s,dense1:i,dense2:o,dense3:l}}}function qse(e){return t=>{let n=e(`${t}/filters`,4),r=e(`${t}/bias`,1);return{filters:n,bias:r}}}function Kse(e,t){let n=Vse(e,t),r=qse(n),a=Use(n);function s(e,t=!1){let n=t?r(`${e}/conv0`):a(`${e}/conv0`),s=a(`${e}/conv1`),i=a(`${e}/conv2`);return{conv0:n,conv1:s,conv2:i}}function i(e,t=!1){let n=t?r(`${e}/conv0`):a(`${e}/conv0`),s=a(`${e}/conv1`),i=a(`${e}/conv2`),o=a(`${e}/conv3`);return{conv0:n,conv1:s,conv2:i,conv3:o}}return{extractDenseBlock3Params:s,extractDenseBlock4Params:i}}function Xse(e){let t=[],{extractDenseBlock4Params:n}=Kse(e,t),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2"),dense3:n("dense3")};return Pse(e,t),{params:r,paramMappings:t}}var Jse=class extends Rse{constructor(){super("FaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceFeatureExtractor - load model before inference");return Do((()=>{let n=wo(e.toBatchTensor(112,!0),"float32"),r=Lae(n,[122.782,117.001,104.298]).div(255),a=Mse(r,t.dense0,!0);return a=Mse(a,t.dense1),a=Mse(a,t.dense2),a=Mse(a,t.dense3),a=Xl(a,[7,7],[2,2],"valid"),a}))}async forward(e){return this.forwardInput(await Nse(e))}getDefaultModelName(){return"face_feature_extractor_model"}extractParamsFromWeightMap(e){return Xse(e)}extractParams(e){return jse(e)}};function Yse(e,t){return Do((()=>Ko(tu(e,t.weights),t.bias)))}function Zse(e,t,n){let r=[],{extractWeights:a,getRemainingWeights:s}=Gse(e),i=zse(a,r)(t,n,"fc");if(0!==s().length)throw new Error(`weights remaing after extract: ${s().length}`);return{paramMappings:r,params:{fc:i}}}function Qse(e){let t=[],n=Vse(e,t);function r(e){let t=n(`${e}/weights`,2),r=n(`${e}/bias`,1);return{weights:t,bias:r}}let a={fc:r("fc")};return Pse(e,t),{params:a,paramMappings:t}}function eie(e){let t={},n={};return Object.keys(e).forEach((r=>{let a=r.startsWith("fc")?n:t;a[r]=e[r]})),{featureExtractorMap:t,classifierMap:n}}var tie=class extends Rse{constructor(e,t){super(e),this._faceFeatureExtractor=t}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return Do((()=>{let n=e instanceof Sse?this.faceFeatureExtractor.forwardInput(e):e;return Yse(n.as2D(n.shape[0],-1),t.fc)}))}dispose(e=!0){this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return Zse(e,this.getClassifierChannelsIn(),this.getClassifierChannelsOut())}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=eie(e);return this.faceFeatureExtractor.loadFromWeightMap(t),Qse(n)}extractParams(e){let t=this.getClassifierChannelsIn(),n=this.getClassifierChannelsOut(),r=n*t+n,a=e.slice(0,e.length-r),s=e.slice(e.length-r);return this.faceFeatureExtractor.extractWeights(a),this.extractClassifierParams(s)}},nie=["neutral","happy","sad","angry","fearful","disgusted","surprised"],rie=class{constructor(e){if(this.neutral=0,this.happy=0,this.sad=0,this.angry=0,this.fearful=0,this.disgusted=0,this.surprised=0,7!==e.length)throw new Error(`FaceExpressions.constructor - expected probabilities.length to be 7, have: ${e.length}`);nie.forEach(((t,n)=>{this[t]=e[n]}))}asSortedArray(){return nie.map((e=>({expression:e,probability:this[e]}))).sort(((e,t)=>t.probability-e.probability))}},aie=class extends tie{constructor(e=new Jse){super("FaceExpressionNet",e)}forwardInput(e){return Do((()=>Yf(this.runNet(e))))}async forward(e){return this.forwardInput(await Nse(e))}async predictExpressions(e){let t=await Nse(e),n=await this.forwardInput(t),r=await Promise.all(Wm(n).map((async e=>{let t=e.dataSync();return e.dispose(),t})));n.dispose();let a=r.map((e=>new rie(e)));return t.isBatchInput?a:a[0]}getDefaultModelName(){return"face_expression_model"}getClassifierChannelsIn(){return 256}getClassifierChannelsOut(){return 7}};function sie(e){return e.expressions instanceof rie}function iie(e,t){return{...e,expressions:t}}function oie(e,t,n=.1,r){(Array.isArray(t)?t:[t]).forEach((t=>{let a=t instanceof rie?t:sie(t)?t.expressions:void 0;if(!a)throw new Error("drawFaceExpressions - expected faceExpressions to be FaceExpressions | WithFaceExpressions<{}> or array thereof");let s=a.asSortedArray().filter((e=>e.probability>n)),i=Jae(t)?t.detection.box.bottomLeft:r||new Aae(0,0);new dse(s.map((e=>`${e.expression} (${Iae(e.probability)})`)),i).draw(e)}))}function lie(e){return Jae(e)&&e.landmarks instanceof jae&&e.unshiftedLandmarks instanceof jae&&e.alignedRect instanceof Dae}function uie(e){let t=e=>180*e/Math.PI,n=(e,t)=>Math.sqrt((e._x-t._x)**2+(e._y-t._y)**2),r={roll:void 0,pitch:void 0,yaw:void 0},a=(e,t,n)=>{let r=Math.floor(e._x-t._x),a=Math.floor(t._x-n._x);return r-a},s=(e,n)=>{let r=Math.hypot(n._x-e._x,n._y-e._y),a=n._y-e._y,s=Math.asin(a/r),i=t(s),o=Math.floor(90-i),l=n._x-e._x<0?-1:1;return o*l},i=(e,r,a)=>{let s=n(e,a),i={_x:(e._x+a._x)/2,_y:(e._y+a._y)/2},o=n(r,i),l=Math.atan(o/s),u=Math.floor(t(l)),p=i._y-r._y<0?-1:1;return u*p};if(!e||!e._positions||68!==e._positions.length)return r;let o=e._positions;return r.roll=s(o[27],o[66]),r.pitch=i(o[14],o[30],o[2]),r.yaw=a(o[14],o[33],o[2]),r}function pie(e,t){let{box:n}=e.detection,r=t.shiftBy(n.x,n.y),a=r.align(),{imageDims:s}=e.detection,i=new Dae(e.detection.score,a.rescale(s.reverse()),s),o=uie(t);return{...e,landmarks:r,unshiftedLandmarks:t,alignedRect:i,angle:o}}var cie=class{constructor(e={}){let{drawLines:t=!0,drawPoints:n=!0,lineWidth:r,lineColor:a,pointSize:s,pointColor:i}=e;this.drawLines=t,this.drawPoints=n,this.lineWidth=r||1,this.pointSize=s||2,this.lineColor=a||"rgba(0, 255, 255, 1)",this.pointColor=i||"rgba(255, 0, 255, 1)"}},die=class{constructor(e,t={}){this.faceLandmarks=e,this.options=new cie(t)}draw(e){let t=use(e),{drawLines:n,drawPoints:r,lineWidth:a,lineColor:s,pointSize:i,pointColor:o}=this.options;if(n&&this.faceLandmarks instanceof qae&&(t.strokeStyle=s,t.lineWidth=a,hae(t,this.faceLandmarks.getJawOutline()),hae(t,this.faceLandmarks.getLeftEyeBrow()),hae(t,this.faceLandmarks.getRightEyeBrow()),hae(t,this.faceLandmarks.getNose()),hae(t,this.faceLandmarks.getLeftEye(),!0),hae(t,this.faceLandmarks.getRightEye(),!0),hae(t,this.faceLandmarks.getMouth(),!0)),r){t.strokeStyle=o,t.fillStyle=o;let e=e=>{t.beginPath(),t.arc(e.x,e.y,i,0,2*Math.PI),t.fill()};this.faceLandmarks.positions.forEach(e)}}};function hie(e,t){(Array.isArray(t)?t:[t]).forEach((t=>{let n=t instanceof jae?t:lie(t)?t.landmarks:void 0;if(!n)throw new Error("drawFaceLandmarks - expected faceExpressions to be FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>> or array thereof");new die(n).draw(e)}))}function fie(e,t){let n=Lse(e,t),r=Wse(e,t);function a(e,t,a){let s=r(e,t,`${a}/separable_conv0`),i=r(t,t,`${a}/separable_conv1`),o=n(e,t,1,`${a}/expansion_conv`);return{separable_conv0:s,separable_conv1:i,expansion_conv:o}}function s(e,t){let n=r(e,e,`${t}/separable_conv0`),a=r(e,e,`${t}/separable_conv1`),s=r(e,e,`${t}/separable_conv2`);return{separable_conv0:n,separable_conv1:a,separable_conv2:s}}return{extractConvParams:n,extractSeparableConvParams:r,extractReductionBlockParams:a,extractMainBlockParams:s}}function mie(e,t){let n=[],{extractWeights:r,getRemainingWeights:a}=Gse(e),{extractConvParams:s,extractSeparableConvParams:i,extractReductionBlockParams:o,extractMainBlockParams:l}=fie(r,n),u=s(3,32,3,"entry_flow/conv_in"),p=o(32,64,"entry_flow/reduction_block_0"),c=o(64,128,"entry_flow/reduction_block_1"),d={conv_in:u,reduction_block_0:p,reduction_block_1:c},h={};_ae(t,0,1).forEach((e=>{h[`main_block_${e}`]=l(128,`middle_flow/main_block_${e}`)}));let f=o(128,256,"exit_flow/reduction_block"),m=i(256,512,"exit_flow/separable_conv"),g={reduction_block:f,separable_conv:m};if(0!==a().length)throw new Error(`weights remaing after extract: ${a().length}`);return{paramMappings:n,params:{entry_flow:d,middle_flow:h,exit_flow:g}}}function gie(e,t){let n=Vse(e,t),r=qse(n),a=Use(n);function s(e){let t=a(`${e}/separable_conv0`),n=a(`${e}/separable_conv1`),s=r(`${e}/expansion_conv`);return{separable_conv0:t,separable_conv1:n,expansion_conv:s}}function i(e){let t=a(`${e}/separable_conv0`),n=a(`${e}/separable_conv1`),r=a(`${e}/separable_conv2`);return{separable_conv0:t,separable_conv1:n,separable_conv2:r}}return{extractConvParams:r,extractSeparableConvParams:a,extractReductionBlockParams:s,extractMainBlockParams:i}}function yie(e,t){let n=[],{extractConvParams:r,extractSeparableConvParams:a,extractReductionBlockParams:s,extractMainBlockParams:i}=gie(e,n),o=r("entry_flow/conv_in"),l=s("entry_flow/reduction_block_0"),u=s("entry_flow/reduction_block_1"),p={conv_in:o,reduction_block_0:l,reduction_block_1:u},c={};_ae(t,0,1).forEach((e=>{c[`main_block_${e}`]=i(`middle_flow/main_block_${e}`)}));let d=s("exit_flow/reduction_block"),h=a("exit_flow/separable_conv"),f={reduction_block:d,separable_conv:h};return Pse(e,n),{params:{entry_flow:p,middle_flow:c,exit_flow:f},paramMappings:n}}function bie(e,t,n){return Ko(Wu(e,t.filters,n,"same"),t.bias)}function xie(e,t,n=!0){let r=n?hf(e):e;return r=Fse(r,t.separable_conv0,[1,1]),r=Fse(hf(r),t.separable_conv1,[1,1]),r=_d(r,[3,3],[2,2],"same"),r=Ko(r,bie(e,t.expansion_conv,[2,2])),r}function vie(e,t){let n=Fse(hf(e),t.separable_conv0,[1,1]);return n=Fse(hf(n),t.separable_conv1,[1,1]),n=Fse(hf(n),t.separable_conv2,[1,1]),n=Ko(n,e),n}var wie=class extends Rse{constructor(e){super("TinyXception"),this._numMainBlocks=e}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyXception - load model before inference");return Do((()=>{let n=wo(e.toBatchTensor(112,!0),"float32"),r=Lae(n,[122.782,117.001,104.298]).div(255),a=hf(bie(r,t.entry_flow.conv_in,[2,2]));return a=xie(a,t.entry_flow.reduction_block_0,!1),a=xie(a,t.entry_flow.reduction_block_1),_ae(this._numMainBlocks,0,1).forEach((e=>{a=vie(a,t.middle_flow[`main_block_${e}`])})),a=xie(a,t.exit_flow.reduction_block),a=hf(Fse(a,t.exit_flow.separable_conv,[1,1])),a}))}async forward(e){return this.forwardInput(await Nse(e))}getDefaultModelName(){return"tiny_xception_model"}extractParamsFromWeightMap(e){return yie(e,this._numMainBlocks)}extractParams(e){return mie(e,this._numMainBlocks)}};function kie(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Gse(e),a=zse(n,t),s=a(512,1,"fc/age"),i=a(512,2,"fc/gender");if(0!==r().length)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{fc:{age:s,gender:i}}}}function Iie(e){let t=[],n=Vse(e,t);function r(e){let t=n(`${e}/weights`,2),r=n(`${e}/bias`,1);return{weights:t,bias:r}}let a={fc:{age:r("fc/age"),gender:r("fc/gender")}};return Pse(e,t),{params:a,paramMappings:t}}var Sie=(e=>(e.FEMALE="female",e.MALE="male",e))(Sie||{}),Nie=class extends Rse{constructor(e=new wie(2)){super("AgeGenderNet"),this._faceFeatureExtractor=e}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return Do((()=>{let n=e instanceof Sse?this.faceFeatureExtractor.forwardInput(e):e,r=Xl(n,[7,7],[2,2],"valid").as2D(n.shape[0],-1),a=Yse(r,t.fc.age).as1D(),s=Yse(r,t.fc.gender);return{age:a,gender:s}}))}forwardInput(e){return Do((()=>{let{age:t,gender:n}=this.runNet(e);return{age:t,gender:Yf(n)}}))}async forward(e){return this.forwardInput(await Nse(e))}async predictAgeAndGender(e){let t=await Nse(e),n=await this.forwardInput(t),r=Wm(n.age),a=Wm(n.gender),s=r.map(((e,t)=>({ageTensor:e,genderTensor:a[t]}))),i=await Promise.all(s.map((async({ageTensor:e,genderTensor:t})=>{let n=e.dataSync()[0],r=t.dataSync()[0],a=r>.5,s=a?"male":"female",i=a?r:1-r;return e.dispose(),t.dispose(),{age:n,gender:s,genderProbability:i}})));return n.age.dispose(),n.gender.dispose(),t.isBatchInput?i:i[0]}getDefaultModelName(){return"age_gender_model"}dispose(e=!0){this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return kie(e)}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=eie(e);return this.faceFeatureExtractor.loadFromWeightMap(t),Iie(n)}extractParams(e){let t=e.slice(0,e.length-1539),n=e.slice(e.length-1539);return this.faceFeatureExtractor.extractWeights(t),this.extractClassifierParams(n)}},Tie=class extends tie{postProcess(e,t,n){let r=n.map((({width:e,height:n})=>{let r=t/Math.max(n,e);return{width:e*r,height:n*r}})),a=r.length;return Do((()=>{let n=(e,t)=>hm([Eu([68],e,"float32"),Eu([68],t,"float32")],1).as2D(1,136).as1D(),s=(e,t)=>{let{width:n,height:a}=r[e];return t(n,a)?Math.abs(n-a)/2:0},i=e=>s(e,((e,t)=>e<t)),o=e=>s(e,((e,t)=>t<e));return e.mul(Eu([a,136],t,"float32")).sub(hm(Array.from(Array(a),((e,t)=>n(i(t),o(t)))))).div(hm(Array.from(Array(a),((e,t)=>n(r[t].width,r[t].height)))))}))}forwardInput(e){return Do((()=>{let t=this.runNet(e);return this.postProcess(t,e.inputSize,e.inputDimensions.map((([e,t])=>({height:e,width:t}))))}))}async forward(e){return this.forwardInput(await Nse(e))}async detectLandmarks(e){let t=await Nse(e),n=Do((()=>Wm(this.forwardInput(t)))),r=await Promise.all(n.map((async(e,n)=>{let r=Array.from(e.dataSync()),a=r.filter(((e,t)=>kae(t))),s=r.filter(((e,t)=>!kae(t)));return new qae(Array(68).fill(0).map(((e,t)=>new Aae(a[t],s[t]))),{height:t.getInputHeight(n),width:t.getInputWidth(n)})})));return n.forEach((e=>e.dispose())),t.isBatchInput?r:r[0]}getClassifierChannelsOut(){return 136}},_ie=class extends Tie{constructor(e=new Jse){super("FaceLandmark68Net",e)}getDefaultModelName(){return"face_landmark_68_model"}getClassifierChannelsIn(){return 256}};function Cie(e){let t=[],{extractDenseBlock3Params:n}=Kse(e,t),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2")};return Pse(e,t),{params:r,paramMappings:t}}function Eie(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Gse(e),{extractDenseBlock3Params:a}=Hse(n,t),s=a(3,32,"dense0",!0),i=a(32,64,"dense1"),o=a(64,128,"dense2");if(0!==r().length)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{dense0:s,dense1:i,dense2:o}}}var Aie=class extends Rse{constructor(){super("TinyFaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyFaceFeatureExtractor - load model before inference");return Do((()=>{let n=wo(e.toBatchTensor(112,!0),"float32"),r=Lae(n,[122.782,117.001,104.298]).div(255),a=Dse(r,t.dense0,!0);return a=Dse(a,t.dense1),a=Dse(a,t.dense2),a=Xl(a,[14,14],[2,2],"valid"),a}))}async forward(e){return this.forwardInput(await Nse(e))}getDefaultModelName(){return"face_feature_extractor_tiny_model"}extractParamsFromWeightMap(e){return Cie(e)}extractParams(e){return Eie(e)}},$ie=class extends Tie{constructor(e=new Aie){super("FaceLandmark68TinyNet",e)}getDefaultModelName(){return"face_landmark_68_tiny_model"}getClassifierChannelsIn(){return 128}};function Rie(e,t){return Ko(el(e,t.weights),t.biases)}function Fie(e,t,n,r,a="same"){let{filters:s,bias:i}=t.conv,o=Wu(e,s,n,a);return o=Ko(o,i),o=Rie(o,t.scale),r?hf(o):o}function Die(e,t){return Fie(e,t,[1,1],!0)}function Mie(e,t){return Fie(e,t,[1,1],!1)}function Oie(e,t){return Fie(e,t,[2,2],!0,"valid")}function Pie(e,t){function n(t,n,r){let a=e(t),s=a.length/(n*r*r);if(wae(s))throw new Error(`depth has to be an integer: ${s}, weights.length: ${a.length}, numFilters: ${n}, filterSize: ${r}`);return Do((()=>Jm(Im(a,[n,s,r,r]),[2,3,1,0])))}function r(r,a,s,i){let o=n(r,a,s),l=vm(e(a));return t.push({paramPath:`${i}/filters`},{paramPath:`${i}/bias`}),{filters:o,bias:l}}function a(n,r){let a=vm(e(n)),s=vm(e(n));return t.push({paramPath:`${r}/weights`},{paramPath:`${r}/biases`}),{weights:a,biases:s}}function s(e,t,n,s){let i=r(e,t,n,`${s}/conv`),o=a(t,`${s}/scale`);return{conv:i,scale:o}}function i(e,t,n,r,a=!1){let i=s((a?.5:1)*e,t,n,`${r}/conv1`),o=s(e,t,n,`${r}/conv2`);return{conv1:i,conv2:o}}return{extractConvLayerParams:s,extractResidualLayerParams:i}}function Lie(e){let{extractWeights:t,getRemainingWeights:n}=Gse(e),r=[],{extractConvLayerParams:a,extractResidualLayerParams:s}=Pie(t,r),i=a(4704,32,7,"conv32_down"),o=s(9216,32,3,"conv32_1"),l=s(9216,32,3,"conv32_2"),u=s(9216,32,3,"conv32_3"),p=s(36864,64,3,"conv64_down",!0),c=s(36864,64,3,"conv64_1"),d=s(36864,64,3,"conv64_2"),h=s(36864,64,3,"conv64_3"),f=s(147456,128,3,"conv128_down",!0),m=s(147456,128,3,"conv128_1"),g=s(147456,128,3,"conv128_2"),y=s(589824,256,3,"conv256_down",!0),b=s(589824,256,3,"conv256_1"),x=s(589824,256,3,"conv256_2"),v=s(589824,256,3,"conv256_down_out"),w=Do((()=>Jm(wm(t(32768),[128,256]),[1,0])));if(r.push({paramPath:"fc"}),0!==n().length)throw new Error(`weights remaing after extract: ${n().length}`);return{params:{conv32_down:i,conv32_1:o,conv32_2:l,conv32_3:u,conv64_down:p,conv64_1:c,conv64_2:d,conv64_3:h,conv128_down:f,conv128_1:m,conv128_2:g,conv256_down:y,conv256_1:b,conv256_2:x,conv256_down_out:v,fc:w},paramMappings:r}}function zie(e,t){let n=Vse(e,t);function r(e){let t=n(`${e}/scale/weights`,1),r=n(`${e}/scale/biases`,1);return{weights:t,biases:r}}function a(e){let t=n(`${e}/conv/filters`,4),a=n(`${e}/conv/bias`,1),s=r(e);return{conv:{filters:t,bias:a},scale:s}}function s(e){return{conv1:a(`${e}/conv1`),conv2:a(`${e}/conv2`)}}return{extractConvLayerParams:a,extractResidualLayerParams:s}}function Bie(e){let t=[],{extractConvLayerParams:n,extractResidualLayerParams:r}=zie(e,t),a=n("conv32_down"),s=r("conv32_1"),i=r("conv32_2"),o=r("conv32_3"),l=r("conv64_down"),u=r("conv64_1"),p=r("conv64_2"),c=r("conv64_3"),d=r("conv128_down"),h=r("conv128_1"),f=r("conv128_2"),m=r("conv256_down"),g=r("conv256_1"),y=r("conv256_2"),b=r("conv256_down_out"),{fc:x}=e;if(t.push({originalPath:"fc",paramPath:"fc"}),!bae(x))throw new Error(`expected weightMap[fc] to be a Tensor2D, instead have ${x}`);let v={conv32_down:a,conv32_1:s,conv32_2:i,conv32_3:o,conv64_down:l,conv64_1:u,conv64_2:p,conv64_3:c,conv128_down:d,conv128_1:h,conv128_2:f,conv256_down:m,conv256_1:g,conv256_2:y,conv256_down_out:b,fc:x};return Pse(e,t),{params:v,paramMappings:t}}function Wie(e,t){let n=Die(e,t.conv1);return n=Mie(n,t.conv2),n=Ko(n,e),n=hf(n),n}function Uie(e,t){let n=Oie(e,t.conv1);n=Mie(n,t.conv2);let r=Xl(e,2,2,"valid"),a=Od(r.shape),s=r.shape[3]!==n.shape[3];if(r.shape[1]!==n.shape[1]||r.shape[2]!==n.shape[2]){let e=[...n.shape];e[1]=1;let t=Od(e);n=Ql([n,t],1);let r=[...n.shape];r[2]=1;let a=Od(r);n=Ql([n,a],2)}return r=s?Ql([r,a],3):r,n=Ko(r,n),n=hf(n),n}var Vie=class extends Rse{constructor(){super("FaceRecognitionNet")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceRecognitionNet - load model before inference");return Do((()=>{let n=wo(e.toBatchTensor(150,!0),"float32"),r=Lae(n,[122.782,117.001,104.298]).div(255),a=Oie(r,t.conv32_down);a=_d(a,3,2,"valid"),a=Wie(a,t.conv32_1),a=Wie(a,t.conv32_2),a=Wie(a,t.conv32_3),a=Uie(a,t.conv64_down),a=Wie(a,t.conv64_1),a=Wie(a,t.conv64_2),a=Wie(a,t.conv64_3),a=Uie(a,t.conv128_down),a=Wie(a,t.conv128_1),a=Wie(a,t.conv128_2),a=Uie(a,t.conv256_down),a=Wie(a,t.conv256_1),a=Wie(a,t.conv256_2),a=Uie(a,t.conv256_down_out);let s=a.mean([1,2]);return tu(s,t.fc)}))}async forward(e){return this.forwardInput(await Nse(e))}async computeFaceDescriptor(e){var t;if(null!=(t=null==e?void 0:e.shape)&&t.some((e=>e<=0)))return new Float32Array(128);let n=await Nse(e),r=Do((()=>Wm(this.forwardInput(n)))),a=await Promise.all(r.map((e=>e.data())));return r.forEach((e=>e.dispose())),n.isBatchInput?a:a[0]}getDefaultModelName(){return"face_recognition_model"}extractParamsFromWeightMap(e){return Bie(e)}extractParams(e){return Lie(e)}};function Gie(e,t){return{...e,descriptor:t}}function Hie(e,t){return{...e,age:t}}function jie(e,t,n){return{...e,gender:t,genderProbability:n}}function qie(e,t){function n(n,r){let a=Im(e(9*n),[3,3,n,1]),s=vm(e(n)),i=vm(e(n)),o=vm(e(n)),l=vm(e(n));return t.push({paramPath:`${r}/filters`},{paramPath:`${r}/batch_norm_scale`},{paramPath:`${r}/batch_norm_offset`},{paramPath:`${r}/batch_norm_mean`},{paramPath:`${r}/batch_norm_variance`}),{filters:a,batch_norm_scale:s,batch_norm_offset:i,batch_norm_mean:o,batch_norm_variance:l}}function r(n,r,a,s,i){let o=Im(e(n*r*a*a),[a,a,n,r]),l=vm(e(r));return t.push({paramPath:`${s}/filters`},{paramPath:`${s}/${i?"batch_norm_offset":"bias"}`}),{filters:o,bias:l}}function a(e,t,n,a){let{filters:s,bias:i}=r(e,t,n,a,!0);return{filters:s,batch_norm_offset:i}}function s(e,t,r){let s=n(e,`${r}/depthwise_conv`),i=a(e,t,1,`${r}/pointwise_conv`);return{depthwise_conv:s,pointwise_conv:i}}function i(){let e=a(3,32,3,"mobilenetv1/conv_0"),t=s(32,64,"mobilenetv1/conv_1"),n=s(64,128,"mobilenetv1/conv_2"),r=s(128,128,"mobilenetv1/conv_3"),i=s(128,256,"mobilenetv1/conv_4"),o=s(256,256,"mobilenetv1/conv_5"),l=s(256,512,"mobilenetv1/conv_6"),u=s(512,512,"mobilenetv1/conv_7"),p=s(512,512,"mobilenetv1/conv_8"),c=s(512,512,"mobilenetv1/conv_9"),d=s(512,512,"mobilenetv1/conv_10"),h=s(512,512,"mobilenetv1/conv_11"),f=s(512,1024,"mobilenetv1/conv_12"),m=s(1024,1024,"mobilenetv1/conv_13");return{conv_0:e,conv_1:t,conv_2:n,conv_3:r,conv_4:i,conv_5:o,conv_6:l,conv_7:u,conv_8:p,conv_9:c,conv_10:d,conv_11:h,conv_12:f,conv_13:m}}function o(){let e=a(1024,256,1,"prediction_layer/conv_0"),t=a(256,512,3,"prediction_layer/conv_1"),n=a(512,128,1,"prediction_layer/conv_2"),s=a(128,256,3,"prediction_layer/conv_3"),i=a(256,128,1,"prediction_layer/conv_4"),o=a(128,256,3,"prediction_layer/conv_5"),l=a(256,64,1,"prediction_layer/conv_6"),u=a(64,128,3,"prediction_layer/conv_7"),p=r(512,12,1,"prediction_layer/box_predictor_0/box_encoding_predictor"),c=r(512,9,1,"prediction_layer/box_predictor_0/class_predictor"),d=r(1024,24,1,"prediction_layer/box_predictor_1/box_encoding_predictor"),h=r(1024,18,1,"prediction_layer/box_predictor_1/class_predictor"),f=r(512,24,1,"prediction_layer/box_predictor_2/box_encoding_predictor"),m=r(512,18,1,"prediction_layer/box_predictor_2/class_predictor"),g=r(256,24,1,"prediction_layer/box_predictor_3/box_encoding_predictor"),y=r(256,18,1,"prediction_layer/box_predictor_3/class_predictor"),b=r(256,24,1,"prediction_layer/box_predictor_4/box_encoding_predictor"),x=r(256,18,1,"prediction_layer/box_predictor_4/class_predictor"),v=r(128,24,1,"prediction_layer/box_predictor_5/box_encoding_predictor"),w=r(128,18,1,"prediction_layer/box_predictor_5/class_predictor");return{conv_0:e,conv_1:t,conv_2:n,conv_3:s,conv_4:i,conv_5:o,conv_6:l,conv_7:u,box_predictor_0:{box_encoding_predictor:p,class_predictor:c},box_predictor_1:{box_encoding_predictor:d,class_predictor:h},box_predictor_2:{box_encoding_predictor:f,class_predictor:m},box_predictor_3:{box_encoding_predictor:g,class_predictor:y},box_predictor_4:{box_encoding_predictor:b,class_predictor:x},box_predictor_5:{box_encoding_predictor:v,class_predictor:w}}}return{extractMobilenetV1Params:i,extractPredictionLayerParams:o}}function Kie(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Gse(e),{extractMobilenetV1Params:a,extractPredictionLayerParams:s}=qie(n,t),i=a(),o=s(),l={extra_dim:km(n(20472),[1,5118,4])};if(t.push({paramPath:"output_layer/extra_dim"}),0!==r().length)throw new Error(`weights remaing after extract: ${r().length}`);return{params:{mobilenetv1:i,prediction_layer:o,output_layer:l},paramMappings:t}}function Xie(e,t){let n=Vse(e,t);function r(e,t,r){let a=n(`${e}/Conv2d_${t}_pointwise/weights`,4,`${r}/filters`),s=n(`${e}/Conv2d_${t}_pointwise/convolution_bn_offset`,1,`${r}/batch_norm_offset`);return{filters:a,batch_norm_offset:s}}function a(e){let t=`mobilenetv1/conv_${e}`,a=`MobilenetV1/Conv2d_${e}_depthwise`,s=`${t}/depthwise_conv`,i=`${t}/pointwise_conv`,o=n(`${a}/depthwise_weights`,4,`${s}/filters`),l=n(`${a}/BatchNorm/gamma`,1,`${s}/batch_norm_scale`),u=n(`${a}/BatchNorm/beta`,1,`${s}/batch_norm_offset`),p=n(`${a}/BatchNorm/moving_mean`,1,`${s}/batch_norm_mean`),c=n(`${a}/BatchNorm/moving_variance`,1,`${s}/batch_norm_variance`);return{depthwise_conv:{filters:o,batch_norm_scale:l,batch_norm_offset:u,batch_norm_mean:p,batch_norm_variance:c},pointwise_conv:r("MobilenetV1",e,i)}}function s(){return{conv_0:r("MobilenetV1",0,"mobilenetv1/conv_0"),conv_1:a(1),conv_2:a(2),conv_3:a(3),conv_4:a(4),conv_5:a(5),conv_6:a(6),conv_7:a(7),conv_8:a(8),conv_9:a(9),conv_10:a(10),conv_11:a(11),conv_12:a(12),conv_13:a(13)}}function i(e,t){let r=n(`${e}/weights`,4,`${t}/filters`),a=n(`${e}/biases`,1,`${t}/bias`);return{filters:r,bias:a}}function o(e){let t=i(`Prediction/BoxPredictor_${e}/BoxEncodingPredictor`,`prediction_layer/box_predictor_${e}/box_encoding_predictor`),n=i(`Prediction/BoxPredictor_${e}/ClassPredictor`,`prediction_layer/box_predictor_${e}/class_predictor`);return{box_encoding_predictor:t,class_predictor:n}}function l(){return{conv_0:r("Prediction",0,"prediction_layer/conv_0"),conv_1:r("Prediction",1,"prediction_layer/conv_1"),conv_2:r("Prediction",2,"prediction_layer/conv_2"),conv_3:r("Prediction",3,"prediction_layer/conv_3"),conv_4:r("Prediction",4,"prediction_layer/conv_4"),conv_5:r("Prediction",5,"prediction_layer/conv_5"),conv_6:r("Prediction",6,"prediction_layer/conv_6"),conv_7:r("Prediction",7,"prediction_layer/conv_7"),box_predictor_0:o(0),box_predictor_1:o(1),box_predictor_2:o(2),box_predictor_3:o(3),box_predictor_4:o(4),box_predictor_5:o(5)}}return{extractMobilenetV1Params:s,extractPredictionLayerParams:l}}function Jie(e){let t=[],{extractMobilenetV1Params:n,extractPredictionLayerParams:r}=Xie(e,t),a=e["Output/extra_dim"];if(t.push({originalPath:"Output/extra_dim",paramPath:"output_layer/extra_dim"}),!xae(a))throw new Error(`expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have ${a}`);let s={mobilenetv1:n(),prediction_layer:r(),output_layer:{extra_dim:a}};return Pse(e,t),{params:s,paramMappings:t}}function Yie(e,t,n){return Do((()=>{let r=Wu(e,t.filters,n,"same");return r=Ko(r,t.batch_norm_offset),$u(r,0,6)}))}var Zie=.0010000000474974513;function Qie(e,t,n){return Do((()=>{let r=hp(e,t.filters,n,"same");return r=fu(r,t.batch_norm_mean,t.batch_norm_variance,t.batch_norm_offset,t.batch_norm_scale,Zie),$u(r,0,6)}))}function eoe(e){return[2,4,6,12].some((t=>t===e))?[2,2]:[1,1]}function toe(e,t){return Do((()=>{let n,r=Yie(e,t.conv_0,[2,2]);if([t.conv_1,t.conv_2,t.conv_3,t.conv_4,t.conv_5,t.conv_6,t.conv_7,t.conv_8,t.conv_9,t.conv_10,t.conv_11,t.conv_12,t.conv_13].forEach(((e,t)=>{let a=t+1,s=eoe(a);r=Qie(r,e.depthwise_conv,s),r=Yie(r,e.pointwise_conv,[1,1]),11===a&&(n=r)})),null===n)throw new Error("mobileNetV1 - output of conv layer 11 is null");return{out:r,conv11:n}}))}function noe(e,t,n){let r=e.arraySync(),a=Math.min(r[t][0],r[t][2]),s=Math.min(r[t][1],r[t][3]),i=Math.max(r[t][0],r[t][2]),o=Math.max(r[t][1],r[t][3]),l=Math.min(r[n][0],r[n][2]),u=Math.min(r[n][1],r[n][3]),p=Math.max(r[n][0],r[n][2]),c=Math.max(r[n][1],r[n][3]),d=(i-a)*(o-s),h=(p-l)*(c-u);if(d<=0||h<=0)return 0;let f=Math.max(a,l),m=Math.max(s,u),g=Math.min(i,p),y=Math.min(o,c),b=Math.max(g-f,0)*Math.max(y-m,0);return b/(d+h-b)}function roe(e,t,n,r,a){let s=e.shape[0],i=Math.min(n,s),o=t.map(((e,t)=>({score:e,boxIndex:t}))).filter((e=>e.score>a)).sort(((e,t)=>t.score-e.score)),l=e=>e<=r?1:0,u=[];return o.forEach((t=>{if(u.length>=i)return;let n=t.score;for(let r=u.length-1;r>=0;--r){let n=noe(e,t.boxIndex,u[r]);if(0!==n&&(t.score*=l(n),t.score<=a))break}n===t.score&&u.push(t.boxIndex)})),u}function aoe(e){let t=Wm(Jm(e,[1,0])),n=[ud(t[2],t[0]),ud(t[3],t[1])],r=[Ko(t[0],Zo(n[0],2)),Ko(t[1],Zo(n[1],2))];return{sizes:n,centers:r}}function soe(e,t){let{sizes:n,centers:r}=aoe(e),a=Wm(Jm(t,[1,0])),s=Zo(el(cc(Zo(a[2],5)),n[0]),2),i=Ko(el(Zo(a[0],10),n[0]),r[0]),o=Zo(el(cc(Zo(a[3],5)),n[1]),2),l=Ko(el(Zo(a[1],10),n[1]),r[1]);return Jm(hm([ud(i,s),ud(l,o),Ko(i,s),Ko(l,o)]),[1,0])}function ioe(e,t,n){return Do((()=>{let r=e.shape[0],a=soe(ql(yc(n.extra_dim,[r,1,1]),[-1,4]),ql(e,[-1,4]));a=ql(a,[r,a.shape[0]/r,4]);let s=ru(su(t,[0,0,1],[-1,-1,-1])),i=su(s,[0,0,0],[-1,-1,1]);i=ql(i,[r,i.shape[1]]);let o=Wm(a),l=Wm(i);return{boxes:o,scores:l}}))}function ooe(e,t){return Do((()=>{let n=e.shape[0],r=ql(Ose(e,t.box_encoding_predictor),[n,-1,1,4]),a=ql(Ose(e,t.class_predictor),[n,-1,3]);return{boxPredictionEncoding:r,classPrediction:a}}))}function loe(e,t,n){return Do((()=>{let r=Yie(e,n.conv_0,[1,1]),a=Yie(r,n.conv_1,[2,2]),s=Yie(a,n.conv_2,[1,1]),i=Yie(s,n.conv_3,[2,2]),o=Yie(i,n.conv_4,[1,1]),l=Yie(o,n.conv_5,[2,2]),u=Yie(l,n.conv_6,[1,1]),p=Yie(u,n.conv_7,[2,2]),c=ooe(t,n.box_predictor_0),d=ooe(e,n.box_predictor_1),h=ooe(a,n.box_predictor_2),f=ooe(i,n.box_predictor_3),m=ooe(l,n.box_predictor_4),g=ooe(p,n.box_predictor_5),y=Ql([c.boxPredictionEncoding,d.boxPredictionEncoding,h.boxPredictionEncoding,f.boxPredictionEncoding,m.boxPredictionEncoding,g.boxPredictionEncoding],1),b=Ql([c.classPrediction,d.classPrediction,h.classPrediction,f.classPrediction,m.classPrediction,g.classPrediction],1);return{boxPredictions:y,classPredictions:b}}))}var uoe=class{constructor({minConfidence:e,maxResults:t}={}){if(this._name="SsdMobilenetv1Options",this._minConfidence=e||.5,this._maxResults=t||100,"number"!=typeof this._minConfidence||this._minConfidence<=0||this._minConfidence>=1)throw new Error(`${this._name} - expected minConfidence to be a number between 0 and 1`);if("number"!=typeof this._maxResults)throw new Error(`${this._name} - expected maxResults to be a number`)}get minConfidence(){return this._minConfidence}get maxResults(){return this._maxResults}},poe=class extends Rse{constructor(){super("SsdMobilenetv1")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("SsdMobilenetv1 - load model before inference");return Do((()=>{let n=wo(e.toBatchTensor(512,!1),"float32"),r=ud(Zo(n,127.5),1),a=toe(r,t.mobilenetv1),{boxPredictions:s,classPredictions:i}=loe(a.out,a.conv11,t.prediction_layer);return ioe(s,i,t.output_layer)}))}async forward(e){return this.forwardInput(await Nse(e))}async locateFaces(e,t={}){let{maxResults:n,minConfidence:r}=new uoe(t),a=await Nse(e),{boxes:s,scores:i}=this.forwardInput(a),o=s[0],l=i[0];for(let y=1;y<s.length;y++)s[y].dispose(),i[y].dispose();let u=Array.from(l.dataSync()),p=roe(o,u,n,.5,r),c=a.getReshapedInputDimensions(0),d=a.inputSize,h=d/c.width,f=d/c.height,m=o.arraySync(),g=p.map((e=>{let[t,n]=[Math.max(0,m[e][0]),Math.min(1,m[e][2])].map((e=>e*f)),[r,s]=[Math.max(0,m[e][1]),Math.min(1,m[e][3])].map((e=>e*h));return new Dae(u[e],new Uae(r,t,s-r,n-t),{height:a.getInputHeight(0),width:a.getInputWidth(0)})}));return o.dispose(),l.dispose(),g}getDefaultModelName(){return"ssd_mobilenetv1_model"}extractParamsFromWeightMap(e){return Jie(e)}extractParams(e){return Kie(e)}};var coe=.4,doe=[new Aae(.738768,.874946),new Aae(2.42204,2.65704),new Aae(4.30971,7.04493),new Aae(10.246,4.59428),new Aae(12.6868,11.8741)],hoe=[new Aae(1.603231,2.094468),new Aae(6.041143,7.080126),new Aae(2.882459,3.518061),new Aae(4.266906,5.178857),new Aae(9.041765,10.66308)],foe=[117.001,114.697,97.404],moe="tiny_yolov2_model",goe="tiny_yolov2_separable_conv_model",yoe=e=>"number"==typeof e;function boe(e){if(!e)throw new Error(`invalid config: ${e}`);if("boolean"!=typeof e.withSeparableConvs)throw new Error(`config.withSeparableConvs has to be a boolean, have: ${e.withSeparableConvs}`);if(!yoe(e.iouThreshold)||e.iouThreshold<0||e.iouThreshold>1)throw new Error(`config.iouThreshold has to be a number between [0, 1], have: ${e.iouThreshold}`);if(!Array.isArray(e.classes)||!e.classes.length||!e.classes.every((e=>"string"==typeof e)))throw new Error(`config.classes has to be an array class names: string[], have: ${JSON.stringify(e.classes)}`);if(!Array.isArray(e.anchors)||!e.anchors.length||!e.anchors.map((e=>e||{})).every((e=>yoe(e.x)&&yoe(e.y))))throw new Error(`config.anchors has to be an array of { x: number, y: number }, have: ${JSON.stringify(e.anchors)}`);if(e.meanRgb&&(!Array.isArray(e.meanRgb)||3!==e.meanRgb.length||!e.meanRgb.every(yoe)))throw new Error(`config.meanRgb has to be an array of shape [number, number, number], have: ${JSON.stringify(e.meanRgb)}`)}function xoe(e){return Do((()=>{let t=el(e,Zp(.10000000149011612));return Ko(hf(ud(e,t)),t)}))}function voe(e,t){return Do((()=>{let n=ih(e,[[0,0],[1,1],[1,1],[0,0]]);return n=Wu(n,t.conv.filters,[1,1],"valid"),n=ud(n,t.bn.sub),n=el(n,t.bn.truediv),n=Ko(n,t.conv.bias),xoe(n)}))}function woe(e,t){return Do((()=>{let n=ih(e,[[0,0],[1,1],[1,1],[0,0]]);return n=Ff(n,t.depthwise_filter,t.pointwise_filter,[1,1],"valid"),n=Ko(n,t.bias),xoe(n)}))}function koe(e,t){let n=Lse(e,t);function r(n,r){let a=vm(e(n)),s=vm(e(n));return t.push({paramPath:`${r}/sub`},{paramPath:`${r}/truediv`}),{sub:a,truediv:s}}function a(e,t,a){let s=n(e,t,3,`${a}/conv`),i=r(t,`${a}/bn`);return{conv:s,bn:i}}let s=Wse(e,t);return{extractConvParams:n,extractConvWithBatchNormParams:a,extractSeparableConvParams:s}}function Ioe(e,t,n,r){let a,{extractWeights:s,getRemainingWeights:i}=Gse(e),o=[],{extractConvParams:l,extractConvWithBatchNormParams:u,extractSeparableConvParams:p}=koe(s,o);if(t.withSeparableConvs){let[e,s,i,o,u,c,d,h,f]=r,m=t.isFirstLayerConv2d?l(e,s,3,"conv0"):p(e,s,"conv0"),g=p(s,i,"conv1"),y=p(i,o,"conv2"),b=p(o,u,"conv3"),x=p(u,c,"conv4"),v=p(c,d,"conv5"),w=h?p(d,h,"conv6"):void 0,k=f?p(h,f,"conv7"):void 0,I=l(f||h||d,5*n,1,"conv8");a={conv0:m,conv1:g,conv2:y,conv3:b,conv4:x,conv5:v,conv6:w,conv7:k,conv8:I}}else{let[e,t,s,i,o,p,c,d,h]=r,f=u(e,t,"conv0"),m=u(t,s,"conv1"),g=u(s,i,"conv2"),y=u(i,o,"conv3"),b=u(o,p,"conv4"),x=u(p,c,"conv5"),v=u(c,d,"conv6"),w=u(d,h,"conv7"),k=l(h,5*n,1,"conv8");a={conv0:f,conv1:m,conv2:g,conv3:y,conv4:b,conv5:x,conv6:v,conv7:w,conv8:k}}if(0!==i().length)throw new Error(`weights remaing after extract: ${i().length}`);return{params:a,paramMappings:o}}function Soe(e,t){let n=Vse(e,t);function r(e){let t=n(`${e}/sub`,1),r=n(`${e}/truediv`,1);return{sub:t,truediv:r}}function a(e){let t=n(`${e}/filters`,4),r=n(`${e}/bias`,1);return{filters:t,bias:r}}function s(e){let t=a(`${e}/conv`),n=r(`${e}/bn`);return{conv:t,bn:n}}let i=Use(n);return{extractConvParams:a,extractConvWithBatchNormParams:s,extractSeparableConvParams:i}}function Noe(e,t){let n,r=[],{extractConvParams:a,extractConvWithBatchNormParams:s,extractSeparableConvParams:i}=Soe(e,r);if(t.withSeparableConvs){let e=t.filterSizes&&t.filterSizes.length||9;n={conv0:t.isFirstLayerConv2d?a("conv0"):i("conv0"),conv1:i("conv1"),conv2:i("conv2"),conv3:i("conv3"),conv4:i("conv4"),conv5:i("conv5"),conv6:e>7?i("conv6"):void 0,conv7:e>8?i("conv7"):void 0,conv8:a("conv8")}}else n={conv0:s("conv0"),conv1:s("conv1"),conv2:s("conv2"),conv3:s("conv3"),conv4:s("conv4"),conv5:s("conv5"),conv6:s("conv6"),conv7:s("conv7"),conv8:a("conv8")};return Pse(e,r),{params:n,paramMappings:r}}var Toe=class{constructor({inputSize:e,scoreThreshold:t}={}){if(this._name="TinyYolov2Options",this._inputSize=e||416,this._scoreThreshold=t||.5,"number"!=typeof this._inputSize||this._inputSize%32!==0)throw new Error(`${this._name} - expected inputSize to be a number divisible by 32`);if("number"!=typeof this._scoreThreshold||this._scoreThreshold<=0||this._scoreThreshold>=1)throw new Error(`${this._name} - expected scoreThreshold to be a number between 0 and 1`)}get inputSize(){return this._inputSize}get scoreThreshold(){return this._scoreThreshold}},_oe=class extends Rse{constructor(e){super("TinyYolov2"),boe(e),this._config=e}get config(){return this._config}get withClassScores(){return this.config.withClassScores||this.config.classes.length>1}get boxEncodingSize(){return 5+(this.withClassScores?this.config.classes.length:0)}runTinyYolov2(e,t){let n=voe(e,t.conv0);return n=_d(n,[2,2],[2,2],"same"),n=voe(n,t.conv1),n=_d(n,[2,2],[2,2],"same"),n=voe(n,t.conv2),n=_d(n,[2,2],[2,2],"same"),n=voe(n,t.conv3),n=_d(n,[2,2],[2,2],"same"),n=voe(n,t.conv4),n=_d(n,[2,2],[2,2],"same"),n=voe(n,t.conv5),n=_d(n,[2,2],[1,1],"same"),n=voe(n,t.conv6),n=voe(n,t.conv7),Ose(n,t.conv8,"valid",!1)}runMobilenet(e,t){let n=this.config.isFirstLayerConv2d?xoe(Ose(e,t.conv0,"valid",!1)):woe(e,t.conv0);return n=_d(n,[2,2],[2,2],"same"),n=woe(n,t.conv1),n=_d(n,[2,2],[2,2],"same"),n=woe(n,t.conv2),n=_d(n,[2,2],[2,2],"same"),n=woe(n,t.conv3),n=_d(n,[2,2],[2,2],"same"),n=woe(n,t.conv4),n=_d(n,[2,2],[2,2],"same"),n=woe(n,t.conv5),n=_d(n,[2,2],[1,1],"same"),n=t.conv6?woe(n,t.conv6):n,n=t.conv7?woe(n,t.conv7):n,Ose(n,t.conv8,"valid",!1)}forwardInput(e,t){let{params:n}=this;if(!n)throw new Error("TinyYolov2 - load model before inference");return Do((()=>{let r=wo(e.toBatchTensor(t,!1),"float32");return r=this.config.meanRgb?Lae(r,this.config.meanRgb):r,r=r.div(255),this.config.withSeparableConvs?this.runMobilenet(r,n):this.runTinyYolov2(r,n)}))}async forward(e,t){return this.forwardInput(await Nse(e),t)}async detect(e,t={}){let{inputSize:n,scoreThreshold:r}=new Toe(t),a=await Nse(e),s=await this.forwardInput(a,n),i=Do((()=>Wm(s)[0].expandDims())),o={width:a.getInputWidth(0),height:a.getInputHeight(0)},l=await this.extractBoxes(i,a.getReshapedInputDimensions(0),r);s.dispose(),i.dispose();let u=l.map((e=>e.box)),p=l.map((e=>e.score)),c=l.map((e=>e.classScore)),d=l.map((e=>this.config.classes[e.label]));return Pae(u.map((e=>e.rescale(n))),p,this.config.iouThreshold,!0).map((e=>new Fae(p[e],c[e],d[e],u[e],o)))}getDefaultModelName(){return""}extractParamsFromWeightMap(e){return Noe(e,this.config)}extractParams(e){let t=this.config.filterSizes||_oe.DEFAULT_FILTER_SIZES,n=t?t.length:void 0;if(7!==n&&8!==n&&9!==n)throw new Error(`TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found ${n} filterSizes in config`);return Ioe(e,this.config,this.boxEncodingSize,t)}async extractBoxes(e,t,n){let{width:r,height:a}=t,s=Math.max(r,a),i=s/r,o=s/a,l=e.shape[1],u=this.config.anchors.length,[p,c,d]=Do((()=>{let t=e.reshape([l,l,u,this.boxEncodingSize]),n=t.slice([0,0,0,0],[l,l,u,4]),r=t.slice([0,0,0,4],[l,l,u,1]),a=this.withClassScores?Yf(t.slice([0,0,0,5],[l,l,u,this.config.classes.length]),3):Zp(0);return[n,r,a]})),h=[],f=await c.array(),m=await p.array();for(let g=0;g<l;g++)for(let e=0;e<l;e++)for(let t=0;t<u;t++){let r=Bae(f[g][e][t][0]);if(!n||r>n){let n=(e+Bae(m[g][e][t][0]))/l*i,a=(g+Bae(m[g][e][t][1]))/l*o,s=Math.exp(m[g][e][t][2])*this.config.anchors[t].x/l*i,u=Math.exp(m[g][e][t][3])*this.config.anchors[t].y/l*o,p=n-s/2,c=a-u/2,f={row:g,col:e,anchor:t},{classScore:y,label:b}=this.withClassScores?await this.extractPredictedClass(d,f):{classScore:1,label:0};h.push({box:new Rae(p,c,p+s,c+u),score:r,classScore:r*y,label:b,...f})}}return p.dispose(),c.dispose(),d.dispose(),h}async extractPredictedClass(e,t){let{row:n,col:r,anchor:a}=t,s=await e.array();return Array(this.config.classes.length).fill(0).map(((e,t)=>s[n][r][a][t])).map(((e,t)=>({classScore:e,label:t}))).reduce(((e,t)=>e.classScore>t.classScore?e:t))}},Coe=_oe;Coe.DEFAULT_FILTER_SIZES=[3,16,32,64,128,256,512,1024,1024];var Eoe=class extends Coe{constructor(e=!0){let t={withSeparableConvs:e,iouThreshold:coe,classes:["face"],...e?{anchors:hoe,meanRgb:foe}:{anchors:doe,withClassScores:!0}};super(t)}get withSeparableConvs(){return this.config.withSeparableConvs}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map((e=>new Dae(e.score,e.relativeBox,{width:e.imageWidth,height:e.imageHeight})))}getDefaultModelName(){return this.withSeparableConvs?goe:moe}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}};var Aoe=class extends Toe{constructor(){super(...arguments),this._name="TinyFaceDetectorOptions"}},$oe=class{async then(e){return e(await this.run())}async run(){throw new Error("ComposableTask - run is not implemented")}};async function Roe(e,t,n,r,a=(({alignedRect:e})=>e)){let s=e.map((e=>lie(e)?a(e):e.detection)),i=r||(t instanceof bs?await _se(t,s):await Tse(t,s)),o=await n(i);return i.forEach((e=>e instanceof bs&&e.dispose())),o}async function Foe(e,t,n,r,a){return Roe([e],t,(async e=>n(e[0])),r,a)}var Doe=.4,Moe=[new Aae(1.603231,2.094468),new Aae(6.041143,7.080126),new Aae(2.882459,3.518061),new Aae(4.266906,5.178857),new Aae(9.041765,10.66308)],Ooe=[117.001,114.697,97.404],Poe=class extends Coe{constructor(){let e={withSeparableConvs:!0,iouThreshold:Doe,classes:["face"],anchors:Moe,meanRgb:Ooe,isFirstLayerConv2d:!0,filterSizes:[3,16,32,64,128,256,512]};super(e)}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map((e=>new Dae(e.score,e.relativeBox,{width:e.imageWidth,height:e.imageHeight})))}getDefaultModelName(){return"tiny_face_detector_model"}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}},Loe={ssdMobilenetv1:new poe,tinyFaceDetector:new Poe,tinyYolov2:new Eoe,faceLandmark68Net:new _ie,faceLandmark68TinyNet:new $ie,faceRecognitionNet:new Vie,faceExpressionNet:new aie,ageGenderNet:new Nie},zoe=e=>Loe.tinyFaceDetector.load(e),Boe=e=>Loe.faceLandmark68TinyNet.load(e),Woe=e=>Loe.faceRecognitionNet.load(e),Uoe=class extends $oe{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},Voe=class extends Uoe{async run(){let e=await this.parentTask,t=await Roe(e,this.input,(async e=>Promise.all(e.map((e=>Loe.faceExpressionNet.predictExpressions(e))))),this.extractedFaces);return e.map(((e,n)=>iie(e,t[n])))}withAgeAndGender(){return new Koe(this,this.input)}},Goe=class extends Uoe{async run(){let e=await this.parentTask;if(!e)return;let t=await Foe(e,this.input,(e=>Loe.faceExpressionNet.predictExpressions(e)),this.extractedFaces);return iie(e,t)}withAgeAndGender(){return new Xoe(this,this.input)}},Hoe=class extends Voe{withAgeAndGender(){return new Joe(this,this.input)}withFaceDescriptors(){return new Qoe(this,this.input)}},joe=class extends Goe{withAgeAndGender(){return new Yoe(this,this.input)}withFaceDescriptor(){return new ele(this,this.input)}},qoe=class extends $oe{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},Koe=class extends qoe{async run(){let e=await this.parentTask,t=await Roe(e,this.input,(async e=>Promise.all(e.map((e=>Loe.ageGenderNet.predictAgeAndGender(e))))),this.extractedFaces);return e.map(((e,n)=>{let{age:r,gender:a,genderProbability:s}=t[n];return Hie(jie(e,a,s),r)}))}withFaceExpressions(){return new Voe(this,this.input)}},Xoe=class extends qoe{async run(){let e=await this.parentTask;if(!e)return;let{age:t,gender:n,genderProbability:r}=await Foe(e,this.input,(e=>Loe.ageGenderNet.predictAgeAndGender(e)),this.extractedFaces);return Hie(jie(e,n,r),t)}withFaceExpressions(){return new Goe(this,this.input)}},Joe=class extends Koe{withFaceExpressions(){return new Hoe(this,this.input)}withFaceDescriptors(){return new Qoe(this,this.input)}},Yoe=class extends Xoe{withFaceExpressions(){return new joe(this,this.input)}withFaceDescriptor(){return new ele(this,this.input)}},Zoe=class extends $oe{constructor(e,t){super(),this.parentTask=e,this.input=t}},Qoe=class extends Zoe{async run(){let e=await this.parentTask;return(await Roe(e,this.input,(e=>Promise.all(e.map((e=>Loe.faceRecognitionNet.computeFaceDescriptor(e))))),null,(e=>e.landmarks.align(null,{useDlibAlignment:!0})))).map(((t,n)=>Gie(e[n],t)))}withFaceExpressions(){return new Hoe(this,this.input)}withAgeAndGender(){return new Joe(this,this.input)}},ele=class extends Zoe{async run(){let e=await this.parentTask;if(!e)return;let t=await Foe(e,this.input,(e=>Loe.faceRecognitionNet.computeFaceDescriptor(e)),null,(e=>e.landmarks.align(null,{useDlibAlignment:!0})));return Gie(e,t)}withFaceExpressions(){return new joe(this,this.input)}withAgeAndGender(){return new Yoe(this,this.input)}},tle=class extends $oe{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.useTinyLandmarkNet=n}get landmarkNet(){return this.useTinyLandmarkNet?Loe.faceLandmark68TinyNet:Loe.faceLandmark68Net}},nle=class extends tle{async run(){let e=await this.parentTask,t=e.map((e=>e.detection)),n=this.input instanceof bs?await _se(this.input,t):await Tse(this.input,t),r=await Promise.all(n.map((e=>this.landmarkNet.detectLandmarks(e))));return n.forEach((e=>e instanceof bs&&e.dispose())),e.filter(((e,t)=>r[t])).map(((e,t)=>pie(e,r[t])))}withFaceExpressions(){return new Hoe(this,this.input)}withAgeAndGender(){return new Joe(this,this.input)}withFaceDescriptors(){return new Qoe(this,this.input)}},rle=class extends tle{async run(){let e=await this.parentTask;if(!e)return;let{detection:t}=e,n=this.input instanceof bs?await _se(this.input,[t]):await Tse(this.input,[t]),r=await this.landmarkNet.detectLandmarks(n[0]);return n.forEach((e=>e instanceof bs&&e.dispose())),pie(e,r)}withFaceExpressions(){return new joe(this,this.input)}withAgeAndGender(){return new Yoe(this,this.input)}withFaceDescriptor(){return new ele(this,this.input)}},ale=class extends $oe{constructor(e,t=new uoe){super(),this.input=e,this.options=t}},sle=class extends ale{async run(){let e,{input:t,options:n}=this;if(n instanceof Aoe)e=Loe.tinyFaceDetector.locateFaces(t,n);else if(n instanceof uoe)e=Loe.ssdMobilenetv1.locateFaces(t,n);else{if(!(n instanceof Toe))throw new Error("detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | TinyYolov2Options");e=Loe.tinyYolov2.locateFaces(t,n)}return e}runAndExtendWithFaceDetections(){return new Promise(((e,t)=>{this.run().then((t=>e(t.map((e=>Yae({},e)))))).catch((e=>t(e)))}))}withFaceLandmarks(e=!1){return new nle(this.runAndExtendWithFaceDetections(),this.input,e)}withFaceExpressions(){return new Voe(this.runAndExtendWithFaceDetections(),this.input)}withAgeAndGender(){return new Koe(this.runAndExtendWithFaceDetections(),this.input)}},ile=class extends ale{async run(){let e=await new sle(this.input,this.options),t=e[0];return e.forEach((e=>{e.score>t.score&&(t=e)})),t}runAndExtendWithFaceDetection(){return new Promise((async e=>{let t=await this.run();e(t?Yae({},t):void 0)}))}withFaceLandmarks(e=!1){return new rle(this.runAndExtendWithFaceDetection(),this.input,e)}withFaceExpressions(){return new Goe(this.runAndExtendWithFaceDetection(),this.input)}withAgeAndGender(){return new Xoe(this.runAndExtendWithFaceDetection(),this.input)}};function ole(e,t=new uoe){return new ile(e,t)}function lle(e,t){if(e.length!==t.length)throw new Error("euclideanDistance: arr1.length !== arr2.length");let n=Array.from(e),r=Array.from(t);return Math.sqrt(n.map(((e,t)=>e-r[t])).reduce(((e,t)=>e+t*t),0))}var ule=class{constructor(e,t=.6){this._distanceThreshold=t;let n=Array.isArray(e)?e:[e];if(!n.length)throw new Error("FaceRecognizer.constructor - expected atleast one input");let r=1,a=()=>"person "+r++;this._labeledDescriptors=n.map((e=>{if(e instanceof Xae)return e;if(e instanceof Float32Array)return new Xae(a(),[e]);if(e.descriptor&&e.descriptor instanceof Float32Array)return new Xae(a(),[e.descriptor]);throw new Error("FaceRecognizer.constructor - expected inputs to be of type LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array | Array<LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array>")}))}get labeledDescriptors(){return this._labeledDescriptors}get distanceThreshold(){return this._distanceThreshold}computeMeanDistance(e,t){return t.map((t=>lle(t,e))).reduce(((e,t)=>e+t),0)/(t.length||1)}matchDescriptor(e){return this.labeledDescriptors.map((({descriptors:t,label:n})=>new Kae(n,this.computeMeanDistance(e,t)))).reduce(((e,t)=>e.distance<t.distance?e:t))}findBestMatch(e){let t=this.matchDescriptor(e);return t.distance<this._distanceThreshold?t:new Kae("unknown",t.distance)}toJSON(){return{distanceThreshold:this._distanceThreshold,labeledDescriptors:this._labeledDescriptors.map((e=>e.toJSON()))}}static fromJSON(e){let t=e.labeledDescriptors.map((e=>Xae.fromJSON(e)));return new ule(t,e.distanceThreshold)}}},4870:function(e,t,n){"use strict";n.d(t,{Bj:function(){return s},Fl:function(){return je},IU:function(){return Ae},Jd:function(){return S},PG:function(){return Te},SU:function(){return We},Um:function(){return Ie},WL:function(){return Ve},X$:function(){return C},X3:function(){return Ee},XI:function(){return Le},Xl:function(){return $e},dq:function(){return Oe},iH:function(){return Pe},j:function(){return T},lk:function(){return N},nZ:function(){return o},qj:function(){return ke},qq:function(){return v},yT:function(){return Ce}});n(7658);var r=n(7139);let a;class s{constructor(e=!1){this.detached=e,this._active=!0,this.effects=[],this.cleanups=[],this.parent=a,!e&&a&&(this.index=(a.scopes||(a.scopes=[])).push(this)-1)}get active(){return this._active}run(e){if(this._active){const t=a;try{return a=this,e()}finally{a=t}}else 0}on(){a=this}off(){a=this.parent}stop(e){if(this._active){let t,n;for(t=0,n=this.effects.length;t<n;t++)this.effects[t].stop();for(t=0,n=this.cleanups.length;t<n;t++)this.cleanups[t]();if(this.scopes)for(t=0,n=this.scopes.length;t<n;t++)this.scopes[t].stop(!0);if(!this.detached&&this.parent&&!e){const e=this.parent.scopes.pop();e&&e!==this&&(this.parent.scopes[this.index]=e,e.index=this.index)}this.parent=void 0,this._active=!1}}}function i(e,t=a){t&&t.active&&t.effects.push(e)}function o(){return a}const l=e=>{const t=new Set(e);return t.w=0,t.n=0,t},u=e=>(e.w&m)>0,p=e=>(e.n&m)>0,c=({deps:e})=>{if(e.length)for(let t=0;t<e.length;t++)e[t].w|=m},d=e=>{const{deps:t}=e;if(t.length){let n=0;for(let r=0;r<t.length;r++){const a=t[r];u(a)&&!p(a)?a.delete(e):t[n++]=a,a.w&=~m,a.n&=~m}t.length=n}},h=new WeakMap;let f=0,m=1;const g=30;let y;const b=Symbol(""),x=Symbol("");class v{constructor(e,t=null,n){this.fn=e,this.scheduler=t,this.active=!0,this.deps=[],this.parent=void 0,i(this,n)}run(){if(!this.active)return this.fn();let e=y,t=k;while(e){if(e===this)return;e=e.parent}try{return this.parent=y,y=this,k=!0,m=1<<++f,f<=g?c(this):w(this),this.fn()}finally{f<=g&&d(this),m=1<<--f,y=this.parent,k=t,this.parent=void 0,this.deferStop&&this.stop()}}stop(){y===this?this.deferStop=!0:this.active&&(w(this),this.onStop&&this.onStop(),this.active=!1)}}function w(e){const{deps:t}=e;if(t.length){for(let n=0;n<t.length;n++)t[n].delete(e);t.length=0}}let k=!0;const I=[];function S(){I.push(k),k=!1}function N(){const e=I.pop();k=void 0===e||e}function T(e,t,n){if(k&&y){let t=h.get(e);t||h.set(e,t=new Map);let r=t.get(n);r||t.set(n,r=l());const a=void 0;_(r,a)}}function _(e,t){let n=!1;f<=g?p(e)||(e.n|=m,n=!u(e)):n=!e.has(y),n&&(e.add(y),y.deps.push(e))}function C(e,t,n,a,s,i){const o=h.get(e);if(!o)return;let u=[];if("clear"===t)u=[...o.values()];else if("length"===n&&(0,r.kJ)(e)){const e=Number(a);o.forEach(((t,n)=>{("length"===n||n>=e)&&u.push(t)}))}else switch(void 0!==n&&u.push(o.get(n)),t){case"add":(0,r.kJ)(e)?(0,r.S0)(n)&&u.push(o.get("length")):(u.push(o.get(b)),(0,r._N)(e)&&u.push(o.get(x)));break;case"delete":(0,r.kJ)(e)||(u.push(o.get(b)),(0,r._N)(e)&&u.push(o.get(x)));break;case"set":(0,r._N)(e)&&u.push(o.get(b));break}if(1===u.length)u[0]&&E(u[0]);else{const e=[];for(const t of u)t&&e.push(...t);E(l(e))}}function E(e,t){const n=(0,r.kJ)(e)?e:[...e];for(const r of n)r.computed&&A(r,t);for(const r of n)r.computed||A(r,t)}function A(e,t){(e!==y||e.allowRecurse)&&(e.scheduler?e.scheduler():e.run())}const $=(0,r.fY)("__proto__,__v_isRef,__isVue"),R=new Set(Object.getOwnPropertyNames(Symbol).filter((e=>"arguments"!==e&&"caller"!==e)).map((e=>Symbol[e])).filter(r.yk)),F=z(),D=z(!1,!0),M=z(!0),O=P();function P(){const e={};return["includes","indexOf","lastIndexOf"].forEach((t=>{e[t]=function(...e){const n=Ae(this);for(let t=0,a=this.length;t<a;t++)T(n,"get",t+"");const r=n[t](...e);return-1===r||!1===r?n[t](...e.map(Ae)):r}})),["push","pop","shift","unshift","splice"].forEach((t=>{e[t]=function(...e){S();const n=Ae(this)[t].apply(this,e);return N(),n}})),e}function L(e){const t=Ae(this);return T(t,"has",e),t.hasOwnProperty(e)}function z(e=!1,t=!1){return function(n,a,s){if("__v_isReactive"===a)return!e;if("__v_isReadonly"===a)return e;if("__v_isShallow"===a)return t;if("__v_raw"===a&&s===(e?t?xe:be:t?ye:ge).get(n))return n;const i=(0,r.kJ)(n);if(!e){if(i&&(0,r.RI)(O,a))return Reflect.get(O,a,s);if("hasOwnProperty"===a)return L}const o=Reflect.get(n,a,s);return((0,r.yk)(a)?R.has(a):$(a))?o:(e||T(n,"get",a),t?o:Oe(o)?i&&(0,r.S0)(a)?o:o.value:(0,r.Kn)(o)?e?Se(o):ke(o):o)}}const B=U(),W=U(!0);function U(e=!1){return function(t,n,a,s){let i=t[n];if(_e(i)&&Oe(i)&&!Oe(a))return!1;if(!e&&(Ce(a)||_e(a)||(i=Ae(i),a=Ae(a)),!(0,r.kJ)(t)&&Oe(i)&&!Oe(a)))return i.value=a,!0;const o=(0,r.kJ)(t)&&(0,r.S0)(n)?Number(n)<t.length:(0,r.RI)(t,n),l=Reflect.set(t,n,a,s);return t===Ae(s)&&(o?(0,r.aU)(a,i)&&C(t,"set",n,a,i):C(t,"add",n,a)),l}}function V(e,t){const n=(0,r.RI)(e,t),a=e[t],s=Reflect.deleteProperty(e,t);return s&&n&&C(e,"delete",t,void 0,a),s}function G(e,t){const n=Reflect.has(e,t);return(0,r.yk)(t)&&R.has(t)||T(e,"has",t),n}function H(e){return T(e,"iterate",(0,r.kJ)(e)?"length":b),Reflect.ownKeys(e)}const j={get:F,set:B,deleteProperty:V,has:G,ownKeys:H},q={get:M,set(e,t){return!0},deleteProperty(e,t){return!0}},K=(0,r.l7)({},j,{get:D,set:W}),X=e=>e,J=e=>Reflect.getPrototypeOf(e);function Y(e,t,n=!1,r=!1){e=e["__v_raw"];const a=Ae(e),s=Ae(t);n||(t!==s&&T(a,"get",t),T(a,"get",s));const{has:i}=J(a),o=r?X:n?Fe:Re;return i.call(a,t)?o(e.get(t)):i.call(a,s)?o(e.get(s)):void(e!==a&&e.get(t))}function Z(e,t=!1){const n=this["__v_raw"],r=Ae(n),a=Ae(e);return t||(e!==a&&T(r,"has",e),T(r,"has",a)),e===a?n.has(e):n.has(e)||n.has(a)}function Q(e,t=!1){return e=e["__v_raw"],!t&&T(Ae(e),"iterate",b),Reflect.get(e,"size",e)}function ee(e){e=Ae(e);const t=Ae(this),n=J(t),r=n.has.call(t,e);return r||(t.add(e),C(t,"add",e,e)),this}function te(e,t){t=Ae(t);const n=Ae(this),{has:a,get:s}=J(n);let i=a.call(n,e);i||(e=Ae(e),i=a.call(n,e));const o=s.call(n,e);return n.set(e,t),i?(0,r.aU)(t,o)&&C(n,"set",e,t,o):C(n,"add",e,t),this}function ne(e){const t=Ae(this),{has:n,get:r}=J(t);let a=n.call(t,e);a||(e=Ae(e),a=n.call(t,e));const s=r?r.call(t,e):void 0,i=t.delete(e);return a&&C(t,"delete",e,void 0,s),i}function re(){const e=Ae(this),t=0!==e.size,n=void 0,r=e.clear();return t&&C(e,"clear",void 0,void 0,n),r}function ae(e,t){return function(n,r){const a=this,s=a["__v_raw"],i=Ae(s),o=t?X:e?Fe:Re;return!e&&T(i,"iterate",b),s.forEach(((e,t)=>n.call(r,o(e),o(t),a)))}}function se(e,t,n){return function(...a){const s=this["__v_raw"],i=Ae(s),o=(0,r._N)(i),l="entries"===e||e===Symbol.iterator&&o,u="keys"===e&&o,p=s[e](...a),c=n?X:t?Fe:Re;return!t&&T(i,"iterate",u?x:b),{next(){const{value:e,done:t}=p.next();return t?{value:e,done:t}:{value:l?[c(e[0]),c(e[1])]:c(e),done:t}},[Symbol.iterator](){return this}}}}function ie(e){return function(...t){return"delete"!==e&&this}}function oe(){const e={get(e){return Y(this,e)},get size(){return Q(this)},has:Z,add:ee,set:te,delete:ne,clear:re,forEach:ae(!1,!1)},t={get(e){return Y(this,e,!1,!0)},get size(){return Q(this)},has:Z,add:ee,set:te,delete:ne,clear:re,forEach:ae(!1,!0)},n={get(e){return Y(this,e,!0)},get size(){return Q(this,!0)},has(e){return Z.call(this,e,!0)},add:ie("add"),set:ie("set"),delete:ie("delete"),clear:ie("clear"),forEach:ae(!0,!1)},r={get(e){return Y(this,e,!0,!0)},get size(){return Q(this,!0)},has(e){return Z.call(this,e,!0)},add:ie("add"),set:ie("set"),delete:ie("delete"),clear:ie("clear"),forEach:ae(!0,!0)},a=["keys","values","entries",Symbol.iterator];return a.forEach((a=>{e[a]=se(a,!1,!1),n[a]=se(a,!0,!1),t[a]=se(a,!1,!0),r[a]=se(a,!0,!0)})),[e,n,t,r]}const[le,ue,pe,ce]=oe();function de(e,t){const n=t?e?ce:pe:e?ue:le;return(t,a,s)=>"__v_isReactive"===a?!e:"__v_isReadonly"===a?e:"__v_raw"===a?t:Reflect.get((0,r.RI)(n,a)&&a in t?n:t,a,s)}const he={get:de(!1,!1)},fe={get:de(!1,!0)},me={get:de(!0,!1)};const ge=new WeakMap,ye=new WeakMap,be=new WeakMap,xe=new WeakMap;function ve(e){switch(e){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function we(e){return e["__v_skip"]||!Object.isExtensible(e)?0:ve((0,r.W7)(e))}function ke(e){return _e(e)?e:Ne(e,!1,j,he,ge)}function Ie(e){return Ne(e,!1,K,fe,ye)}function Se(e){return Ne(e,!0,q,me,be)}function Ne(e,t,n,a,s){if(!(0,r.Kn)(e))return e;if(e["__v_raw"]&&(!t||!e["__v_isReactive"]))return e;const i=s.get(e);if(i)return i;const o=we(e);if(0===o)return e;const l=new Proxy(e,2===o?a:n);return s.set(e,l),l}function Te(e){return _e(e)?Te(e["__v_raw"]):!(!e||!e["__v_isReactive"])}function _e(e){return!(!e||!e["__v_isReadonly"])}function Ce(e){return!(!e||!e["__v_isShallow"])}function Ee(e){return Te(e)||_e(e)}function Ae(e){const t=e&&e["__v_raw"];return t?Ae(t):e}function $e(e){return(0,r.Nj)(e,"__v_skip",!0),e}const Re=e=>(0,r.Kn)(e)?ke(e):e,Fe=e=>(0,r.Kn)(e)?Se(e):e;function De(e){k&&y&&(e=Ae(e),_(e.dep||(e.dep=l())))}function Me(e,t){e=Ae(e);const n=e.dep;n&&E(n)}function Oe(e){return!(!e||!0!==e.__v_isRef)}function Pe(e){return ze(e,!1)}function Le(e){return ze(e,!0)}function ze(e,t){return Oe(e)?e:new Be(e,t)}class Be{constructor(e,t){this.__v_isShallow=t,this.dep=void 0,this.__v_isRef=!0,this._rawValue=t?e:Ae(e),this._value=t?e:Re(e)}get value(){return De(this),this._value}set value(e){const t=this.__v_isShallow||Ce(e)||_e(e);e=t?e:Ae(e),(0,r.aU)(e,this._rawValue)&&(this._rawValue=e,this._value=t?e:Re(e),Me(this,e))}}function We(e){return Oe(e)?e.value:e}const Ue={get:(e,t,n)=>We(Reflect.get(e,t,n)),set:(e,t,n,r)=>{const a=e[t];return Oe(a)&&!Oe(n)?(a.value=n,!0):Reflect.set(e,t,n,r)}};function Ve(e){return Te(e)?e:new Proxy(e,Ue)}var Ge;class He{constructor(e,t,n,r){this._setter=t,this.dep=void 0,this.__v_isRef=!0,this[Ge]=!1,this._dirty=!0,this.effect=new v(e,(()=>{this._dirty||(this._dirty=!0,Me(this))})),this.effect.computed=this,this.effect.active=this._cacheable=!r,this["__v_isReadonly"]=n}get value(){const e=Ae(this);return De(e),!e._dirty&&e._cacheable||(e._dirty=!1,e._value=e.effect.run()),e._value}set value(e){this._setter(e)}}function je(e,t,n=!1){let a,s;const i=(0,r.mf)(e);i?(a=e,s=r.dG):(a=e.get,s=e.set);const o=new He(a,s,i||!s,n);return o}Ge="__v_isReadonly"},3396:function(e,t,n){"use strict";n.d(t,{$d:function(){return i},FN:function(){return ln},Fl:function(){return Sn},HY:function(){return Ct},JJ:function(){return G},P$:function(){return te},Q6:function(){return oe},U2:function(){return re},Uk:function(){return Yt},Us:function(){return kt},Wm:function(){return qt},Y3:function(){return b},Y8:function(){return Z},YP:function(){return q},_:function(){return jt},aZ:function(){return le},f3:function(){return H},h:function(){return Nn},iD:function(){return zt},ic:function(){return Ie},j4:function(){return Bt},nK:function(){return ie},up:function(){return Re},wg:function(){return Dt}});n(7658),n(541);var r=n(4870),a=n(7139);function s(e,t,n,r){let a;try{a=r?e(...r):e()}catch(s){o(s,t,n)}return a}function i(e,t,n,r){if((0,a.mf)(e)){const i=s(e,t,n,r);return i&&(0,a.tI)(i)&&i.catch((e=>{o(e,t,n)})),i}const l=[];for(let a=0;a<e.length;a++)l.push(i(e[a],t,n,r));return l}function o(e,t,n,r=!0){const a=t?t.vnode:null;if(t){let r=t.parent;const a=t.proxy,i=n;while(r){const t=r.ec;if(t)for(let n=0;n<t.length;n++)if(!1===t[n](e,a,i))return;r=r.parent}const o=t.appContext.config.errorHandler;if(o)return void s(o,null,10,[e,a,i])}l(e,n,a,r)}function l(e,t,n,r=!0){console.error(e)}let u=!1,p=!1;const c=[];let d=0;const h=[];let f=null,m=0;const g=Promise.resolve();let y=null;function b(e){const t=y||g;return e?t.then(this?e.bind(this):e):t}function x(e){let t=d+1,n=c.length;while(t<n){const r=t+n>>>1,a=T(c[r]);a<e?t=r+1:n=r}return t}function v(e){c.length&&c.includes(e,u&&e.allowRecurse?d+1:d)||(null==e.id?c.push(e):c.splice(x(e.id),0,e),w())}function w(){u||p||(p=!0,y=g.then(C))}function k(e){const t=c.indexOf(e);t>d&&c.splice(t,1)}function I(e){(0,a.kJ)(e)?h.push(...e):f&&f.includes(e,e.allowRecurse?m+1:m)||h.push(e),w()}function S(e,t=(u?d+1:0)){for(0;t<c.length;t++){const e=c[t];e&&e.pre&&(c.splice(t,1),t--,e())}}function N(e){if(h.length){const e=[...new Set(h)];if(h.length=0,f)return void f.push(...e);for(f=e,f.sort(((e,t)=>T(e)-T(t))),m=0;m<f.length;m++)f[m]();f=null,m=0}}const T=e=>null==e.id?1/0:e.id,_=(e,t)=>{const n=T(e)-T(t);if(0===n){if(e.pre&&!t.pre)return-1;if(t.pre&&!e.pre)return 1}return n};function C(e){p=!1,u=!0,c.sort(_);a.dG;try{for(d=0;d<c.length;d++){const e=c[d];e&&!1!==e.active&&s(e,null,14)}}finally{d=0,c.length=0,N(e),u=!1,y=null,(c.length||h.length)&&C(e)}}new Set;new Map;function E(e,t,...n){if(e.isUnmounted)return;const r=e.vnode.props||a.kT;let s=n;const o=t.startsWith("update:"),l=o&&t.slice(7);if(l&&l in r){const e=`${"modelValue"===l?"model":l}Modifiers`,{number:t,trim:i}=r[e]||a.kT;i&&(s=n.map((e=>(0,a.HD)(e)?e.trim():e))),t&&(s=n.map(a.h5))}let u;let p=r[u=(0,a.hR)(t)]||r[u=(0,a.hR)((0,a._A)(t))];!p&&o&&(p=r[u=(0,a.hR)((0,a.rs)(t))]),p&&i(p,e,6,s);const c=r[u+"Once"];if(c){if(e.emitted){if(e.emitted[u])return}else e.emitted={};e.emitted[u]=!0,i(c,e,6,s)}}function A(e,t,n=!1){const r=t.emitsCache,s=r.get(e);if(void 0!==s)return s;const i=e.emits;let o={},l=!1;if(!(0,a.mf)(e)){const r=e=>{const n=A(e,t,!0);n&&(l=!0,(0,a.l7)(o,n))};!n&&t.mixins.length&&t.mixins.forEach(r),e.extends&&r(e.extends),e.mixins&&e.mixins.forEach(r)}return i||l?((0,a.kJ)(i)?i.forEach((e=>o[e]=null)):(0,a.l7)(o,i),(0,a.Kn)(e)&&r.set(e,o),o):((0,a.Kn)(e)&&r.set(e,null),null)}function $(e,t){return!(!e||!(0,a.F7)(t))&&(t=t.slice(2).replace(/Once$/,""),(0,a.RI)(e,t[0].toLowerCase()+t.slice(1))||(0,a.RI)(e,(0,a.rs)(t))||(0,a.RI)(e,t))}let R=null,F=null;function D(e){const t=R;return R=e,F=e&&e.type.__scopeId||null,t}function M(e,t=R,n){if(!t)return e;if(e._n)return e;const r=(...n)=>{r._d&&Pt(-1);const a=D(t);let s;try{s=e(...n)}finally{D(a),r._d&&Pt(1)}return s};return r._n=!0,r._c=!0,r._d=!0,r}function O(e){const{type:t,vnode:n,proxy:r,withProxy:s,props:i,propsOptions:[l],slots:u,attrs:p,emit:c,render:d,renderCache:h,data:f,setupState:m,ctx:g,inheritAttrs:y}=e;let b,x;const v=D(e);try{if(4&n.shapeFlag){const e=s||r;b=Zt(d.call(e,e,h,i,m,f,g)),x=p}else{const e=t;0,b=Zt(e.length>1?e(i,{attrs:p,slots:u,emit:c}):e(i,null)),x=t.props?p:P(p)}}catch(k){Rt.length=0,o(k,e,1),b=qt(At)}let w=b;if(x&&!1!==y){const e=Object.keys(x),{shapeFlag:t}=w;e.length&&7&t&&(l&&e.some(a.tR)&&(x=L(x,l)),w=Jt(w,x))}return n.dirs&&(w=Jt(w),w.dirs=w.dirs?w.dirs.concat(n.dirs):n.dirs),n.transition&&(w.transition=n.transition),b=w,D(v),b}const P=e=>{let t;for(const n in e)("class"===n||"style"===n||(0,a.F7)(n))&&((t||(t={}))[n]=e[n]);return t},L=(e,t)=>{const n={};for(const r in e)(0,a.tR)(r)&&r.slice(9)in t||(n[r]=e[r]);return n};function z(e,t,n){const{props:r,children:a,component:s}=e,{props:i,children:o,patchFlag:l}=t,u=s.emitsOptions;if(t.dirs||t.transition)return!0;if(!(n&&l>=0))return!(!a&&!o||o&&o.$stable)||r!==i&&(r?!i||B(r,i,u):!!i);if(1024&l)return!0;if(16&l)return r?B(r,i,u):!!i;if(8&l){const e=t.dynamicProps;for(let t=0;t<e.length;t++){const n=e[t];if(i[n]!==r[n]&&!$(u,n))return!0}}return!1}function B(e,t,n){const r=Object.keys(t);if(r.length!==Object.keys(e).length)return!0;for(let a=0;a<r.length;a++){const s=r[a];if(t[s]!==e[s]&&!$(n,s))return!0}return!1}function W({vnode:e,parent:t},n){while(t&&t.subTree===e)(e=t.vnode).el=n,t=t.parent}const U=e=>e.__isSuspense;function V(e,t){t&&t.pendingBranch?(0,a.kJ)(e)?t.effects.push(...e):t.effects.push(e):I(e)}function G(e,t){if(on){let n=on.provides;const r=on.parent&&on.parent.provides;r===n&&(n=on.provides=Object.create(r)),n[e]=t}else 0}function H(e,t,n=!1){const r=on||R;if(r){const s=null==r.parent?r.vnode.appContext&&r.vnode.appContext.provides:r.parent.provides;if(s&&e in s)return s[e];if(arguments.length>1)return n&&(0,a.mf)(t)?t.call(r.proxy):t}else 0}const j={};function q(e,t,n){return K(e,t,n)}function K(e,t,{immediate:n,deep:o,flush:l,onTrack:u,onTrigger:p}=a.kT){const c=(0,r.nZ)()===(null===on||void 0===on?void 0:on.scope)?on:null;let d,h,f=!1,m=!1;if((0,r.dq)(e)?(d=()=>e.value,f=(0,r.yT)(e)):(0,r.PG)(e)?(d=()=>e,o=!0):(0,a.kJ)(e)?(m=!0,f=e.some((e=>(0,r.PG)(e)||(0,r.yT)(e))),d=()=>e.map((e=>(0,r.dq)(e)?e.value:(0,r.PG)(e)?Y(e):(0,a.mf)(e)?s(e,c,2):void 0))):d=(0,a.mf)(e)?t?()=>s(e,c,2):()=>{if(!c||!c.isUnmounted)return h&&h(),i(e,c,3,[y])}:a.dG,t&&o){const e=d;d=()=>Y(e())}let g,y=e=>{h=k.onStop=()=>{s(e,c,4)}};if(fn){if(y=a.dG,t?n&&i(t,c,3,[d(),m?[]:void 0,y]):d(),"sync"!==l)return a.dG;{const e=_n();g=e.__watcherHandles||(e.__watcherHandles=[])}}let b=m?new Array(e.length).fill(j):j;const x=()=>{if(k.active)if(t){const e=k.run();(o||f||(m?e.some(((e,t)=>(0,a.aU)(e,b[t]))):(0,a.aU)(e,b)))&&(h&&h(),i(t,c,3,[e,b===j?void 0:m&&b[0]===j?[]:b,y]),b=e)}else k.run()};let w;x.allowRecurse=!!t,"sync"===l?w=x:"post"===l?w=()=>wt(x,c&&c.suspense):(x.pre=!0,c&&(x.id=c.uid),w=()=>v(x));const k=new r.qq(d,w);t?n?x():b=k.run():"post"===l?wt(k.run.bind(k),c&&c.suspense):k.run();const I=()=>{k.stop(),c&&c.scope&&(0,a.Od)(c.scope.effects,k)};return g&&g.push(I),I}function X(e,t,n){const r=this.proxy,s=(0,a.HD)(e)?e.includes(".")?J(r,e):()=>r[e]:e.bind(r,r);let i;(0,a.mf)(t)?i=t:(i=t.handler,n=t);const o=on;un(this);const l=K(s,i.bind(r),n);return o?un(o):pn(),l}function J(e,t){const n=t.split(".");return()=>{let t=e;for(let e=0;e<n.length&&t;e++)t=t[n[e]];return t}}function Y(e,t){if(!(0,a.Kn)(e)||e["__v_skip"])return e;if(t=t||new Set,t.has(e))return e;if(t.add(e),(0,r.dq)(e))Y(e.value,t);else if((0,a.kJ)(e))for(let n=0;n<e.length;n++)Y(e[n],t);else if((0,a.DM)(e)||(0,a._N)(e))e.forEach((e=>{Y(e,t)}));else if((0,a.PO)(e))for(const n in e)Y(e[n],t);return e}function Z(){const e={isMounted:!1,isLeaving:!1,isUnmounting:!1,leavingVNodes:new Map};return we((()=>{e.isMounted=!0})),Se((()=>{e.isUnmounting=!0})),e}const Q=[Function,Array],ee={name:"BaseTransition",props:{mode:String,appear:Boolean,persisted:Boolean,onBeforeEnter:Q,onEnter:Q,onAfterEnter:Q,onEnterCancelled:Q,onBeforeLeave:Q,onLeave:Q,onAfterLeave:Q,onLeaveCancelled:Q,onBeforeAppear:Q,onAppear:Q,onAfterAppear:Q,onAppearCancelled:Q},setup(e,{slots:t}){const n=ln(),a=Z();let s;return()=>{const i=t.default&&oe(t.default(),!0);if(!i||!i.length)return;let o=i[0];if(i.length>1){let e=!1;for(const t of i)if(t.type!==At){0,o=t,e=!0;break}}const l=(0,r.IU)(e),{mode:u}=l;if(a.isLeaving)return ae(o);const p=se(o);if(!p)return ae(o);const c=re(p,l,a,n);ie(p,c);const d=n.subTree,h=d&&se(d);let f=!1;const{getTransitionKey:m}=p.type;if(m){const e=m();void 0===s?s=e:e!==s&&(s=e,f=!0)}if(h&&h.type!==At&&(!Ut(p,h)||f)){const e=re(h,l,a,n);if(ie(h,e),"out-in"===u)return a.isLeaving=!0,e.afterLeave=()=>{a.isLeaving=!1,!1!==n.update.active&&n.update()},ae(o);"in-out"===u&&p.type!==At&&(e.delayLeave=(e,t,n)=>{const r=ne(a,h);r[String(h.key)]=h,e._leaveCb=()=>{t(),e._leaveCb=void 0,delete c.delayedLeave},c.delayedLeave=n})}return o}}},te=ee;function ne(e,t){const{leavingVNodes:n}=e;let r=n.get(t.type);return r||(r=Object.create(null),n.set(t.type,r)),r}function re(e,t,n,r){const{appear:s,mode:o,persisted:l=!1,onBeforeEnter:u,onEnter:p,onAfterEnter:c,onEnterCancelled:d,onBeforeLeave:h,onLeave:f,onAfterLeave:m,onLeaveCancelled:g,onBeforeAppear:y,onAppear:b,onAfterAppear:x,onAppearCancelled:v}=t,w=String(e.key),k=ne(n,e),I=(e,t)=>{e&&i(e,r,9,t)},S=(e,t)=>{const n=t[1];I(e,t),(0,a.kJ)(e)?e.every((e=>e.length<=1))&&n():e.length<=1&&n()},N={mode:o,persisted:l,beforeEnter(t){let r=u;if(!n.isMounted){if(!s)return;r=y||u}t._leaveCb&&t._leaveCb(!0);const a=k[w];a&&Ut(e,a)&&a.el._leaveCb&&a.el._leaveCb(),I(r,[t])},enter(e){let t=p,r=c,a=d;if(!n.isMounted){if(!s)return;t=b||p,r=x||c,a=v||d}let i=!1;const o=e._enterCb=t=>{i||(i=!0,I(t?a:r,[e]),N.delayedLeave&&N.delayedLeave(),e._enterCb=void 0)};t?S(t,[e,o]):o()},leave(t,r){const a=String(e.key);if(t._enterCb&&t._enterCb(!0),n.isUnmounting)return r();I(h,[t]);let s=!1;const i=t._leaveCb=n=>{s||(s=!0,r(),I(n?g:m,[t]),t._leaveCb=void 0,k[a]===e&&delete k[a])};k[a]=e,f?S(f,[t,i]):i()},clone(e){return re(e,t,n,r)}};return N}function ae(e){if(pe(e))return e=Jt(e),e.children=null,e}function se(e){return pe(e)?e.children?e.children[0]:void 0:e}function ie(e,t){6&e.shapeFlag&&e.component?ie(e.component.subTree,t):128&e.shapeFlag?(e.ssContent.transition=t.clone(e.ssContent),e.ssFallback.transition=t.clone(e.ssFallback)):e.transition=t}function oe(e,t=!1,n){let r=[],a=0;for(let s=0;s<e.length;s++){let i=e[s];const o=null==n?i.key:String(n)+String(null!=i.key?i.key:s);i.type===Ct?(128&i.patchFlag&&a++,r=r.concat(oe(i.children,t,o))):(t||i.type!==At)&&r.push(null!=o?Jt(i,{key:o}):i)}if(a>1)for(let s=0;s<r.length;s++)r[s].patchFlag=-2;return r}function le(e){return(0,a.mf)(e)?{setup:e,name:e.name}:e}const ue=e=>!!e.type.__asyncLoader;const pe=e=>e.type.__isKeepAlive;RegExp,RegExp;function ce(e,t){return(0,a.kJ)(e)?e.some((e=>ce(e,t))):(0,a.HD)(e)?e.split(",").includes(t):!!(0,a.Kj)(e)&&e.test(t)}function de(e,t){fe(e,"a",t)}function he(e,t){fe(e,"da",t)}function fe(e,t,n=on){const r=e.__wdc||(e.__wdc=()=>{let t=n;while(t){if(t.isDeactivated)return;t=t.parent}return e()});if(be(t,r,n),n){let e=n.parent;while(e&&e.parent)pe(e.parent.vnode)&&me(r,t,n,e),e=e.parent}}function me(e,t,n,r){const s=be(t,e,r,!0);Ne((()=>{(0,a.Od)(r[t],s)}),n)}function ge(e){e.shapeFlag&=-257,e.shapeFlag&=-513}function ye(e){return 128&e.shapeFlag?e.ssContent:e}function be(e,t,n=on,a=!1){if(n){const s=n[e]||(n[e]=[]),o=t.__weh||(t.__weh=(...a)=>{if(n.isUnmounted)return;(0,r.Jd)(),un(n);const s=i(t,n,e,a);return pn(),(0,r.lk)(),s});return a?s.unshift(o):s.push(o),o}}const xe=e=>(t,n=on)=>(!fn||"sp"===e)&&be(e,((...e)=>t(...e)),n),ve=xe("bm"),we=xe("m"),ke=xe("bu"),Ie=xe("u"),Se=xe("bum"),Ne=xe("um"),Te=xe("sp"),_e=xe("rtg"),Ce=xe("rtc");function Ee(e,t=on){be("ec",e,t)}function Ae(e,t,n,a){const s=e.dirs,o=t&&t.dirs;for(let l=0;l<s.length;l++){const u=s[l];o&&(u.oldValue=o[l].value);let p=u.dir[a];p&&((0,r.Jd)(),i(p,n,8,[e.el,u,e,t]),(0,r.lk)())}}const $e="components";function Re(e,t){return De($e,e,!0,t)||e}const Fe=Symbol();function De(e,t,n=!0,r=!1){const s=R||on;if(s){const n=s.type;if(e===$e){const e=kn(n,!1);if(e&&(e===t||e===(0,a._A)(t)||e===(0,a.kC)((0,a._A)(t))))return n}const i=Me(s[e]||n[e],t)||Me(s.appContext[e],t);return!i&&r?n:i}}function Me(e,t){return e&&(e[t]||e[(0,a._A)(t)]||e[(0,a.kC)((0,a._A)(t))])}const Oe=e=>e?cn(e)?wn(e)||e.proxy:Oe(e.parent):null,Pe=(0,a.l7)(Object.create(null),{$:e=>e,$el:e=>e.vnode.el,$data:e=>e.data,$props:e=>e.props,$attrs:e=>e.attrs,$slots:e=>e.slots,$refs:e=>e.refs,$parent:e=>Oe(e.parent),$root:e=>Oe(e.root),$emit:e=>e.emit,$options:e=>He(e),$forceUpdate:e=>e.f||(e.f=()=>v(e.update)),$nextTick:e=>e.n||(e.n=b.bind(e.proxy)),$watch:e=>X.bind(e)}),Le=(e,t)=>e!==a.kT&&!e.__isScriptSetup&&(0,a.RI)(e,t),ze={get({_:e},t){const{ctx:n,setupState:s,data:i,props:o,accessCache:l,type:u,appContext:p}=e;let c;if("$"!==t[0]){const r=l[t];if(void 0!==r)switch(r){case 1:return s[t];case 2:return i[t];case 4:return n[t];case 3:return o[t]}else{if(Le(s,t))return l[t]=1,s[t];if(i!==a.kT&&(0,a.RI)(i,t))return l[t]=2,i[t];if((c=e.propsOptions[0])&&(0,a.RI)(c,t))return l[t]=3,o[t];if(n!==a.kT&&(0,a.RI)(n,t))return l[t]=4,n[t];Be&&(l[t]=0)}}const d=Pe[t];let h,f;return d?("$attrs"===t&&(0,r.j)(e,"get",t),d(e)):(h=u.__cssModules)&&(h=h[t])?h:n!==a.kT&&(0,a.RI)(n,t)?(l[t]=4,n[t]):(f=p.config.globalProperties,(0,a.RI)(f,t)?f[t]:void 0)},set({_:e},t,n){const{data:r,setupState:s,ctx:i}=e;return Le(s,t)?(s[t]=n,!0):r!==a.kT&&(0,a.RI)(r,t)?(r[t]=n,!0):!(0,a.RI)(e.props,t)&&(("$"!==t[0]||!(t.slice(1)in e))&&(i[t]=n,!0))},has({_:{data:e,setupState:t,accessCache:n,ctx:r,appContext:s,propsOptions:i}},o){let l;return!!n[o]||e!==a.kT&&(0,a.RI)(e,o)||Le(t,o)||(l=i[0])&&(0,a.RI)(l,o)||(0,a.RI)(r,o)||(0,a.RI)(Pe,o)||(0,a.RI)(s.config.globalProperties,o)},defineProperty(e,t,n){return null!=n.get?e._.accessCache[t]=0:(0,a.RI)(n,"value")&&this.set(e,t,n.value,null),Reflect.defineProperty(e,t,n)}};let Be=!0;function We(e){const t=He(e),n=e.proxy,s=e.ctx;Be=!1,t.beforeCreate&&Ve(t.beforeCreate,e,"bc");const{data:i,computed:o,methods:l,watch:u,provide:p,inject:c,created:d,beforeMount:h,mounted:f,beforeUpdate:m,updated:g,activated:y,deactivated:b,beforeDestroy:x,beforeUnmount:v,destroyed:w,unmounted:k,render:I,renderTracked:S,renderTriggered:N,errorCaptured:T,serverPrefetch:_,expose:C,inheritAttrs:E,components:A,directives:$,filters:R}=t,F=null;if(c&&Ue(c,s,F,e.appContext.config.unwrapInjectedRef),l)for(const r in l){const e=l[r];(0,a.mf)(e)&&(s[r]=e.bind(n))}if(i){0;const t=i.call(n,n);0,(0,a.Kn)(t)&&(e.data=(0,r.qj)(t))}if(Be=!0,o)for(const r in o){const e=o[r],t=(0,a.mf)(e)?e.bind(n,n):(0,a.mf)(e.get)?e.get.bind(n,n):a.dG;0;const i=!(0,a.mf)(e)&&(0,a.mf)(e.set)?e.set.bind(n):a.dG,l=Sn({get:t,set:i});Object.defineProperty(s,r,{enumerable:!0,configurable:!0,get:()=>l.value,set:e=>l.value=e})}if(u)for(const r in u)Ge(u[r],s,n,r);if(p){const e=(0,a.mf)(p)?p.call(n):p;Reflect.ownKeys(e).forEach((t=>{G(t,e[t])}))}function D(e,t){(0,a.kJ)(t)?t.forEach((t=>e(t.bind(n)))):t&&e(t.bind(n))}if(d&&Ve(d,e,"c"),D(ve,h),D(we,f),D(ke,m),D(Ie,g),D(de,y),D(he,b),D(Ee,T),D(Ce,S),D(_e,N),D(Se,v),D(Ne,k),D(Te,_),(0,a.kJ)(C))if(C.length){const t=e.exposed||(e.exposed={});C.forEach((e=>{Object.defineProperty(t,e,{get:()=>n[e],set:t=>n[e]=t})}))}else e.exposed||(e.exposed={});I&&e.render===a.dG&&(e.render=I),null!=E&&(e.inheritAttrs=E),A&&(e.components=A),$&&(e.directives=$)}function Ue(e,t,n=a.dG,s=!1){(0,a.kJ)(e)&&(e=Je(e));for(const i in e){const n=e[i];let o;o=(0,a.Kn)(n)?"default"in n?H(n.from||i,n.default,!0):H(n.from||i):H(n),(0,r.dq)(o)&&s?Object.defineProperty(t,i,{enumerable:!0,configurable:!0,get:()=>o.value,set:e=>o.value=e}):t[i]=o}}function Ve(e,t,n){i((0,a.kJ)(e)?e.map((e=>e.bind(t.proxy))):e.bind(t.proxy),t,n)}function Ge(e,t,n,r){const s=r.includes(".")?J(n,r):()=>n[r];if((0,a.HD)(e)){const n=t[e];(0,a.mf)(n)&&q(s,n)}else if((0,a.mf)(e))q(s,e.bind(n));else if((0,a.Kn)(e))if((0,a.kJ)(e))e.forEach((e=>Ge(e,t,n,r)));else{const r=(0,a.mf)(e.handler)?e.handler.bind(n):t[e.handler];(0,a.mf)(r)&&q(s,r,e)}else 0}function He(e){const t=e.type,{mixins:n,extends:r}=t,{mixins:s,optionsCache:i,config:{optionMergeStrategies:o}}=e.appContext,l=i.get(t);let u;return l?u=l:s.length||n||r?(u={},s.length&&s.forEach((e=>je(u,e,o,!0))),je(u,t,o)):u=t,(0,a.Kn)(t)&&i.set(t,u),u}function je(e,t,n,r=!1){const{mixins:a,extends:s}=t;s&&je(e,s,n,!0),a&&a.forEach((t=>je(e,t,n,!0)));for(const i in t)if(r&&"expose"===i);else{const r=qe[i]||n&&n[i];e[i]=r?r(e[i],t[i]):t[i]}return e}const qe={data:Ke,props:Ze,emits:Ze,methods:Ze,computed:Ze,beforeCreate:Ye,created:Ye,beforeMount:Ye,mounted:Ye,beforeUpdate:Ye,updated:Ye,beforeDestroy:Ye,beforeUnmount:Ye,destroyed:Ye,unmounted:Ye,activated:Ye,deactivated:Ye,errorCaptured:Ye,serverPrefetch:Ye,components:Ze,directives:Ze,watch:Qe,provide:Ke,inject:Xe};function Ke(e,t){return t?e?function(){return(0,a.l7)((0,a.mf)(e)?e.call(this,this):e,(0,a.mf)(t)?t.call(this,this):t)}:t:e}function Xe(e,t){return Ze(Je(e),Je(t))}function Je(e){if((0,a.kJ)(e)){const t={};for(let n=0;n<e.length;n++)t[e[n]]=e[n];return t}return e}function Ye(e,t){return e?[...new Set([].concat(e,t))]:t}function Ze(e,t){return e?(0,a.l7)((0,a.l7)(Object.create(null),e),t):t}function Qe(e,t){if(!e)return t;if(!t)return e;const n=(0,a.l7)(Object.create(null),e);for(const r in t)n[r]=Ye(e[r],t[r]);return n}function et(e,t,n,s=!1){const i={},o={};(0,a.Nj)(o,Vt,1),e.propsDefaults=Object.create(null),nt(e,t,i,o);for(const r in e.propsOptions[0])r in i||(i[r]=void 0);n?e.props=s?i:(0,r.Um)(i):e.type.props?e.props=i:e.props=o,e.attrs=o}function tt(e,t,n,s){const{props:i,attrs:o,vnode:{patchFlag:l}}=e,u=(0,r.IU)(i),[p]=e.propsOptions;let c=!1;if(!(s||l>0)||16&l){let r;nt(e,t,i,o)&&(c=!0);for(const s in u)t&&((0,a.RI)(t,s)||(r=(0,a.rs)(s))!==s&&(0,a.RI)(t,r))||(p?!n||void 0===n[s]&&void 0===n[r]||(i[s]=rt(p,u,s,void 0,e,!0)):delete i[s]);if(o!==u)for(const e in o)t&&(0,a.RI)(t,e)||(delete o[e],c=!0)}else if(8&l){const n=e.vnode.dynamicProps;for(let r=0;r<n.length;r++){let s=n[r];if($(e.emitsOptions,s))continue;const l=t[s];if(p)if((0,a.RI)(o,s))l!==o[s]&&(o[s]=l,c=!0);else{const t=(0,a._A)(s);i[t]=rt(p,u,t,l,e,!1)}else l!==o[s]&&(o[s]=l,c=!0)}}c&&(0,r.X$)(e,"set","$attrs")}function nt(e,t,n,s){const[i,o]=e.propsOptions;let l,u=!1;if(t)for(let r in t){if((0,a.Gg)(r))continue;const p=t[r];let c;i&&(0,a.RI)(i,c=(0,a._A)(r))?o&&o.includes(c)?(l||(l={}))[c]=p:n[c]=p:$(e.emitsOptions,r)||r in s&&p===s[r]||(s[r]=p,u=!0)}if(o){const t=(0,r.IU)(n),s=l||a.kT;for(let r=0;r<o.length;r++){const l=o[r];n[l]=rt(i,t,l,s[l],e,!(0,a.RI)(s,l))}}return u}function rt(e,t,n,r,s,i){const o=e[n];if(null!=o){const e=(0,a.RI)(o,"default");if(e&&void 0===r){const e=o.default;if(o.type!==Function&&(0,a.mf)(e)){const{propsDefaults:a}=s;n in a?r=a[n]:(un(s),r=a[n]=e.call(null,t),pn())}else r=e}o[0]&&(i&&!e?r=!1:!o[1]||""!==r&&r!==(0,a.rs)(n)||(r=!0))}return r}function at(e,t,n=!1){const r=t.propsCache,s=r.get(e);if(s)return s;const i=e.props,o={},l=[];let u=!1;if(!(0,a.mf)(e)){const r=e=>{u=!0;const[n,r]=at(e,t,!0);(0,a.l7)(o,n),r&&l.push(...r)};!n&&t.mixins.length&&t.mixins.forEach(r),e.extends&&r(e.extends),e.mixins&&e.mixins.forEach(r)}if(!i&&!u)return(0,a.Kn)(e)&&r.set(e,a.Z6),a.Z6;if((0,a.kJ)(i))for(let c=0;c<i.length;c++){0;const e=(0,a._A)(i[c]);st(e)&&(o[e]=a.kT)}else if(i){0;for(const e in i){const t=(0,a._A)(e);if(st(t)){const n=i[e],r=o[t]=(0,a.kJ)(n)||(0,a.mf)(n)?{type:n}:Object.assign({},n);if(r){const e=lt(Boolean,r.type),n=lt(String,r.type);r[0]=e>-1,r[1]=n<0||e<n,(e>-1||(0,a.RI)(r,"default"))&&l.push(t)}}}}const p=[o,l];return(0,a.Kn)(e)&&r.set(e,p),p}function st(e){return"$"!==e[0]}function it(e){const t=e&&e.toString().match(/^\s*(function|class) (\w+)/);return t?t[2]:null===e?"null":""}function ot(e,t){return it(e)===it(t)}function lt(e,t){return(0,a.kJ)(t)?t.findIndex((t=>ot(t,e))):(0,a.mf)(t)&&ot(t,e)?0:-1}const ut=e=>"_"===e[0]||"$stable"===e,pt=e=>(0,a.kJ)(e)?e.map(Zt):[Zt(e)],ct=(e,t,n)=>{if(t._n)return t;const r=M(((...e)=>pt(t(...e))),n);return r._c=!1,r},dt=(e,t,n)=>{const r=e._ctx;for(const s in e){if(ut(s))continue;const n=e[s];if((0,a.mf)(n))t[s]=ct(s,n,r);else if(null!=n){0;const e=pt(n);t[s]=()=>e}}},ht=(e,t)=>{const n=pt(t);e.slots.default=()=>n},ft=(e,t)=>{if(32&e.vnode.shapeFlag){const n=t._;n?(e.slots=(0,r.IU)(t),(0,a.Nj)(t,"_",n)):dt(t,e.slots={})}else e.slots={},t&&ht(e,t);(0,a.Nj)(e.slots,Vt,1)},mt=(e,t,n)=>{const{vnode:r,slots:s}=e;let i=!0,o=a.kT;if(32&r.shapeFlag){const e=t._;e?n&&1===e?i=!1:((0,a.l7)(s,t),n||1!==e||delete s._):(i=!t.$stable,dt(t,s)),o=t}else t&&(ht(e,t),o={default:1});if(i)for(const a in s)ut(a)||a in o||delete s[a]};function gt(){return{app:null,config:{isNativeTag:a.NO,performance:!1,globalProperties:{},optionMergeStrategies:{},errorHandler:void 0,warnHandler:void 0,compilerOptions:{}},mixins:[],components:{},directives:{},provides:Object.create(null),optionsCache:new WeakMap,propsCache:new WeakMap,emitsCache:new WeakMap}}let yt=0;function bt(e,t){return function(n,r=null){(0,a.mf)(n)||(n=Object.assign({},n)),null==r||(0,a.Kn)(r)||(r=null);const s=gt(),i=new Set;let o=!1;const l=s.app={_uid:yt++,_component:n,_props:r,_container:null,_context:s,_instance:null,version:Cn,get config(){return s.config},set config(e){0},use(e,...t){return i.has(e)||(e&&(0,a.mf)(e.install)?(i.add(e),e.install(l,...t)):(0,a.mf)(e)&&(i.add(e),e(l,...t))),l},mixin(e){return s.mixins.includes(e)||s.mixins.push(e),l},component(e,t){return t?(s.components[e]=t,l):s.components[e]},directive(e,t){return t?(s.directives[e]=t,l):s.directives[e]},mount(a,i,u){if(!o){0;const p=qt(n,r);return p.appContext=s,i&&t?t(p,a):e(p,a,u),o=!0,l._container=a,a.__vue_app__=l,wn(p.component)||p.component.proxy}},unmount(){o&&(e(null,l._container),delete l._container.__vue_app__)},provide(e,t){return s.provides[e]=t,l}};return l}}function xt(e,t,n,i,o=!1){if((0,a.kJ)(e))return void e.forEach(((e,r)=>xt(e,t&&((0,a.kJ)(t)?t[r]:t),n,i,o)));if(ue(i)&&!o)return;const l=4&i.shapeFlag?wn(i.component)||i.component.proxy:i.el,u=o?null:l,{i:p,r:c}=e;const d=t&&t.r,h=p.refs===a.kT?p.refs={}:p.refs,f=p.setupState;if(null!=d&&d!==c&&((0,a.HD)(d)?(h[d]=null,(0,a.RI)(f,d)&&(f[d]=null)):(0,r.dq)(d)&&(d.value=null)),(0,a.mf)(c))s(c,p,12,[u,h]);else{const t=(0,a.HD)(c),s=(0,r.dq)(c);if(t||s){const r=()=>{if(e.f){const n=t?(0,a.RI)(f,c)?f[c]:h[c]:c.value;o?(0,a.kJ)(n)&&(0,a.Od)(n,l):(0,a.kJ)(n)?n.includes(l)||n.push(l):t?(h[c]=[l],(0,a.RI)(f,c)&&(f[c]=h[c])):(c.value=[l],e.k&&(h[e.k]=c.value))}else t?(h[c]=u,(0,a.RI)(f,c)&&(f[c]=u)):s&&(c.value=u,e.k&&(h[e.k]=u))};u?(r.id=-1,wt(r,n)):r()}else 0}}function vt(){}const wt=V;function kt(e){return It(e)}function It(e,t){vt();const n=(0,a.E9)();n.__VUE__=!0;const{insert:s,remove:i,patchProp:o,createElement:l,createText:u,createComment:p,setText:c,setElementText:d,parentNode:h,nextSibling:f,setScopeId:m=a.dG,insertStaticContent:g}=e,y=(e,t,n,r=null,a=null,s=null,i=!1,o=null,l=!!t.dynamicChildren)=>{if(e===t)return;e&&!Ut(e,t)&&(r=Z(e),q(e,a,s,!0),e=null),-2===t.patchFlag&&(l=!1,t.dynamicChildren=null);const{type:u,ref:p,shapeFlag:c}=t;switch(u){case Et:b(e,t,n,r);break;case At:x(e,t,n,r);break;case $t:null==e&&w(t,n,r,i);break;case Ct:D(e,t,n,r,a,s,i,o,l);break;default:1&c?_(e,t,n,r,a,s,i,o,l):6&c?M(e,t,n,r,a,s,i,o,l):(64&c||128&c)&&u.process(e,t,n,r,a,s,i,o,l,ee)}null!=p&&a&&xt(p,e&&e.ref,s,t||e,!t)},b=(e,t,n,r)=>{if(null==e)s(t.el=u(t.children),n,r);else{const n=t.el=e.el;t.children!==e.children&&c(n,t.children)}},x=(e,t,n,r)=>{null==e?s(t.el=p(t.children||""),n,r):t.el=e.el},w=(e,t,n,r)=>{[e.el,e.anchor]=g(e.children,t,n,r,e.el,e.anchor)},I=({el:e,anchor:t},n,r)=>{let a;while(e&&e!==t)a=f(e),s(e,n,r),e=a;s(t,n,r)},T=({el:e,anchor:t})=>{let n;while(e&&e!==t)n=f(e),i(e),e=n;i(t)},_=(e,t,n,r,a,s,i,o,l)=>{i=i||"svg"===t.type,null==e?C(t,n,r,a,s,i,o,l):$(e,t,a,s,i,o,l)},C=(e,t,n,r,i,u,p,c)=>{let h,f;const{type:m,props:g,shapeFlag:y,transition:b,dirs:x}=e;if(h=e.el=l(e.type,u,g&&g.is,g),8&y?d(h,e.children):16&y&&A(e.children,h,null,r,i,u&&"foreignObject"!==m,p,c),x&&Ae(e,null,r,"created"),E(h,e,e.scopeId,p,r),g){for(const t in g)"value"===t||(0,a.Gg)(t)||o(h,t,null,g[t],u,e.children,r,i,Y);"value"in g&&o(h,"value",null,g.value),(f=g.onVnodeBeforeMount)&&nn(f,r,e)}x&&Ae(e,null,r,"beforeMount");const v=(!i||i&&!i.pendingBranch)&&b&&!b.persisted;v&&b.beforeEnter(h),s(h,t,n),((f=g&&g.onVnodeMounted)||v||x)&&wt((()=>{f&&nn(f,r,e),v&&b.enter(h),x&&Ae(e,null,r,"mounted")}),i)},E=(e,t,n,r,a)=>{if(n&&m(e,n),r)for(let s=0;s<r.length;s++)m(e,r[s]);if(a){let n=a.subTree;if(t===n){const t=a.vnode;E(e,t,t.scopeId,t.slotScopeIds,a.parent)}}},A=(e,t,n,r,a,s,i,o,l=0)=>{for(let u=l;u<e.length;u++){const l=e[u]=o?Qt(e[u]):Zt(e[u]);y(null,l,t,n,r,a,s,i,o)}},$=(e,t,n,r,s,i,l)=>{const u=t.el=e.el;let{patchFlag:p,dynamicChildren:c,dirs:h}=t;p|=16&e.patchFlag;const f=e.props||a.kT,m=t.props||a.kT;let g;n&&St(n,!1),(g=m.onVnodeBeforeUpdate)&&nn(g,n,t,e),h&&Ae(t,e,n,"beforeUpdate"),n&&St(n,!0);const y=s&&"foreignObject"!==t.type;if(c?R(e.dynamicChildren,c,u,n,r,y,i):l||V(e,t,u,null,n,r,y,i,!1),p>0){if(16&p)F(u,t,f,m,n,r,s);else if(2&p&&f.class!==m.class&&o(u,"class",null,m.class,s),4&p&&o(u,"style",f.style,m.style,s),8&p){const a=t.dynamicProps;for(let t=0;t<a.length;t++){const i=a[t],l=f[i],p=m[i];p===l&&"value"!==i||o(u,i,l,p,s,e.children,n,r,Y)}}1&p&&e.children!==t.children&&d(u,t.children)}else l||null!=c||F(u,t,f,m,n,r,s);((g=m.onVnodeUpdated)||h)&&wt((()=>{g&&nn(g,n,t,e),h&&Ae(t,e,n,"updated")}),r)},R=(e,t,n,r,a,s,i)=>{for(let o=0;o<t.length;o++){const l=e[o],u=t[o],p=l.el&&(l.type===Ct||!Ut(l,u)||70&l.shapeFlag)?h(l.el):n;y(l,u,p,null,r,a,s,i,!0)}},F=(e,t,n,r,s,i,l)=>{if(n!==r){if(n!==a.kT)for(const u in n)(0,a.Gg)(u)||u in r||o(e,u,n[u],null,l,t.children,s,i,Y);for(const u in r){if((0,a.Gg)(u))continue;const p=r[u],c=n[u];p!==c&&"value"!==u&&o(e,u,c,p,l,t.children,s,i,Y)}"value"in r&&o(e,"value",n.value,r.value)}},D=(e,t,n,r,a,i,o,l,p)=>{const c=t.el=e?e.el:u(""),d=t.anchor=e?e.anchor:u("");let{patchFlag:h,dynamicChildren:f,slotScopeIds:m}=t;m&&(l=l?l.concat(m):m),null==e?(s(c,n,r),s(d,n,r),A(t.children,n,d,a,i,o,l,p)):h>0&&64&h&&f&&e.dynamicChildren?(R(e.dynamicChildren,f,n,a,i,o,l),(null!=t.key||a&&t===a.subTree)&&Nt(e,t,!0)):V(e,t,n,d,a,i,o,l,p)},M=(e,t,n,r,a,s,i,o,l)=>{t.slotScopeIds=o,null==e?512&t.shapeFlag?a.ctx.activate(t,n,r,i,l):P(t,n,r,a,s,i,l):L(e,t,l)},P=(e,t,n,r,a,s,i)=>{const o=e.component=sn(e,r,a);if(pe(e)&&(o.ctx.renderer=ee),mn(o),o.asyncDep){if(a&&a.registerDep(o,B),!e.el){const e=o.subTree=qt(At);x(null,e,t,n)}}else B(o,e,t,n,a,s,i)},L=(e,t,n)=>{const r=t.component=e.component;if(z(e,t,n)){if(r.asyncDep&&!r.asyncResolved)return void U(r,t,n);r.next=t,k(r.update),r.update()}else t.el=e.el,r.vnode=t},B=(e,t,n,s,i,o,l)=>{const u=()=>{if(e.isMounted){let t,{next:n,bu:r,u:s,parent:u,vnode:p}=e,c=n;0,St(e,!1),n?(n.el=p.el,U(e,n,l)):n=p,r&&(0,a.ir)(r),(t=n.props&&n.props.onVnodeBeforeUpdate)&&nn(t,u,n,p),St(e,!0);const d=O(e);0;const f=e.subTree;e.subTree=d,y(f,d,h(f.el),Z(f),e,i,o),n.el=d.el,null===c&&W(e,d.el),s&&wt(s,i),(t=n.props&&n.props.onVnodeUpdated)&&wt((()=>nn(t,u,n,p)),i)}else{let r;const{el:l,props:u}=t,{bm:p,m:c,parent:d}=e,h=ue(t);if(St(e,!1),p&&(0,a.ir)(p),!h&&(r=u&&u.onVnodeBeforeMount)&&nn(r,d,t),St(e,!0),l&&ne){const n=()=>{e.subTree=O(e),ne(l,e.subTree,e,i,null)};h?t.type.__asyncLoader().then((()=>!e.isUnmounted&&n())):n()}else{0;const r=e.subTree=O(e);0,y(null,r,n,s,e,i,o),t.el=r.el}if(c&&wt(c,i),!h&&(r=u&&u.onVnodeMounted)){const e=t;wt((()=>nn(r,d,e)),i)}(256&t.shapeFlag||d&&ue(d.vnode)&&256&d.vnode.shapeFlag)&&e.a&&wt(e.a,i),e.isMounted=!0,t=n=s=null}},p=e.effect=new r.qq(u,(()=>v(c)),e.scope),c=e.update=()=>p.run();c.id=e.uid,St(e,!0),c()},U=(e,t,n)=>{t.component=e;const a=e.vnode.props;e.vnode=t,e.next=null,tt(e,t.props,a,n),mt(e,t.children,n),(0,r.Jd)(),S(),(0,r.lk)()},V=(e,t,n,r,a,s,i,o,l=!1)=>{const u=e&&e.children,p=e?e.shapeFlag:0,c=t.children,{patchFlag:h,shapeFlag:f}=t;if(h>0){if(128&h)return void H(u,c,n,r,a,s,i,o,l);if(256&h)return void G(u,c,n,r,a,s,i,o,l)}8&f?(16&p&&Y(u,a,s),c!==u&&d(n,c)):16&p?16&f?H(u,c,n,r,a,s,i,o,l):Y(u,a,s,!0):(8&p&&d(n,""),16&f&&A(c,n,r,a,s,i,o,l))},G=(e,t,n,r,s,i,o,l,u)=>{e=e||a.Z6,t=t||a.Z6;const p=e.length,c=t.length,d=Math.min(p,c);let h;for(h=0;h<d;h++){const r=t[h]=u?Qt(t[h]):Zt(t[h]);y(e[h],r,n,null,s,i,o,l,u)}p>c?Y(e,s,i,!0,!1,d):A(t,n,r,s,i,o,l,u,d)},H=(e,t,n,r,s,i,o,l,u)=>{let p=0;const c=t.length;let d=e.length-1,h=c-1;while(p<=d&&p<=h){const r=e[p],a=t[p]=u?Qt(t[p]):Zt(t[p]);if(!Ut(r,a))break;y(r,a,n,null,s,i,o,l,u),p++}while(p<=d&&p<=h){const r=e[d],a=t[h]=u?Qt(t[h]):Zt(t[h]);if(!Ut(r,a))break;y(r,a,n,null,s,i,o,l,u),d--,h--}if(p>d){if(p<=h){const e=h+1,a=e<c?t[e].el:r;while(p<=h)y(null,t[p]=u?Qt(t[p]):Zt(t[p]),n,a,s,i,o,l,u),p++}}else if(p>h)while(p<=d)q(e[p],s,i,!0),p++;else{const f=p,m=p,g=new Map;for(p=m;p<=h;p++){const e=t[p]=u?Qt(t[p]):Zt(t[p]);null!=e.key&&g.set(e.key,p)}let b,x=0;const v=h-m+1;let w=!1,k=0;const I=new Array(v);for(p=0;p<v;p++)I[p]=0;for(p=f;p<=d;p++){const r=e[p];if(x>=v){q(r,s,i,!0);continue}let a;if(null!=r.key)a=g.get(r.key);else for(b=m;b<=h;b++)if(0===I[b-m]&&Ut(r,t[b])){a=b;break}void 0===a?q(r,s,i,!0):(I[a-m]=p+1,a>=k?k=a:w=!0,y(r,t[a],n,null,s,i,o,l,u),x++)}const S=w?Tt(I):a.Z6;for(b=S.length-1,p=v-1;p>=0;p--){const e=m+p,a=t[e],d=e+1<c?t[e+1].el:r;0===I[p]?y(null,a,n,d,s,i,o,l,u):w&&(b<0||p!==S[b]?j(a,n,d,2):b--)}}},j=(e,t,n,r,a=null)=>{const{el:i,type:o,transition:l,children:u,shapeFlag:p}=e;if(6&p)return void j(e.component.subTree,t,n,r);if(128&p)return void e.suspense.move(t,n,r);if(64&p)return void o.move(e,t,n,ee);if(o===Ct){s(i,t,n);for(let e=0;e<u.length;e++)j(u[e],t,n,r);return void s(e.anchor,t,n)}if(o===$t)return void I(e,t,n);const c=2!==r&&1&p&&l;if(c)if(0===r)l.beforeEnter(i),s(i,t,n),wt((()=>l.enter(i)),a);else{const{leave:e,delayLeave:r,afterLeave:a}=l,o=()=>s(i,t,n),u=()=>{e(i,(()=>{o(),a&&a()}))};r?r(i,o,u):u()}else s(i,t,n)},q=(e,t,n,r=!1,a=!1)=>{const{type:s,props:i,ref:o,children:l,dynamicChildren:u,shapeFlag:p,patchFlag:c,dirs:d}=e;if(null!=o&&xt(o,null,n,e,!0),256&p)return void t.ctx.deactivate(e);const h=1&p&&d,f=!ue(e);let m;if(f&&(m=i&&i.onVnodeBeforeUnmount)&&nn(m,t,e),6&p)J(e.component,n,r);else{if(128&p)return void e.suspense.unmount(n,r);h&&Ae(e,null,t,"beforeUnmount"),64&p?e.type.remove(e,t,n,a,ee,r):u&&(s!==Ct||c>0&&64&c)?Y(u,t,n,!1,!0):(s===Ct&&384&c||!a&&16&p)&&Y(l,t,n),r&&K(e)}(f&&(m=i&&i.onVnodeUnmounted)||h)&&wt((()=>{m&&nn(m,t,e),h&&Ae(e,null,t,"unmounted")}),n)},K=e=>{const{type:t,el:n,anchor:r,transition:a}=e;if(t===Ct)return void X(n,r);if(t===$t)return void T(e);const s=()=>{i(n),a&&!a.persisted&&a.afterLeave&&a.afterLeave()};if(1&e.shapeFlag&&a&&!a.persisted){const{leave:t,delayLeave:r}=a,i=()=>t(n,s);r?r(e.el,s,i):i()}else s()},X=(e,t)=>{let n;while(e!==t)n=f(e),i(e),e=n;i(t)},J=(e,t,n)=>{const{bum:r,scope:s,update:i,subTree:o,um:l}=e;r&&(0,a.ir)(r),s.stop(),i&&(i.active=!1,q(o,e,t,n)),l&&wt(l,t),wt((()=>{e.isUnmounted=!0}),t),t&&t.pendingBranch&&!t.isUnmounted&&e.asyncDep&&!e.asyncResolved&&e.suspenseId===t.pendingId&&(t.deps--,0===t.deps&&t.resolve())},Y=(e,t,n,r=!1,a=!1,s=0)=>{for(let i=s;i<e.length;i++)q(e[i],t,n,r,a)},Z=e=>6&e.shapeFlag?Z(e.component.subTree):128&e.shapeFlag?e.suspense.next():f(e.anchor||e.el),Q=(e,t,n)=>{null==e?t._vnode&&q(t._vnode,null,null,!0):y(t._vnode||null,e,t,null,null,null,n),S(),N(),t._vnode=e},ee={p:y,um:q,m:j,r:K,mt:P,mc:A,pc:V,pbc:R,n:Z,o:e};let te,ne;return t&&([te,ne]=t(ee)),{render:Q,hydrate:te,createApp:bt(Q,te)}}function St({effect:e,update:t},n){e.allowRecurse=t.allowRecurse=n}function Nt(e,t,n=!1){const r=e.children,s=t.children;if((0,a.kJ)(r)&&(0,a.kJ)(s))for(let a=0;a<r.length;a++){const e=r[a];let t=s[a];1&t.shapeFlag&&!t.dynamicChildren&&((t.patchFlag<=0||32===t.patchFlag)&&(t=s[a]=Qt(s[a]),t.el=e.el),n||Nt(e,t)),t.type===Et&&(t.el=e.el)}}function Tt(e){const t=e.slice(),n=[0];let r,a,s,i,o;const l=e.length;for(r=0;r<l;r++){const l=e[r];if(0!==l){if(a=n[n.length-1],e[a]<l){t[r]=a,n.push(r);continue}s=0,i=n.length-1;while(s<i)o=s+i>>1,e[n[o]]<l?s=o+1:i=o;l<e[n[s]]&&(s>0&&(t[r]=n[s-1]),n[s]=r)}}s=n.length,i=n[s-1];while(s-- >0)n[s]=i,i=t[i];return n}const _t=e=>e.__isTeleport;const Ct=Symbol(void 0),Et=Symbol(void 0),At=Symbol(void 0),$t=Symbol(void 0),Rt=[];let Ft=null;function Dt(e=!1){Rt.push(Ft=e?null:[])}function Mt(){Rt.pop(),Ft=Rt[Rt.length-1]||null}let Ot=1;function Pt(e){Ot+=e}function Lt(e){return e.dynamicChildren=Ot>0?Ft||a.Z6:null,Mt(),Ot>0&&Ft&&Ft.push(e),e}function zt(e,t,n,r,a,s){return Lt(jt(e,t,n,r,a,s,!0))}function Bt(e,t,n,r,a){return Lt(qt(e,t,n,r,a,!0))}function Wt(e){return!!e&&!0===e.__v_isVNode}function Ut(e,t){return e.type===t.type&&e.key===t.key}const Vt="__vInternal",Gt=({key:e})=>null!=e?e:null,Ht=({ref:e,ref_key:t,ref_for:n})=>null!=e?(0,a.HD)(e)||(0,r.dq)(e)||(0,a.mf)(e)?{i:R,r:e,k:t,f:!!n}:e:null;function jt(e,t=null,n=null,r=0,s=null,i=(e===Ct?0:1),o=!1,l=!1){const u={__v_isVNode:!0,__v_skip:!0,type:e,props:t,key:t&&Gt(t),ref:t&&Ht(t),scopeId:F,slotScopeIds:null,children:n,component:null,suspense:null,ssContent:null,ssFallback:null,dirs:null,transition:null,el:null,anchor:null,target:null,targetAnchor:null,staticCount:0,shapeFlag:i,patchFlag:r,dynamicProps:s,dynamicChildren:null,appContext:null,ctx:R};return l?(en(u,n),128&i&&e.normalize(u)):n&&(u.shapeFlag|=(0,a.HD)(n)?8:16),Ot>0&&!o&&Ft&&(u.patchFlag>0||6&i)&&32!==u.patchFlag&&Ft.push(u),u}const qt=Kt;function Kt(e,t=null,n=null,s=0,i=null,o=!1){if(e&&e!==Fe||(e=At),Wt(e)){const r=Jt(e,t,!0);return n&&en(r,n),Ot>0&&!o&&Ft&&(6&r.shapeFlag?Ft[Ft.indexOf(e)]=r:Ft.push(r)),r.patchFlag|=-2,r}if(In(e)&&(e=e.__vccOpts),t){t=Xt(t);let{class:e,style:n}=t;e&&!(0,a.HD)(e)&&(t.class=(0,a.C_)(e)),(0,a.Kn)(n)&&((0,r.X3)(n)&&!(0,a.kJ)(n)&&(n=(0,a.l7)({},n)),t.style=(0,a.j5)(n))}const l=(0,a.HD)(e)?1:U(e)?128:_t(e)?64:(0,a.Kn)(e)?4:(0,a.mf)(e)?2:0;return jt(e,t,n,s,i,l,o,!0)}function Xt(e){return e?(0,r.X3)(e)||Vt in e?(0,a.l7)({},e):e:null}function Jt(e,t,n=!1){const{props:r,ref:s,patchFlag:i,children:o}=e,l=t?tn(r||{},t):r,u={__v_isVNode:!0,__v_skip:!0,type:e.type,props:l,key:l&&Gt(l),ref:t&&t.ref?n&&s?(0,a.kJ)(s)?s.concat(Ht(t)):[s,Ht(t)]:Ht(t):s,scopeId:e.scopeId,slotScopeIds:e.slotScopeIds,children:o,target:e.target,targetAnchor:e.targetAnchor,staticCount:e.staticCount,shapeFlag:e.shapeFlag,patchFlag:t&&e.type!==Ct?-1===i?16:16|i:i,dynamicProps:e.dynamicProps,dynamicChildren:e.dynamicChildren,appContext:e.appContext,dirs:e.dirs,transition:e.transition,component:e.component,suspense:e.suspense,ssContent:e.ssContent&&Jt(e.ssContent),ssFallback:e.ssFallback&&Jt(e.ssFallback),el:e.el,anchor:e.anchor,ctx:e.ctx,ce:e.ce};return u}function Yt(e=" ",t=0){return qt(Et,null,e,t)}function Zt(e){return null==e||"boolean"===typeof e?qt(At):(0,a.kJ)(e)?qt(Ct,null,e.slice()):"object"===typeof e?Qt(e):qt(Et,null,String(e))}function Qt(e){return null===e.el&&-1!==e.patchFlag||e.memo?e:Jt(e)}function en(e,t){let n=0;const{shapeFlag:r}=e;if(null==t)t=null;else if((0,a.kJ)(t))n=16;else if("object"===typeof t){if(65&r){const n=t.default;return void(n&&(n._c&&(n._d=!1),en(e,n()),n._c&&(n._d=!0)))}{n=32;const r=t._;r||Vt in t?3===r&&R&&(1===R.slots._?t._=1:(t._=2,e.patchFlag|=1024)):t._ctx=R}}else(0,a.mf)(t)?(t={default:t,_ctx:R},n=32):(t=String(t),64&r?(n=16,t=[Yt(t)]):n=8);e.children=t,e.shapeFlag|=n}function tn(...e){const t={};for(let n=0;n<e.length;n++){const r=e[n];for(const e in r)if("class"===e)t.class!==r.class&&(t.class=(0,a.C_)([t.class,r.class]));else if("style"===e)t.style=(0,a.j5)([t.style,r.style]);else if((0,a.F7)(e)){const n=t[e],s=r[e];!s||n===s||(0,a.kJ)(n)&&n.includes(s)||(t[e]=n?[].concat(n,s):s)}else""!==e&&(t[e]=r[e])}return t}function nn(e,t,n,r=null){i(e,t,7,[n,r])}const rn=gt();let an=0;function sn(e,t,n){const s=e.type,i=(t?t.appContext:e.appContext)||rn,o={uid:an++,vnode:e,type:s,parent:t,appContext:i,root:null,next:null,subTree:null,effect:null,update:null,scope:new r.Bj(!0),render:null,proxy:null,exposed:null,exposeProxy:null,withProxy:null,provides:t?t.provides:Object.create(i.provides),accessCache:null,renderCache:[],components:null,directives:null,propsOptions:at(s,i),emitsOptions:A(s,i),emit:null,emitted:null,propsDefaults:a.kT,inheritAttrs:s.inheritAttrs,ctx:a.kT,data:a.kT,props:a.kT,attrs:a.kT,slots:a.kT,refs:a.kT,setupState:a.kT,setupContext:null,suspense:n,suspenseId:n?n.pendingId:0,asyncDep:null,asyncResolved:!1,isMounted:!1,isUnmounted:!1,isDeactivated:!1,bc:null,c:null,bm:null,m:null,bu:null,u:null,um:null,bum:null,da:null,a:null,rtg:null,rtc:null,ec:null,sp:null};return o.ctx={_:o},o.root=t?t.root:o,o.emit=E.bind(null,o),e.ce&&e.ce(o),o}let on=null;const ln=()=>on||R,un=e=>{on=e,e.scope.on()},pn=()=>{on&&on.scope.off(),on=null};function cn(e){return 4&e.vnode.shapeFlag}let dn,hn,fn=!1;function mn(e,t=!1){fn=t;const{props:n,children:r}=e.vnode,a=cn(e);et(e,n,a,t),ft(e,r);const s=a?gn(e,t):void 0;return fn=!1,s}function gn(e,t){const n=e.type;e.accessCache=Object.create(null),e.proxy=(0,r.Xl)(new Proxy(e.ctx,ze));const{setup:i}=n;if(i){const n=e.setupContext=i.length>1?vn(e):null;un(e),(0,r.Jd)();const l=s(i,e,0,[e.props,n]);if((0,r.lk)(),pn(),(0,a.tI)(l)){if(l.then(pn,pn),t)return l.then((n=>{yn(e,n,t)})).catch((t=>{o(t,e,0)}));e.asyncDep=l}else yn(e,l,t)}else bn(e,t)}function yn(e,t,n){(0,a.mf)(t)?e.type.__ssrInlineRender?e.ssrRender=t:e.render=t:(0,a.Kn)(t)&&(e.setupState=(0,r.WL)(t)),bn(e,n)}function bn(e,t,n){const s=e.type;if(!e.render){if(!t&&dn&&!s.render){const t=s.template||He(e).template;if(t){0;const{isCustomElement:n,compilerOptions:r}=e.appContext.config,{delimiters:i,compilerOptions:o}=s,l=(0,a.l7)((0,a.l7)({isCustomElement:n,delimiters:i},r),o);s.render=dn(t,l)}}e.render=s.render||a.dG,hn&&hn(e)}un(e),(0,r.Jd)(),We(e),(0,r.lk)(),pn()}function xn(e){return new Proxy(e.attrs,{get(t,n){return(0,r.j)(e,"get","$attrs"),t[n]}})}function vn(e){const t=t=>{e.exposed=t||{}};let n;return{get attrs(){return n||(n=xn(e))},slots:e.slots,emit:e.emit,expose:t}}function wn(e){if(e.exposed)return e.exposeProxy||(e.exposeProxy=new Proxy((0,r.WL)((0,r.Xl)(e.exposed)),{get(t,n){return n in t?t[n]:n in Pe?Pe[n](e):void 0},has(e,t){return t in e||t in Pe}}))}function kn(e,t=!0){return(0,a.mf)(e)?e.displayName||e.name:e.name||t&&e.__name}function In(e){return(0,a.mf)(e)&&"__vccOpts"in e}const Sn=(e,t)=>(0,r.Fl)(e,t,fn);function Nn(e,t,n){const r=arguments.length;return 2===r?(0,a.Kn)(t)&&!(0,a.kJ)(t)?Wt(t)?qt(e,null,[t]):qt(e,t):qt(e,null,t):(r>3?n=Array.prototype.slice.call(arguments,2):3===r&&Wt(n)&&(n=[n]),qt(e,t,n))}const Tn=Symbol(""),_n=()=>{{const e=H(Tn);return e}};const Cn="3.2.47"},9242:function(e,t,n){"use strict";n.d(t,{ri:function(){return le}});n(7658);var r=n(7139),a=n(3396),s=n(4870);const i="http://www.w3.org/2000/svg",o="undefined"!==typeof document?document:null,l=o&&o.createElement("template"),u={insert:(e,t,n)=>{t.insertBefore(e,n||null)},remove:e=>{const t=e.parentNode;t&&t.removeChild(e)},createElement:(e,t,n,r)=>{const a=t?o.createElementNS(i,e):o.createElement(e,n?{is:n}:void 0);return"select"===e&&r&&null!=r.multiple&&a.setAttribute("multiple",r.multiple),a},createText:e=>o.createTextNode(e),createComment:e=>o.createComment(e),setText:(e,t)=>{e.nodeValue=t},setElementText:(e,t)=>{e.textContent=t},parentNode:e=>e.parentNode,nextSibling:e=>e.nextSibling,querySelector:e=>o.querySelector(e),setScopeId(e,t){e.setAttribute(t,"")},insertStaticContent(e,t,n,r,a,s){const i=n?n.previousSibling:t.lastChild;if(a&&(a===s||a.nextSibling)){while(1)if(t.insertBefore(a.cloneNode(!0),n),a===s||!(a=a.nextSibling))break}else{l.innerHTML=r?`<svg>${e}</svg>`:e;const a=l.content;if(r){const e=a.firstChild;while(e.firstChild)a.appendChild(e.firstChild);a.removeChild(e)}t.insertBefore(a,n)}return[i?i.nextSibling:t.firstChild,n?n.previousSibling:t.lastChild]}};function p(e,t,n){const r=e._vtc;r&&(t=(t?[t,...r]:[...r]).join(" ")),null==t?e.removeAttribute("class"):n?e.setAttribute("class",t):e.className=t}function c(e,t,n){const a=e.style,s=(0,r.HD)(n);if(n&&!s){if(t&&!(0,r.HD)(t))for(const e in t)null==n[e]&&h(a,e,"");for(const e in n)h(a,e,n[e])}else{const r=a.display;s?t!==n&&(a.cssText=n):t&&e.removeAttribute("style"),"_vod"in e&&(a.display=r)}}const d=/\s*!important$/;function h(e,t,n){if((0,r.kJ)(n))n.forEach((n=>h(e,t,n)));else if(null==n&&(n=""),t.startsWith("--"))e.setProperty(t,n);else{const a=g(e,t);d.test(n)?e.setProperty((0,r.rs)(a),n.replace(d,""),"important"):e[a]=n}}const f=["Webkit","Moz","ms"],m={};function g(e,t){const n=m[t];if(n)return n;let a=(0,r._A)(t);if("filter"!==a&&a in e)return m[t]=a;a=(0,r.kC)(a);for(let r=0;r<f.length;r++){const n=f[r]+a;if(n in e)return m[t]=n}return t}const y="http://www.w3.org/1999/xlink";function b(e,t,n,a,s){if(a&&t.startsWith("xlink:"))null==n?e.removeAttributeNS(y,t.slice(6,t.length)):e.setAttributeNS(y,t,n);else{const a=(0,r.Pq)(t);null==n||a&&!(0,r.yA)(n)?e.removeAttribute(t):e.setAttribute(t,a?"":n)}}function x(e,t,n,a,s,i,o){if("innerHTML"===t||"textContent"===t)return a&&o(a,s,i),void(e[t]=null==n?"":n);if("value"===t&&"PROGRESS"!==e.tagName&&!e.tagName.includes("-")){e._value=n;const r=null==n?"":n;return e.value===r&&"OPTION"!==e.tagName||(e.value=r),void(null==n&&e.removeAttribute(t))}let l=!1;if(""===n||null==n){const a=typeof e[t];"boolean"===a?n=(0,r.yA)(n):null==n&&"string"===a?(n="",l=!0):"number"===a&&(n=0,l=!0)}try{e[t]=n}catch(u){0}l&&e.removeAttribute(t)}function v(e,t,n,r){e.addEventListener(t,n,r)}function w(e,t,n,r){e.removeEventListener(t,n,r)}function k(e,t,n,r,a=null){const s=e._vei||(e._vei={}),i=s[t];if(r&&i)i.value=r;else{const[n,o]=S(t);if(r){const i=s[t]=C(r,a);v(e,n,i,o)}else i&&(w(e,n,i,o),s[t]=void 0)}}const I=/(?:Once|Passive|Capture)$/;function S(e){let t;if(I.test(e)){let n;t={};while(n=e.match(I))e=e.slice(0,e.length-n[0].length),t[n[0].toLowerCase()]=!0}const n=":"===e[2]?e.slice(3):(0,r.rs)(e.slice(2));return[n,t]}let N=0;const T=Promise.resolve(),_=()=>N||(T.then((()=>N=0)),N=Date.now());function C(e,t){const n=e=>{if(e._vts){if(e._vts<=n.attached)return}else e._vts=Date.now();(0,a.$d)(E(e,n.value),t,5,[e])};return n.value=e,n.attached=_(),n}function E(e,t){if((0,r.kJ)(t)){const n=e.stopImmediatePropagation;return e.stopImmediatePropagation=()=>{n.call(e),e._stopped=!0},t.map((e=>t=>!t._stopped&&e&&e(t)))}return t}const A=/^on[a-z]/,$=(e,t,n,a,s=!1,i,o,l,u)=>{"class"===t?p(e,a,s):"style"===t?c(e,n,a):(0,r.F7)(t)?(0,r.tR)(t)||k(e,t,n,a,o):("."===t[0]?(t=t.slice(1),1):"^"===t[0]?(t=t.slice(1),0):R(e,t,a,s))?x(e,t,a,i,o,l,u):("true-value"===t?e._trueValue=a:"false-value"===t&&(e._falseValue=a),b(e,t,a,s))};function R(e,t,n,a){return a?"innerHTML"===t||"textContent"===t||!!(t in e&&A.test(t)&&(0,r.mf)(n)):"spellcheck"!==t&&"draggable"!==t&&"translate"!==t&&("form"!==t&&(("list"!==t||"INPUT"!==e.tagName)&&(("type"!==t||"TEXTAREA"!==e.tagName)&&((!A.test(t)||!(0,r.HD)(n))&&t in e))))}"undefined"!==typeof HTMLElement&&HTMLElement;const F="transition",D="animation",M=(e,{slots:t})=>(0,a.h)(a.P$,B(e),t);M.displayName="Transition";const O={name:String,type:String,css:{type:Boolean,default:!0},duration:[String,Number,Object],enterFromClass:String,enterActiveClass:String,enterToClass:String,appearFromClass:String,appearActiveClass:String,appearToClass:String,leaveFromClass:String,leaveActiveClass:String,leaveToClass:String},P=M.props=(0,r.l7)({},a.P$.props,O),L=(e,t=[])=>{(0,r.kJ)(e)?e.forEach((e=>e(...t))):e&&e(...t)},z=e=>!!e&&((0,r.kJ)(e)?e.some((e=>e.length>1)):e.length>1);function B(e){const t={};for(const r in e)r in O||(t[r]=e[r]);if(!1===e.css)return t;const{name:n="v",type:a,duration:s,enterFromClass:i=`${n}-enter-from`,enterActiveClass:o=`${n}-enter-active`,enterToClass:l=`${n}-enter-to`,appearFromClass:u=i,appearActiveClass:p=o,appearToClass:c=l,leaveFromClass:d=`${n}-leave-from`,leaveActiveClass:h=`${n}-leave-active`,leaveToClass:f=`${n}-leave-to`}=e,m=W(s),g=m&&m[0],y=m&&m[1],{onBeforeEnter:b,onEnter:x,onEnterCancelled:v,onLeave:w,onLeaveCancelled:k,onBeforeAppear:I=b,onAppear:S=x,onAppearCancelled:N=v}=t,T=(e,t,n)=>{G(e,t?c:l),G(e,t?p:o),n&&n()},_=(e,t)=>{e._isLeaving=!1,G(e,d),G(e,f),G(e,h),t&&t()},C=e=>(t,n)=>{const r=e?S:x,s=()=>T(t,e,n);L(r,[t,s]),H((()=>{G(t,e?u:i),V(t,e?c:l),z(r)||q(t,a,g,s)}))};return(0,r.l7)(t,{onBeforeEnter(e){L(b,[e]),V(e,i),V(e,o)},onBeforeAppear(e){L(I,[e]),V(e,u),V(e,p)},onEnter:C(!1),onAppear:C(!0),onLeave(e,t){e._isLeaving=!0;const n=()=>_(e,t);V(e,d),Y(),V(e,h),H((()=>{e._isLeaving&&(G(e,d),V(e,f),z(w)||q(e,a,y,n))})),L(w,[e,n])},onEnterCancelled(e){T(e,!1),L(v,[e])},onAppearCancelled(e){T(e,!0),L(N,[e])},onLeaveCancelled(e){_(e),L(k,[e])}})}function W(e){if(null==e)return null;if((0,r.Kn)(e))return[U(e.enter),U(e.leave)];{const t=U(e);return[t,t]}}function U(e){const t=(0,r.He)(e);return t}function V(e,t){t.split(/\s+/).forEach((t=>t&&e.classList.add(t))),(e._vtc||(e._vtc=new Set)).add(t)}function G(e,t){t.split(/\s+/).forEach((t=>t&&e.classList.remove(t)));const{_vtc:n}=e;n&&(n.delete(t),n.size||(e._vtc=void 0))}function H(e){requestAnimationFrame((()=>{requestAnimationFrame(e)}))}let j=0;function q(e,t,n,r){const a=e._endId=++j,s=()=>{a===e._endId&&r()};if(n)return setTimeout(s,n);const{type:i,timeout:o,propCount:l}=K(e,t);if(!i)return r();const u=i+"end";let p=0;const c=()=>{e.removeEventListener(u,d),s()},d=t=>{t.target===e&&++p>=l&&c()};setTimeout((()=>{p<l&&c()}),o+1),e.addEventListener(u,d)}function K(e,t){const n=window.getComputedStyle(e),r=e=>(n[e]||"").split(", "),a=r(`${F}Delay`),s=r(`${F}Duration`),i=X(a,s),o=r(`${D}Delay`),l=r(`${D}Duration`),u=X(o,l);let p=null,c=0,d=0;t===F?i>0&&(p=F,c=i,d=s.length):t===D?u>0&&(p=D,c=u,d=l.length):(c=Math.max(i,u),p=c>0?i>u?F:D:null,d=p?p===F?s.length:l.length:0);const h=p===F&&/\b(transform|all)(,|$)/.test(r(`${F}Property`).toString());return{type:p,timeout:c,propCount:d,hasTransform:h}}function X(e,t){while(e.length<t.length)e=e.concat(e);return Math.max(...t.map(((t,n)=>J(t)+J(e[n]))))}function J(e){return 1e3*Number(e.slice(0,-1).replace(",","."))}function Y(){return document.body.offsetHeight}const Z=new WeakMap,Q=new WeakMap,ee={name:"TransitionGroup",props:(0,r.l7)({},P,{tag:String,moveClass:String}),setup(e,{slots:t}){const n=(0,a.FN)(),r=(0,a.Y8)();let i,o;return(0,a.ic)((()=>{if(!i.length)return;const t=e.moveClass||`${e.name||"v"}-move`;if(!ae(i[0].el,n.vnode.el,t))return;i.forEach(te),i.forEach(ne);const r=i.filter(re);Y(),r.forEach((e=>{const n=e.el,r=n.style;V(n,t),r.transform=r.webkitTransform=r.transitionDuration="";const a=n._moveCb=e=>{e&&e.target!==n||e&&!/transform$/.test(e.propertyName)||(n.removeEventListener("transitionend",a),n._moveCb=null,G(n,t))};n.addEventListener("transitionend",a)}))})),()=>{const l=(0,s.IU)(e),u=B(l);let p=l.tag||a.HY;i=o,o=t.default?(0,a.Q6)(t.default()):[];for(let e=0;e<o.length;e++){const t=o[e];null!=t.key&&(0,a.nK)(t,(0,a.U2)(t,u,r,n))}if(i)for(let e=0;e<i.length;e++){const t=i[e];(0,a.nK)(t,(0,a.U2)(t,u,r,n)),Z.set(t,t.el.getBoundingClientRect())}return(0,a.Wm)(p,null,o)}}};ee.props;function te(e){const t=e.el;t._moveCb&&t._moveCb(),t._enterCb&&t._enterCb()}function ne(e){Q.set(e,e.el.getBoundingClientRect())}function re(e){const t=Z.get(e),n=Q.get(e),r=t.left-n.left,a=t.top-n.top;if(r||a){const t=e.el.style;return t.transform=t.webkitTransform=`translate(${r}px,${a}px)`,t.transitionDuration="0s",e}}function ae(e,t,n){const r=e.cloneNode();e._vtc&&e._vtc.forEach((e=>{e.split(/\s+/).forEach((e=>e&&r.classList.remove(e)))})),n.split(/\s+/).forEach((e=>e&&r.classList.add(e))),r.style.display="none";const a=1===t.nodeType?t:t.parentNode;a.appendChild(r);const{hasTransform:s}=K(r);return a.removeChild(r),s}const se=(0,r.l7)({patchProp:$},u);let ie;function oe(){return ie||(ie=(0,a.Us)(se))}const le=(...e)=>{const t=oe().createApp(...e);const{mount:n}=t;return t.mount=e=>{const a=ue(e);if(!a)return;const s=t._component;(0,r.mf)(s)||s.render||s.template||(s.template=a.innerHTML),a.innerHTML="";const i=n(a,!1,a instanceof SVGElement);return a instanceof Element&&(a.removeAttribute("v-cloak"),a.setAttribute("data-v-app","")),i},t};function ue(e){if((0,r.HD)(e)){const t=document.querySelector(e);return t}return e}},7139:function(e,t,n){"use strict";n.d(t,{C_:function(){return c},DM:function(){return F},E9:function(){return ie},F7:function(){return N},Gg:function(){return j},HD:function(){return P},He:function(){return ae},Kj:function(){return M},Kn:function(){return z},NO:function(){return I},Nj:function(){return ne},Od:function(){return C},PO:function(){return G},Pq:function(){return h},RI:function(){return A},S0:function(){return H},W7:function(){return V},WV:function(){return g},Z6:function(){return w},_A:function(){return X},_N:function(){return R},aU:function(){return ee},dG:function(){return k},e1:function(){return s},fY:function(){return r},h5:function(){return re},hR:function(){return Q},hq:function(){return y},ir:function(){return te},j5:function(){return i},kC:function(){return Z},kJ:function(){return $},kT:function(){return v},l7:function(){return _},mf:function(){return O},rs:function(){return Y},tI:function(){return B},tR:function(){return T},yA:function(){return f},yk:function(){return L},zw:function(){return b}});n(7658);function r(e,t){const n=Object.create(null),r=e.split(",");for(let a=0;a<r.length;a++)n[r[a]]=!0;return t?e=>!!n[e.toLowerCase()]:e=>!!n[e]}const a="Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt",s=r(a);function i(e){if($(e)){const t={};for(let n=0;n<e.length;n++){const r=e[n],a=P(r)?p(r):i(r);if(a)for(const e in a)t[e]=a[e]}return t}return P(e)||z(e)?e:void 0}const o=/;(?![^(]*\))/g,l=/:([^]+)/,u=/\/\*.*?\*\//gs;function p(e){const t={};return e.replace(u,"").split(o).forEach((e=>{if(e){const n=e.split(l);n.length>1&&(t[n[0].trim()]=n[1].trim())}})),t}function c(e){let t="";if(P(e))t=e;else if($(e))for(let n=0;n<e.length;n++){const r=c(e[n]);r&&(t+=r+" ")}else if(z(e))for(const n in e)e[n]&&(t+=n+" ");return t.trim()}const d="itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",h=r(d);function f(e){return!!e||""===e}function m(e,t){if(e.length!==t.length)return!1;let n=!0;for(let r=0;n&&r<e.length;r++)n=g(e[r],t[r]);return n}function g(e,t){if(e===t)return!0;let n=D(e),r=D(t);if(n||r)return!(!n||!r)&&e.getTime()===t.getTime();if(n=L(e),r=L(t),n||r)return e===t;if(n=$(e),r=$(t),n||r)return!(!n||!r)&&m(e,t);if(n=z(e),r=z(t),n||r){if(!n||!r)return!1;const a=Object.keys(e).length,s=Object.keys(t).length;if(a!==s)return!1;for(const n in e){const r=e.hasOwnProperty(n),a=t.hasOwnProperty(n);if(r&&!a||!r&&a||!g(e[n],t[n]))return!1}}return String(e)===String(t)}function y(e,t){return e.findIndex((e=>g(e,t)))}const b=e=>P(e)?e:null==e?"":$(e)||z(e)&&(e.toString===W||!O(e.toString))?JSON.stringify(e,x,2):String(e),x=(e,t)=>t&&t.__v_isRef?x(e,t.value):R(t)?{[`Map(${t.size})`]:[...t.entries()].reduce(((e,[t,n])=>(e[`${t} =>`]=n,e)),{})}:F(t)?{[`Set(${t.size})`]:[...t.values()]}:!z(t)||$(t)||G(t)?t:String(t),v={},w=[],k=()=>{},I=()=>!1,S=/^on[^a-z]/,N=e=>S.test(e),T=e=>e.startsWith("onUpdate:"),_=Object.assign,C=(e,t)=>{const n=e.indexOf(t);n>-1&&e.splice(n,1)},E=Object.prototype.hasOwnProperty,A=(e,t)=>E.call(e,t),$=Array.isArray,R=e=>"[object Map]"===U(e),F=e=>"[object Set]"===U(e),D=e=>"[object Date]"===U(e),M=e=>"[object RegExp]"===U(e),O=e=>"function"===typeof e,P=e=>"string"===typeof e,L=e=>"symbol"===typeof e,z=e=>null!==e&&"object"===typeof e,B=e=>z(e)&&O(e.then)&&O(e.catch),W=Object.prototype.toString,U=e=>W.call(e),V=e=>U(e).slice(8,-1),G=e=>"[object Object]"===U(e),H=e=>P(e)&&"NaN"!==e&&"-"!==e[0]&&""+parseInt(e,10)===e,j=r(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),q=e=>{const t=Object.create(null);return n=>{const r=t[n];return r||(t[n]=e(n))}},K=/-(\w)/g,X=q((e=>e.replace(K,((e,t)=>t?t.toUpperCase():"")))),J=/\B([A-Z])/g,Y=q((e=>e.replace(J,"-$1").toLowerCase())),Z=q((e=>e.charAt(0).toUpperCase()+e.slice(1))),Q=q((e=>e?`on${Z(e)}`:"")),ee=(e,t)=>!Object.is(e,t),te=(e,t)=>{for(let n=0;n<e.length;n++)e[n](t)},ne=(e,t,n)=>{Object.defineProperty(e,t,{configurable:!0,enumerable:!1,value:n})},re=e=>{const t=parseFloat(e);return isNaN(t)?e:t},ae=e=>{const t=P(e)?Number(e):NaN;return isNaN(t)?e:t};let se;const ie=()=>se||(se="undefined"!==typeof globalThis?globalThis:"undefined"!==typeof self?self:"undefined"!==typeof window?window:"undefined"!==typeof n.g?n.g:{})},5431:function(e,t,n){"use strict";n.d(t,{z:function(){return s}});var r,a=function(){return Boolean("localhost"===window.location.hostname||"[::1]"===window.location.hostname||window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/))};function s(e,t){void 0===t&&(t={});var n=t.registrationOptions;void 0===n&&(n={}),delete t.registrationOptions;var s=function(e){var n=[],r=arguments.length-1;while(r-- >0)n[r]=arguments[r+1];t&&t[e]&&t[e].apply(t,n)};"serviceWorker"in navigator&&r.then((function(){a()?(l(e,s,n),navigator.serviceWorker.ready.then((function(e){s("ready",e)})).catch((function(e){return i(s,e)}))):(o(e,s,n),navigator.serviceWorker.ready.then((function(e){s("ready",e)})).catch((function(e){return i(s,e)})))}))}function i(e,t){navigator.onLine||e("offline"),e("error",t)}function o(e,t,n){navigator.serviceWorker.register(e,n).then((function(e){t("registered",e),e.waiting?t("updated",e):e.onupdatefound=function(){t("updatefound",e);var n=e.installing;n.onstatechange=function(){"installed"===n.state&&(navigator.serviceWorker.controller?t("updated",e):t("cached",e))}}})).catch((function(e){return i(t,e)}))}function l(e,t,n){fetch(e).then((function(r){404===r.status?(t("error",new Error("Service worker not found at "+e)),u()):-1===r.headers.get("content-type").indexOf("javascript")?(t("error",new Error("Expected "+e+" to have javascript content-type, but received "+r.headers.get("content-type"))),u()):o(e,t,n)})).catch((function(e){return i(t,e)}))}function u(){"serviceWorker"in navigator&&navigator.serviceWorker.ready.then((function(e){e.unregister()})).catch((function(e){return i(emit,e)}))}"undefined"!==typeof window&&(r="undefined"!==typeof Promise?new Promise((function(e){return window.addEventListener("load",e)})):{then:function(e){return window.addEventListener("load",e)}})},89:function(e,t){"use strict";t.Z=(e,t)=>{const n=e.__vccOpts||e;for(const[r,a]of t)n[r]=a;return n}},4161:function(e,t,n){"use strict";n.d(t,{Z:function(){return Ot}});n(3767),n(8585),n(8696),n(7658);function r(e,t){return function(){return e.apply(t,arguments)}}const{toString:a}=Object.prototype,{getPrototypeOf:s}=Object,i=(e=>t=>{const n=a.call(t);return e[n]||(e[n]=n.slice(8,-1).toLowerCase())})(Object.create(null)),o=e=>(e=e.toLowerCase(),t=>i(t)===e),l=e=>t=>typeof t===e,{isArray:u}=Array,p=l("undefined");function c(e){return null!==e&&!p(e)&&null!==e.constructor&&!p(e.constructor)&&m(e.constructor.isBuffer)&&e.constructor.isBuffer(e)}const d=o("ArrayBuffer");function h(e){let t;return t="undefined"!==typeof ArrayBuffer&&ArrayBuffer.isView?ArrayBuffer.isView(e):e&&e.buffer&&d(e.buffer),t}const f=l("string"),m=l("function"),g=l("number"),y=e=>null!==e&&"object"===typeof e,b=e=>!0===e||!1===e,x=e=>{if("object"!==i(e))return!1;const t=s(e);return(null===t||t===Object.prototype||null===Object.getPrototypeOf(t))&&!(Symbol.toStringTag in e)&&!(Symbol.iterator in e)},v=o("Date"),w=o("File"),k=o("Blob"),I=o("FileList"),S=e=>y(e)&&m(e.pipe),N=e=>{const t="[object FormData]";return e&&("function"===typeof FormData&&e instanceof FormData||a.call(e)===t||m(e.toString)&&e.toString()===t)},T=o("URLSearchParams"),_=e=>e.trim?e.trim():e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,"");function C(e,t,{allOwnKeys:n=!1}={}){if(null===e||"undefined"===typeof e)return;let r,a;if("object"!==typeof e&&(e=[e]),u(e))for(r=0,a=e.length;r<a;r++)t.call(null,e[r],r,e);else{const a=n?Object.getOwnPropertyNames(e):Object.keys(e),s=a.length;let i;for(r=0;r<s;r++)i=a[r],t.call(null,e[i],i,e)}}function E(e,t){t=t.toLowerCase();const n=Object.keys(e);let r,a=n.length;while(a-- >0)if(r=n[a],t===r.toLowerCase())return r;return null}const A=(()=>"undefined"!==typeof globalThis?globalThis:"undefined"!==typeof self?self:"undefined"!==typeof window?window:global)(),$=e=>!p(e)&&e!==A;function R(){const{caseless:e}=$(this)&&this||{},t={},n=(n,r)=>{const a=e&&E(t,r)||r;x(t[a])&&x(n)?t[a]=R(t[a],n):x(n)?t[a]=R({},n):u(n)?t[a]=n.slice():t[a]=n};for(let r=0,a=arguments.length;r<a;r++)arguments[r]&&C(arguments[r],n);return t}const F=(e,t,n,{allOwnKeys:a}={})=>(C(t,((t,a)=>{n&&m(t)?e[a]=r(t,n):e[a]=t}),{allOwnKeys:a}),e),D=e=>(65279===e.charCodeAt(0)&&(e=e.slice(1)),e),M=(e,t,n,r)=>{e.prototype=Object.create(t.prototype,r),e.prototype.constructor=e,Object.defineProperty(e,"super",{value:t.prototype}),n&&Object.assign(e.prototype,n)},O=(e,t,n,r)=>{let a,i,o;const l={};if(t=t||{},null==e)return t;do{a=Object.getOwnPropertyNames(e),i=a.length;while(i-- >0)o=a[i],r&&!r(o,e,t)||l[o]||(t[o]=e[o],l[o]=!0);e=!1!==n&&s(e)}while(e&&(!n||n(e,t))&&e!==Object.prototype);return t},P=(e,t,n)=>{e=String(e),(void 0===n||n>e.length)&&(n=e.length),n-=t.length;const r=e.indexOf(t,n);return-1!==r&&r===n},L=e=>{if(!e)return null;if(u(e))return e;let t=e.length;if(!g(t))return null;const n=new Array(t);while(t-- >0)n[t]=e[t];return n},z=(e=>t=>e&&t instanceof e)("undefined"!==typeof Uint8Array&&s(Uint8Array)),B=(e,t)=>{const n=e&&e[Symbol.iterator],r=n.call(e);let a;while((a=r.next())&&!a.done){const n=a.value;t.call(e,n[0],n[1])}},W=(e,t)=>{let n;const r=[];while(null!==(n=e.exec(t)))r.push(n);return r},U=o("HTMLFormElement"),V=e=>e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,(function(e,t,n){return t.toUpperCase()+n})),G=(({hasOwnProperty:e})=>(t,n)=>e.call(t,n))(Object.prototype),H=o("RegExp"),j=(e,t)=>{const n=Object.getOwnPropertyDescriptors(e),r={};C(n,((n,a)=>{!1!==t(n,a,e)&&(r[a]=n)})),Object.defineProperties(e,r)},q=e=>{j(e,((t,n)=>{if(m(e)&&-1!==["arguments","caller","callee"].indexOf(n))return!1;const r=e[n];m(r)&&(t.enumerable=!1,"writable"in t?t.writable=!1:t.set||(t.set=()=>{throw Error("Can not rewrite read-only method '"+n+"'")}))}))},K=(e,t)=>{const n={},r=e=>{e.forEach((e=>{n[e]=!0}))};return u(e)?r(e):r(String(e).split(t)),n},X=()=>{},J=(e,t)=>(e=+e,Number.isFinite(e)?e:t),Y="abcdefghijklmnopqrstuvwxyz",Z="0123456789",Q={DIGIT:Z,ALPHA:Y,ALPHA_DIGIT:Y+Y.toUpperCase()+Z},ee=(e=16,t=Q.ALPHA_DIGIT)=>{let n="";const{length:r}=t;while(e--)n+=t[Math.random()*r|0];return n};function te(e){return!!(e&&m(e.append)&&"FormData"===e[Symbol.toStringTag]&&e[Symbol.iterator])}const ne=e=>{const t=new Array(10),n=(e,r)=>{if(y(e)){if(t.indexOf(e)>=0)return;if(!("toJSON"in e)){t[r]=e;const a=u(e)?[]:{};return C(e,((e,t)=>{const s=n(e,r+1);!p(s)&&(a[t]=s)})),t[r]=void 0,a}}return e};return n(e,0)};var re={isArray:u,isArrayBuffer:d,isBuffer:c,isFormData:N,isArrayBufferView:h,isString:f,isNumber:g,isBoolean:b,isObject:y,isPlainObject:x,isUndefined:p,isDate:v,isFile:w,isBlob:k,isRegExp:H,isFunction:m,isStream:S,isURLSearchParams:T,isTypedArray:z,isFileList:I,forEach:C,merge:R,extend:F,trim:_,stripBOM:D,inherits:M,toFlatObject:O,kindOf:i,kindOfTest:o,endsWith:P,toArray:L,forEachEntry:B,matchAll:W,isHTMLForm:U,hasOwnProperty:G,hasOwnProp:G,reduceDescriptors:j,freezeMethods:q,toObjectSet:K,toCamelCase:V,noop:X,toFiniteNumber:J,findKey:E,global:A,isContextDefined:$,ALPHABET:Q,generateString:ee,isSpecCompliantForm:te,toJSONObject:ne};n(541);function ae(e,t,n,r,a){Error.call(this),Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):this.stack=(new Error).stack,this.message=e,this.name="AxiosError",t&&(this.code=t),n&&(this.config=n),r&&(this.request=r),a&&(this.response=a)}re.inherits(ae,Error,{toJSON:function(){return{message:this.message,name:this.name,description:this.description,number:this.number,fileName:this.fileName,lineNumber:this.lineNumber,columnNumber:this.columnNumber,stack:this.stack,config:re.toJSONObject(this.config),code:this.code,status:this.response&&this.response.status?this.response.status:null}}});const se=ae.prototype,ie={};["ERR_BAD_OPTION_VALUE","ERR_BAD_OPTION","ECONNABORTED","ETIMEDOUT","ERR_NETWORK","ERR_FR_TOO_MANY_REDIRECTS","ERR_DEPRECATED","ERR_BAD_RESPONSE","ERR_BAD_REQUEST","ERR_CANCELED","ERR_NOT_SUPPORT","ERR_INVALID_URL"].forEach((e=>{ie[e]={value:e}})),Object.defineProperties(ae,ie),Object.defineProperty(se,"isAxiosError",{value:!0}),ae.from=(e,t,n,r,a,s)=>{const i=Object.create(se);return re.toFlatObject(e,i,(function(e){return e!==Error.prototype}),(e=>"isAxiosError"!==e)),ae.call(i,e.message,t,n,r,a),i.cause=e,i.name=e.name,s&&Object.assign(i,s),i};var oe=ae,le=null;function ue(e){return re.isPlainObject(e)||re.isArray(e)}function pe(e){return re.endsWith(e,"[]")?e.slice(0,-2):e}function ce(e,t,n){return e?e.concat(t).map((function(e,t){return e=pe(e),!n&&t?"["+e+"]":e})).join(n?".":""):t}function de(e){return re.isArray(e)&&!e.some(ue)}const he=re.toFlatObject(re,{},null,(function(e){return/^is[A-Z]/.test(e)}));function fe(e,t,n){if(!re.isObject(e))throw new TypeError("target must be an object");t=t||new(le||FormData),n=re.toFlatObject(n,{metaTokens:!0,dots:!1,indexes:!1},!1,(function(e,t){return!re.isUndefined(t[e])}));const r=n.metaTokens,a=n.visitor||p,s=n.dots,i=n.indexes,o=n.Blob||"undefined"!==typeof Blob&&Blob,l=o&&re.isSpecCompliantForm(t);if(!re.isFunction(a))throw new TypeError("visitor must be a function");function u(e){if(null===e)return"";if(re.isDate(e))return e.toISOString();if(!l&&re.isBlob(e))throw new oe("Blob is not supported. Use a Buffer instead.");return re.isArrayBuffer(e)||re.isTypedArray(e)?l&&"function"===typeof Blob?new Blob([e]):Buffer.from(e):e}function p(e,n,a){let o=e;if(e&&!a&&"object"===typeof e)if(re.endsWith(n,"{}"))n=r?n:n.slice(0,-2),e=JSON.stringify(e);else if(re.isArray(e)&&de(e)||(re.isFileList(e)||re.endsWith(n,"[]"))&&(o=re.toArray(e)))return n=pe(n),o.forEach((function(e,r){!re.isUndefined(e)&&null!==e&&t.append(!0===i?ce([n],r,s):null===i?n:n+"[]",u(e))})),!1;return!!ue(e)||(t.append(ce(a,n,s),u(e)),!1)}const c=[],d=Object.assign(he,{defaultVisitor:p,convertValue:u,isVisitable:ue});function h(e,n){if(!re.isUndefined(e)){if(-1!==c.indexOf(e))throw Error("Circular reference detected in "+n.join("."));c.push(e),re.forEach(e,(function(e,r){const s=!(re.isUndefined(e)||null===e)&&a.call(t,e,re.isString(r)?r.trim():r,n,d);!0===s&&h(e,n?n.concat(r):[r])})),c.pop()}}if(!re.isObject(e))throw new TypeError("data must be an object");return h(e),t}var me=fe;function ge(e){const t={"!":"%21","'":"%27","(":"%28",")":"%29","~":"%7E","%20":"+","%00":"\0"};return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g,(function(e){return t[e]}))}function ye(e,t){this._pairs=[],e&&me(e,this,t)}const be=ye.prototype;be.append=function(e,t){this._pairs.push([e,t])},be.toString=function(e){const t=e?function(t){return e.call(this,t,ge)}:ge;return this._pairs.map((function(e){return t(e[0])+"="+t(e[1])}),"").join("&")};var xe=ye;function ve(e){return encodeURIComponent(e).replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,"+").replace(/%5B/gi,"[").replace(/%5D/gi,"]")}function we(e,t,n){if(!t)return e;const r=n&&n.encode||ve,a=n&&n.serialize;let s;if(s=a?a(t,n):re.isURLSearchParams(t)?t.toString():new xe(t,n).toString(r),s){const t=e.indexOf("#");-1!==t&&(e=e.slice(0,t)),e+=(-1===e.indexOf("?")?"?":"&")+s}return e}class ke{constructor(){this.handlers=[]}use(e,t,n){return this.handlers.push({fulfilled:e,rejected:t,synchronous:!!n&&n.synchronous,runWhen:n?n.runWhen:null}),this.handlers.length-1}eject(e){this.handlers[e]&&(this.handlers[e]=null)}clear(){this.handlers&&(this.handlers=[])}forEach(e){re.forEach(this.handlers,(function(t){null!==t&&e(t)}))}}var Ie=ke,Se={silentJSONParsing:!0,forcedJSONParsing:!0,clarifyTimeoutError:!1},Ne="undefined"!==typeof URLSearchParams?URLSearchParams:xe,Te="undefined"!==typeof FormData?FormData:null,_e="undefined"!==typeof Blob?Blob:null;const Ce=(()=>{let e;return("undefined"===typeof navigator||"ReactNative"!==(e=navigator.product)&&"NativeScript"!==e&&"NS"!==e)&&("undefined"!==typeof window&&"undefined"!==typeof document)})(),Ee=(()=>"undefined"!==typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope&&"function"===typeof self.importScripts)();var Ae={isBrowser:!0,classes:{URLSearchParams:Ne,FormData:Te,Blob:_e},isStandardBrowserEnv:Ce,isStandardBrowserWebWorkerEnv:Ee,protocols:["http","https","file","blob","url","data"]};function $e(e,t){return me(e,new Ae.classes.URLSearchParams,Object.assign({visitor:function(e,t,n,r){return Ae.isNode&&re.isBuffer(e)?(this.append(t,e.toString("base64")),!1):r.defaultVisitor.apply(this,arguments)}},t))}function Re(e){return re.matchAll(/\w+|\[(\w*)]/g,e).map((e=>"[]"===e[0]?"":e[1]||e[0]))}function Fe(e){const t={},n=Object.keys(e);let r;const a=n.length;let s;for(r=0;r<a;r++)s=n[r],t[s]=e[s];return t}function De(e){function t(e,n,r,a){let s=e[a++];const i=Number.isFinite(+s),o=a>=e.length;if(s=!s&&re.isArray(r)?r.length:s,o)return re.hasOwnProp(r,s)?r[s]=[r[s],n]:r[s]=n,!i;r[s]&&re.isObject(r[s])||(r[s]=[]);const l=t(e,n,r[s],a);return l&&re.isArray(r[s])&&(r[s]=Fe(r[s])),!i}if(re.isFormData(e)&&re.isFunction(e.entries)){const n={};return re.forEachEntry(e,((e,r)=>{t(Re(e),r,n,0)})),n}return null}var Me=De;const Oe={"Content-Type":void 0};function Pe(e,t,n){if(re.isString(e))try{return(t||JSON.parse)(e),re.trim(e)}catch(r){if("SyntaxError"!==r.name)throw r}return(n||JSON.stringify)(e)}const Le={transitional:Se,adapter:["xhr","http"],transformRequest:[function(e,t){const n=t.getContentType()||"",r=n.indexOf("application/json")>-1,a=re.isObject(e);a&&re.isHTMLForm(e)&&(e=new FormData(e));const s=re.isFormData(e);if(s)return r&&r?JSON.stringify(Me(e)):e;if(re.isArrayBuffer(e)||re.isBuffer(e)||re.isStream(e)||re.isFile(e)||re.isBlob(e))return e;if(re.isArrayBufferView(e))return e.buffer;if(re.isURLSearchParams(e))return t.setContentType("application/x-www-form-urlencoded;charset=utf-8",!1),e.toString();let i;if(a){if(n.indexOf("application/x-www-form-urlencoded")>-1)return $e(e,this.formSerializer).toString();if((i=re.isFileList(e))||n.indexOf("multipart/form-data")>-1){const t=this.env&&this.env.FormData;return me(i?{"files[]":e}:e,t&&new t,this.formSerializer)}}return a||r?(t.setContentType("application/json",!1),Pe(e)):e}],transformResponse:[function(e){const t=this.transitional||Le.transitional,n=t&&t.forcedJSONParsing,r="json"===this.responseType;if(e&&re.isString(e)&&(n&&!this.responseType||r)){const n=t&&t.silentJSONParsing,s=!n&&r;try{return JSON.parse(e)}catch(a){if(s){if("SyntaxError"===a.name)throw oe.from(a,oe.ERR_BAD_RESPONSE,this,null,this.response);throw a}}}return e}],timeout:0,xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",maxContentLength:-1,maxBodyLength:-1,env:{FormData:Ae.classes.FormData,Blob:Ae.classes.Blob},validateStatus:function(e){return e>=200&&e<300},headers:{common:{Accept:"application/json, text/plain, */*"}}};re.forEach(["delete","get","head"],(function(e){Le.headers[e]={}})),re.forEach(["post","put","patch"],(function(e){Le.headers[e]=re.merge(Oe)}));var ze=Le;const Be=re.toObjectSet(["age","authorization","content-length","content-type","etag","expires","from","host","if-modified-since","if-unmodified-since","last-modified","location","max-forwards","proxy-authorization","referer","retry-after","user-agent"]);var We=e=>{const t={};let n,r,a;return e&&e.split("\n").forEach((function(e){a=e.indexOf(":"),n=e.substring(0,a).trim().toLowerCase(),r=e.substring(a+1).trim(),!n||t[n]&&Be[n]||("set-cookie"===n?t[n]?t[n].push(r):t[n]=[r]:t[n]=t[n]?t[n]+", "+r:r)})),t};const Ue=Symbol("internals");function Ve(e){return e&&String(e).trim().toLowerCase()}function Ge(e){return!1===e||null==e?e:re.isArray(e)?e.map(Ge):String(e)}function He(e){const t=Object.create(null),n=/([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;let r;while(r=n.exec(e))t[r[1]]=r[2];return t}function je(e){return/^[-_a-zA-Z]+$/.test(e.trim())}function qe(e,t,n,r,a){return re.isFunction(r)?r.call(this,t,n):(a&&(t=n),re.isString(t)?re.isString(r)?-1!==t.indexOf(r):re.isRegExp(r)?r.test(t):void 0:void 0)}function Ke(e){return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g,((e,t,n)=>t.toUpperCase()+n))}function Xe(e,t){const n=re.toCamelCase(" "+t);["get","set","has"].forEach((r=>{Object.defineProperty(e,r+n,{value:function(e,n,a){return this[r].call(this,t,e,n,a)},configurable:!0})}))}class Je{constructor(e){e&&this.set(e)}set(e,t,n){const r=this;function a(e,t,n){const a=Ve(t);if(!a)throw new Error("header name must be a non-empty string");const s=re.findKey(r,a);(!s||void 0===r[s]||!0===n||void 0===n&&!1!==r[s])&&(r[s||t]=Ge(e))}const s=(e,t)=>re.forEach(e,((e,n)=>a(e,n,t)));return re.isPlainObject(e)||e instanceof this.constructor?s(e,t):re.isString(e)&&(e=e.trim())&&!je(e)?s(We(e),t):null!=e&&a(t,e,n),this}get(e,t){if(e=Ve(e),e){const n=re.findKey(this,e);if(n){const e=this[n];if(!t)return e;if(!0===t)return He(e);if(re.isFunction(t))return t.call(this,e,n);if(re.isRegExp(t))return t.exec(e);throw new TypeError("parser must be boolean|regexp|function")}}}has(e,t){if(e=Ve(e),e){const n=re.findKey(this,e);return!(!n||void 0===this[n]||t&&!qe(this,this[n],n,t))}return!1}delete(e,t){const n=this;let r=!1;function a(e){if(e=Ve(e),e){const a=re.findKey(n,e);!a||t&&!qe(n,n[a],a,t)||(delete n[a],r=!0)}}return re.isArray(e)?e.forEach(a):a(e),r}clear(e){const t=Object.keys(this);let n=t.length,r=!1;while(n--){const a=t[n];e&&!qe(this,this[a],a,e,!0)||(delete this[a],r=!0)}return r}normalize(e){const t=this,n={};return re.forEach(this,((r,a)=>{const s=re.findKey(n,a);if(s)return t[s]=Ge(r),void delete t[a];const i=e?Ke(a):String(a).trim();i!==a&&delete t[a],t[i]=Ge(r),n[i]=!0})),this}concat(...e){return this.constructor.concat(this,...e)}toJSON(e){const t=Object.create(null);return re.forEach(this,((n,r)=>{null!=n&&!1!==n&&(t[r]=e&&re.isArray(n)?n.join(", "):n)})),t}[Symbol.iterator](){return Object.entries(this.toJSON())[Symbol.iterator]()}toString(){return Object.entries(this.toJSON()).map((([e,t])=>e+": "+t)).join("\n")}get[Symbol.toStringTag](){return"AxiosHeaders"}static from(e){return e instanceof this?e:new this(e)}static concat(e,...t){const n=new this(e);return t.forEach((e=>n.set(e))),n}static accessor(e){const t=this[Ue]=this[Ue]={accessors:{}},n=t.accessors,r=this.prototype;function a(e){const t=Ve(e);n[t]||(Xe(r,e),n[t]=!0)}return re.isArray(e)?e.forEach(a):a(e),this}}Je.accessor(["Content-Type","Content-Length","Accept","Accept-Encoding","User-Agent","Authorization"]),re.freezeMethods(Je.prototype),re.freezeMethods(Je);var Ye=Je;function Ze(e,t){const n=this||ze,r=t||n,a=Ye.from(r.headers);let s=r.data;return re.forEach(e,(function(e){s=e.call(n,s,a.normalize(),t?t.status:void 0)})),a.normalize(),s}function Qe(e){return!(!e||!e.__CANCEL__)}function et(e,t,n){oe.call(this,null==e?"canceled":e,oe.ERR_CANCELED,t,n),this.name="CanceledError"}re.inherits(et,oe,{__CANCEL__:!0});var tt=et;n(2801);function nt(e,t,n){const r=n.config.validateStatus;n.status&&r&&!r(n.status)?t(new oe("Request failed with status code "+n.status,[oe.ERR_BAD_REQUEST,oe.ERR_BAD_RESPONSE][Math.floor(n.status/100)-4],n.config,n.request,n)):e(n)}var rt=Ae.isStandardBrowserEnv?function(){return{write:function(e,t,n,r,a,s){const i=[];i.push(e+"="+encodeURIComponent(t)),re.isNumber(n)&&i.push("expires="+new Date(n).toGMTString()),re.isString(r)&&i.push("path="+r),re.isString(a)&&i.push("domain="+a),!0===s&&i.push("secure"),document.cookie=i.join("; ")},read:function(e){const t=document.cookie.match(new RegExp("(^|;\\s*)("+e+")=([^;]*)"));return t?decodeURIComponent(t[3]):null},remove:function(e){this.write(e,"",Date.now()-864e5)}}}():function(){return{write:function(){},read:function(){return null},remove:function(){}}}();function at(e){return/^([a-z][a-z\d+\-.]*:)?\/\//i.test(e)}function st(e,t){return t?e.replace(/\/+$/,"")+"/"+t.replace(/^\/+/,""):e}function it(e,t){return e&&!at(t)?st(e,t):t}var ot=Ae.isStandardBrowserEnv?function(){const e=/(msie|trident)/i.test(navigator.userAgent),t=document.createElement("a");let n;function r(n){let r=n;return e&&(t.setAttribute("href",r),r=t.href),t.setAttribute("href",r),{href:t.href,protocol:t.protocol?t.protocol.replace(/:$/,""):"",host:t.host,search:t.search?t.search.replace(/^\?/,""):"",hash:t.hash?t.hash.replace(/^#/,""):"",hostname:t.hostname,port:t.port,pathname:"/"===t.pathname.charAt(0)?t.pathname:"/"+t.pathname}}return n=r(window.location.href),function(e){const t=re.isString(e)?r(e):e;return t.protocol===n.protocol&&t.host===n.host}}():function(){return function(){return!0}}();function lt(e){const t=/^([-+\w]{1,25})(:?\/\/|:)/.exec(e);return t&&t[1]||""}function ut(e,t){e=e||10;const n=new Array(e),r=new Array(e);let a,s=0,i=0;return t=void 0!==t?t:1e3,function(o){const l=Date.now(),u=r[i];a||(a=l),n[s]=o,r[s]=l;let p=i,c=0;while(p!==s)c+=n[p++],p%=e;if(s=(s+1)%e,s===i&&(i=(i+1)%e),l-a<t)return;const d=u&&l-u;return d?Math.round(1e3*c/d):void 0}}var pt=ut;function ct(e,t){let n=0;const r=pt(50,250);return a=>{const s=a.loaded,i=a.lengthComputable?a.total:void 0,o=s-n,l=r(o),u=s<=i;n=s;const p={loaded:s,total:i,progress:i?s/i:void 0,bytes:o,rate:l||void 0,estimated:l&&i&&u?(i-s)/l:void 0,event:a};p[t?"download":"upload"]=!0,e(p)}}const dt="undefined"!==typeof XMLHttpRequest;var ht=dt&&function(e){return new Promise((function(t,n){let r=e.data;const a=Ye.from(e.headers).normalize(),s=e.responseType;let i;function o(){e.cancelToken&&e.cancelToken.unsubscribe(i),e.signal&&e.signal.removeEventListener("abort",i)}re.isFormData(r)&&(Ae.isStandardBrowserEnv||Ae.isStandardBrowserWebWorkerEnv)&&a.setContentType(!1);let l=new XMLHttpRequest;if(e.auth){const t=e.auth.username||"",n=e.auth.password?unescape(encodeURIComponent(e.auth.password)):"";a.set("Authorization","Basic "+btoa(t+":"+n))}const u=it(e.baseURL,e.url);function p(){if(!l)return;const r=Ye.from("getAllResponseHeaders"in l&&l.getAllResponseHeaders()),a=s&&"text"!==s&&"json"!==s?l.response:l.responseText,i={data:a,status:l.status,statusText:l.statusText,headers:r,config:e,request:l};nt((function(e){t(e),o()}),(function(e){n(e),o()}),i),l=null}if(l.open(e.method.toUpperCase(),we(u,e.params,e.paramsSerializer),!0),l.timeout=e.timeout,"onloadend"in l?l.onloadend=p:l.onreadystatechange=function(){l&&4===l.readyState&&(0!==l.status||l.responseURL&&0===l.responseURL.indexOf("file:"))&&setTimeout(p)},l.onabort=function(){l&&(n(new oe("Request aborted",oe.ECONNABORTED,e,l)),l=null)},l.onerror=function(){n(new oe("Network Error",oe.ERR_NETWORK,e,l)),l=null},l.ontimeout=function(){let t=e.timeout?"timeout of "+e.timeout+"ms exceeded":"timeout exceeded";const r=e.transitional||Se;e.timeoutErrorMessage&&(t=e.timeoutErrorMessage),n(new oe(t,r.clarifyTimeoutError?oe.ETIMEDOUT:oe.ECONNABORTED,e,l)),l=null},Ae.isStandardBrowserEnv){const t=(e.withCredentials||ot(u))&&e.xsrfCookieName&&rt.read(e.xsrfCookieName);t&&a.set(e.xsrfHeaderName,t)}void 0===r&&a.setContentType(null),"setRequestHeader"in l&&re.forEach(a.toJSON(),(function(e,t){l.setRequestHeader(t,e)})),re.isUndefined(e.withCredentials)||(l.withCredentials=!!e.withCredentials),s&&"json"!==s&&(l.responseType=e.responseType),"function"===typeof e.onDownloadProgress&&l.addEventListener("progress",ct(e.onDownloadProgress,!0)),"function"===typeof e.onUploadProgress&&l.upload&&l.upload.addEventListener("progress",ct(e.onUploadProgress)),(e.cancelToken||e.signal)&&(i=t=>{l&&(n(!t||t.type?new tt(null,e,l):t),l.abort(),l=null)},e.cancelToken&&e.cancelToken.subscribe(i),e.signal&&(e.signal.aborted?i():e.signal.addEventListener("abort",i)));const c=lt(u);c&&-1===Ae.protocols.indexOf(c)?n(new oe("Unsupported protocol "+c+":",oe.ERR_BAD_REQUEST,e)):l.send(r||null)}))};const ft={http:le,xhr:ht};re.forEach(ft,((e,t)=>{if(e){try{Object.defineProperty(e,"name",{value:t})}catch(n){}Object.defineProperty(e,"adapterName",{value:t})}}));var mt={getAdapter:e=>{e=re.isArray(e)?e:[e];const{length:t}=e;let n,r;for(let a=0;a<t;a++)if(n=e[a],r=re.isString(n)?ft[n.toLowerCase()]:n)break;if(!r){if(!1===r)throw new oe(`Adapter ${n} is not supported by the environment`,"ERR_NOT_SUPPORT");throw new Error(re.hasOwnProp(ft,n)?`Adapter '${n}' is not available in the build`:`Unknown adapter '${n}'`)}if(!re.isFunction(r))throw new TypeError("adapter is not a function");return r},adapters:ft};function gt(e){if(e.cancelToken&&e.cancelToken.throwIfRequested(),e.signal&&e.signal.aborted)throw new tt(null,e)}function yt(e){gt(e),e.headers=Ye.from(e.headers),e.data=Ze.call(e,e.transformRequest),-1!==["post","put","patch"].indexOf(e.method)&&e.headers.setContentType("application/x-www-form-urlencoded",!1);const t=mt.getAdapter(e.adapter||ze.adapter);return t(e).then((function(t){return gt(e),t.data=Ze.call(e,e.transformResponse,t),t.headers=Ye.from(t.headers),t}),(function(t){return Qe(t)||(gt(e),t&&t.response&&(t.response.data=Ze.call(e,e.transformResponse,t.response),t.response.headers=Ye.from(t.response.headers))),Promise.reject(t)}))}const bt=e=>e instanceof Ye?e.toJSON():e;function xt(e,t){t=t||{};const n={};function r(e,t,n){return re.isPlainObject(e)&&re.isPlainObject(t)?re.merge.call({caseless:n},e,t):re.isPlainObject(t)?re.merge({},t):re.isArray(t)?t.slice():t}function a(e,t,n){return re.isUndefined(t)?re.isUndefined(e)?void 0:r(void 0,e,n):r(e,t,n)}function s(e,t){if(!re.isUndefined(t))return r(void 0,t)}function i(e,t){return re.isUndefined(t)?re.isUndefined(e)?void 0:r(void 0,e):r(void 0,t)}function o(n,a,s){return s in t?r(n,a):s in e?r(void 0,n):void 0}const l={url:s,method:s,data:s,baseURL:i,transformRequest:i,transformResponse:i,paramsSerializer:i,timeout:i,timeoutMessage:i,withCredentials:i,adapter:i,responseType:i,xsrfCookieName:i,xsrfHeaderName:i,onUploadProgress:i,onDownloadProgress:i,decompress:i,maxContentLength:i,maxBodyLength:i,beforeRedirect:i,transport:i,httpAgent:i,httpsAgent:i,cancelToken:i,socketPath:i,responseEncoding:i,validateStatus:o,headers:(e,t)=>a(bt(e),bt(t),!0)};return re.forEach(Object.keys(e).concat(Object.keys(t)),(function(r){const s=l[r]||a,i=s(e[r],t[r],r);re.isUndefined(i)&&s!==o||(n[r]=i)})),n}const vt="1.3.4",wt={};["object","boolean","number","function","string","symbol"].forEach(((e,t)=>{wt[e]=function(n){return typeof n===e||"a"+(t<1?"n ":" ")+e}}));const kt={};function It(e,t,n){if("object"!==typeof e)throw new oe("options must be an object",oe.ERR_BAD_OPTION_VALUE);const r=Object.keys(e);let a=r.length;while(a-- >0){const s=r[a],i=t[s];if(i){const t=e[s],n=void 0===t||i(t,s,e);if(!0!==n)throw new oe("option "+s+" must be "+n,oe.ERR_BAD_OPTION_VALUE)}else if(!0!==n)throw new oe("Unknown option "+s,oe.ERR_BAD_OPTION)}}wt.transitional=function(e,t,n){function r(e,t){return"[Axios v"+vt+"] Transitional option '"+e+"'"+t+(n?". "+n:"")}return(n,a,s)=>{if(!1===e)throw new oe(r(a," has been removed"+(t?" in "+t:"")),oe.ERR_DEPRECATED);return t&&!kt[a]&&(kt[a]=!0,console.warn(r(a," has been deprecated since v"+t+" and will be removed in the near future"))),!e||e(n,a,s)}};var St={assertOptions:It,validators:wt};const Nt=St.validators;class Tt{constructor(e){this.defaults=e,this.interceptors={request:new Ie,response:new Ie}}request(e,t){"string"===typeof e?(t=t||{},t.url=e):t=e||{},t=xt(this.defaults,t);const{transitional:n,paramsSerializer:r,headers:a}=t;let s;void 0!==n&&St.assertOptions(n,{silentJSONParsing:Nt.transitional(Nt.boolean),forcedJSONParsing:Nt.transitional(Nt.boolean),clarifyTimeoutError:Nt.transitional(Nt.boolean)},!1),void 0!==r&&St.assertOptions(r,{encode:Nt.function,serialize:Nt.function},!0),t.method=(t.method||this.defaults.method||"get").toLowerCase(),s=a&&re.merge(a.common,a[t.method]),s&&re.forEach(["delete","get","head","post","put","patch","common"],(e=>{delete a[e]})),t.headers=Ye.concat(s,a);const i=[];let o=!0;this.interceptors.request.forEach((function(e){"function"===typeof e.runWhen&&!1===e.runWhen(t)||(o=o&&e.synchronous,i.unshift(e.fulfilled,e.rejected))}));const l=[];let u;this.interceptors.response.forEach((function(e){l.push(e.fulfilled,e.rejected)}));let p,c=0;if(!o){const e=[yt.bind(this),void 0];e.unshift.apply(e,i),e.push.apply(e,l),p=e.length,u=Promise.resolve(t);while(c<p)u=u.then(e[c++],e[c++]);return u}p=i.length;let d=t;c=0;while(c<p){const e=i[c++],t=i[c++];try{d=e(d)}catch(h){t.call(this,h);break}}try{u=yt.call(this,d)}catch(h){return Promise.reject(h)}c=0,p=l.length;while(c<p)u=u.then(l[c++],l[c++]);return u}getUri(e){e=xt(this.defaults,e);const t=it(e.baseURL,e.url);return we(t,e.params,e.paramsSerializer)}}re.forEach(["delete","get","head","options"],(function(e){Tt.prototype[e]=function(t,n){return this.request(xt(n||{},{method:e,url:t,data:(n||{}).data}))}})),re.forEach(["post","put","patch"],(function(e){function t(t){return function(n,r,a){return this.request(xt(a||{},{method:e,headers:t?{"Content-Type":"multipart/form-data"}:{},url:n,data:r}))}}Tt.prototype[e]=t(),Tt.prototype[e+"Form"]=t(!0)}));var _t=Tt;class Ct{constructor(e){if("function"!==typeof e)throw new TypeError("executor must be a function.");let t;this.promise=new Promise((function(e){t=e}));const n=this;this.promise.then((e=>{if(!n._listeners)return;let t=n._listeners.length;while(t-- >0)n._listeners[t](e);n._listeners=null})),this.promise.then=e=>{let t;const r=new Promise((e=>{n.subscribe(e),t=e})).then(e);return r.cancel=function(){n.unsubscribe(t)},r},e((function(e,r,a){n.reason||(n.reason=new tt(e,r,a),t(n.reason))}))}throwIfRequested(){if(this.reason)throw this.reason}subscribe(e){this.reason?e(this.reason):this._listeners?this._listeners.push(e):this._listeners=[e]}unsubscribe(e){if(!this._listeners)return;const t=this._listeners.indexOf(e);-1!==t&&this._listeners.splice(t,1)}static source(){let e;const t=new Ct((function(t){e=t}));return{token:t,cancel:e}}}var Et=Ct;function At(e){return function(t){return e.apply(null,t)}}function $t(e){return re.isObject(e)&&!0===e.isAxiosError}const Rt={Continue:100,SwitchingProtocols:101,Processing:102,EarlyHints:103,Ok:200,Created:201,Accepted:202,NonAuthoritativeInformation:203,NoContent:204,ResetContent:205,PartialContent:206,MultiStatus:207,AlreadyReported:208,ImUsed:226,MultipleChoices:300,MovedPermanently:301,Found:302,SeeOther:303,NotModified:304,UseProxy:305,Unused:306,TemporaryRedirect:307,PermanentRedirect:308,BadRequest:400,Unauthorized:401,PaymentRequired:402,Forbidden:403,NotFound:404,MethodNotAllowed:405,NotAcceptable:406,ProxyAuthenticationRequired:407,RequestTimeout:408,Conflict:409,Gone:410,LengthRequired:411,PreconditionFailed:412,PayloadTooLarge:413,UriTooLong:414,UnsupportedMediaType:415,RangeNotSatisfiable:416,ExpectationFailed:417,ImATeapot:418,MisdirectedRequest:421,UnprocessableEntity:422,Locked:423,FailedDependency:424,TooEarly:425,UpgradeRequired:426,PreconditionRequired:428,TooManyRequests:429,RequestHeaderFieldsTooLarge:431,UnavailableForLegalReasons:451,InternalServerError:500,NotImplemented:501,BadGateway:502,ServiceUnavailable:503,GatewayTimeout:504,HttpVersionNotSupported:505,VariantAlsoNegotiates:506,InsufficientStorage:507,LoopDetected:508,NotExtended:510,NetworkAuthenticationRequired:511};Object.entries(Rt).forEach((([e,t])=>{Rt[t]=e}));var Ft=Rt;function Dt(e){const t=new _t(e),n=r(_t.prototype.request,t);return re.extend(n,_t.prototype,t,{allOwnKeys:!0}),re.extend(n,t,null,{allOwnKeys:!0}),n.create=function(t){return Dt(xt(e,t))},n}const Mt=Dt(ze);Mt.Axios=_t,Mt.CanceledError=tt,Mt.CancelToken=Et,Mt.isCancel=Qe,Mt.VERSION=vt,Mt.toFormData=me,Mt.AxiosError=oe,Mt.Cancel=Mt.CanceledError,Mt.all=function(e){return Promise.all(e)},Mt.spread=At,Mt.isAxiosError=$t,Mt.mergeConfig=xt,Mt.AxiosHeaders=Ye,Mt.formToJSON=e=>Me(re.isHTMLForm(e)?new FormData(e):e),Mt.HttpStatusCode=Ft,Mt.default=Mt;var Ot=Mt},2483:function(e,t,n){"use strict";n.d(t,{p7:function(){return nt},r5:function(){return B}});n(7658),n(541);var r=n(3396),a=n(4870);
/*!
  * vue-router v4.1.6
  * (c) 2022 Eduardo San Martin Morote
  * @license MIT
  */
const s="undefined"!==typeof window;function i(e){return e.__esModule||"Module"===e[Symbol.toStringTag]}const o=Object.assign;function l(e,t){const n={};for(const r in t){const a=t[r];n[r]=p(a)?a.map(e):e(a)}return n}const u=()=>{},p=Array.isArray;const c=/\/$/,d=e=>e.replace(c,"");function h(e,t,n="/"){let r,a={},s="",i="";const o=t.indexOf("#");let l=t.indexOf("?");return o<l&&o>=0&&(l=-1),l>-1&&(r=t.slice(0,l),s=t.slice(l+1,o>-1?o:t.length),a=e(s)),o>-1&&(r=r||t.slice(0,o),i=t.slice(o,t.length)),r=w(null!=r?r:t,n),{fullPath:r+(s&&"?")+s+i,path:r,query:a,hash:i}}function f(e,t){const n=t.query?e(t.query):"";return t.path+(n&&"?")+n+(t.hash||"")}function m(e,t){return t&&e.toLowerCase().startsWith(t.toLowerCase())?e.slice(t.length)||"/":e}function g(e,t,n){const r=t.matched.length-1,a=n.matched.length-1;return r>-1&&r===a&&y(t.matched[r],n.matched[a])&&b(t.params,n.params)&&e(t.query)===e(n.query)&&t.hash===n.hash}function y(e,t){return(e.aliasOf||e)===(t.aliasOf||t)}function b(e,t){if(Object.keys(e).length!==Object.keys(t).length)return!1;for(const n in e)if(!x(e[n],t[n]))return!1;return!0}function x(e,t){return p(e)?v(e,t):p(t)?v(t,e):e===t}function v(e,t){return p(t)?e.length===t.length&&e.every(((e,n)=>e===t[n])):1===e.length&&e[0]===t}function w(e,t){if(e.startsWith("/"))return e;if(!e)return t;const n=t.split("/"),r=e.split("/");let a,s,i=n.length-1;for(a=0;a<r.length;a++)if(s=r[a],"."!==s){if(".."!==s)break;i>1&&i--}return n.slice(0,i).join("/")+"/"+r.slice(a-(a===r.length?1:0)).join("/")}var k,I;(function(e){e["pop"]="pop",e["push"]="push"})(k||(k={})),function(e){e["back"]="back",e["forward"]="forward",e["unknown"]=""}(I||(I={}));function S(e){if(!e)if(s){const t=document.querySelector("base");e=t&&t.getAttribute("href")||"/",e=e.replace(/^\w+:\/\/[^\/]+/,"")}else e="/";return"/"!==e[0]&&"#"!==e[0]&&(e="/"+e),d(e)}const N=/^[^#]+#/;function T(e,t){return e.replace(N,"#")+t}function _(e,t){const n=document.documentElement.getBoundingClientRect(),r=e.getBoundingClientRect();return{behavior:t.behavior,left:r.left-n.left-(t.left||0),top:r.top-n.top-(t.top||0)}}const C=()=>({left:window.pageXOffset,top:window.pageYOffset});function E(e){let t;if("el"in e){const n=e.el,r="string"===typeof n&&n.startsWith("#");0;const a="string"===typeof n?r?document.getElementById(n.slice(1)):document.querySelector(n):n;if(!a)return;t=_(a,e)}else t=e;"scrollBehavior"in document.documentElement.style?window.scrollTo(t):window.scrollTo(null!=t.left?t.left:window.pageXOffset,null!=t.top?t.top:window.pageYOffset)}function A(e,t){const n=history.state?history.state.position-t:-1;return n+e}const $=new Map;function R(e,t){$.set(e,t)}function F(e){const t=$.get(e);return $.delete(e),t}let D=()=>location.protocol+"//"+location.host;function M(e,t){const{pathname:n,search:r,hash:a}=t,s=e.indexOf("#");if(s>-1){let t=a.includes(e.slice(s))?e.slice(s).length:1,n=a.slice(t);return"/"!==n[0]&&(n="/"+n),m(n,"")}const i=m(n,e);return i+r+a}function O(e,t,n,r){let a=[],s=[],i=null;const l=({state:s})=>{const o=M(e,location),l=n.value,u=t.value;let p=0;if(s){if(n.value=o,t.value=s,i&&i===l)return void(i=null);p=u?s.position-u.position:0}else r(o);a.forEach((e=>{e(n.value,l,{delta:p,type:k.pop,direction:p?p>0?I.forward:I.back:I.unknown})}))};function u(){i=n.value}function p(e){a.push(e);const t=()=>{const t=a.indexOf(e);t>-1&&a.splice(t,1)};return s.push(t),t}function c(){const{history:e}=window;e.state&&e.replaceState(o({},e.state,{scroll:C()}),"")}function d(){for(const e of s)e();s=[],window.removeEventListener("popstate",l),window.removeEventListener("beforeunload",c)}return window.addEventListener("popstate",l),window.addEventListener("beforeunload",c),{pauseListeners:u,listen:p,destroy:d}}function P(e,t,n,r=!1,a=!1){return{back:e,current:t,forward:n,replaced:r,position:window.history.length,scroll:a?C():null}}function L(e){const{history:t,location:n}=window,r={value:M(e,n)},a={value:t.state};function s(r,s,i){const o=e.indexOf("#"),l=o>-1?(n.host&&document.querySelector("base")?e:e.slice(o))+r:D()+e+r;try{t[i?"replaceState":"pushState"](s,"",l),a.value=s}catch(u){console.error(u),n[i?"replace":"assign"](l)}}function i(e,n){const i=o({},t.state,P(a.value.back,e,a.value.forward,!0),n,{position:a.value.position});s(e,i,!0),r.value=e}function l(e,n){const i=o({},a.value,t.state,{forward:e,scroll:C()});s(i.current,i,!0);const l=o({},P(r.value,e,null),{position:i.position+1},n);s(e,l,!1),r.value=e}return a.value||s(r.value,{back:null,current:r.value,forward:null,position:t.length-1,replaced:!0,scroll:null},!0),{location:r,state:a,push:l,replace:i}}function z(e){e=S(e);const t=L(e),n=O(e,t.state,t.location,t.replace);function r(e,t=!0){t||n.pauseListeners(),history.go(e)}const a=o({location:"",base:e,go:r,createHref:T.bind(null,e)},t,n);return Object.defineProperty(a,"location",{enumerable:!0,get:()=>t.location.value}),Object.defineProperty(a,"state",{enumerable:!0,get:()=>t.state.value}),a}function B(e){return e=location.host?e||location.pathname+location.search:"",e.includes("#")||(e+="#"),z(e)}function W(e){return"string"===typeof e||e&&"object"===typeof e}function U(e){return"string"===typeof e||"symbol"===typeof e}const V={path:"/",name:void 0,params:{},query:{},hash:"",fullPath:"/",matched:[],meta:{},redirectedFrom:void 0},G=Symbol("");var H;(function(e){e[e["aborted"]=4]="aborted",e[e["cancelled"]=8]="cancelled",e[e["duplicated"]=16]="duplicated"})(H||(H={}));function j(e,t){return o(new Error,{type:e,[G]:!0},t)}function q(e,t){return e instanceof Error&&G in e&&(null==t||!!(e.type&t))}const K="[^/]+?",X={sensitive:!1,strict:!1,start:!0,end:!0},J=/[.+*?^${}()[\]/\\]/g;function Y(e,t){const n=o({},X,t),r=[];let a=n.start?"^":"";const s=[];for(const o of e){const e=o.length?[]:[90];n.strict&&!o.length&&(a+="/");for(let t=0;t<o.length;t++){const r=o[t];let i=40+(n.sensitive?.25:0);if(0===r.type)t||(a+="/"),a+=r.value.replace(J,"\\$&"),i+=40;else if(1===r.type){const{value:e,repeatable:n,optional:l,regexp:u}=r;s.push({name:e,repeatable:n,optional:l});const p=u||K;if(p!==K){i+=10;try{new RegExp(`(${p})`)}catch(c){throw new Error(`Invalid custom RegExp for param "${e}" (${p}): `+c.message)}}let d=n?`((?:${p})(?:/(?:${p}))*)`:`(${p})`;t||(d=l&&o.length<2?`(?:/${d})`:"/"+d),l&&(d+="?"),a+=d,i+=20,l&&(i+=-8),n&&(i+=-20),".*"===p&&(i+=-50)}e.push(i)}r.push(e)}if(n.strict&&n.end){const e=r.length-1;r[e][r[e].length-1]+=.7000000000000001}n.strict||(a+="/?"),n.end?a+="$":n.strict&&(a+="(?:/|$)");const i=new RegExp(a,n.sensitive?"":"i");function l(e){const t=e.match(i),n={};if(!t)return null;for(let r=1;r<t.length;r++){const e=t[r]||"",a=s[r-1];n[a.name]=e&&a.repeatable?e.split("/"):e}return n}function u(t){let n="",r=!1;for(const a of e){r&&n.endsWith("/")||(n+="/"),r=!1;for(const e of a)if(0===e.type)n+=e.value;else if(1===e.type){const{value:s,repeatable:i,optional:o}=e,l=s in t?t[s]:"";if(p(l)&&!i)throw new Error(`Provided param "${s}" is an array but it is not repeatable (* or + modifiers)`);const u=p(l)?l.join("/"):l;if(!u){if(!o)throw new Error(`Missing required param "${s}"`);a.length<2&&(n.endsWith("/")?n=n.slice(0,-1):r=!0)}n+=u}}return n||"/"}return{re:i,score:r,keys:s,parse:l,stringify:u}}function Z(e,t){let n=0;while(n<e.length&&n<t.length){const r=t[n]-e[n];if(r)return r;n++}return e.length<t.length?1===e.length&&80===e[0]?-1:1:e.length>t.length?1===t.length&&80===t[0]?1:-1:0}function Q(e,t){let n=0;const r=e.score,a=t.score;while(n<r.length&&n<a.length){const e=Z(r[n],a[n]);if(e)return e;n++}if(1===Math.abs(a.length-r.length)){if(ee(r))return 1;if(ee(a))return-1}return a.length-r.length}function ee(e){const t=e[e.length-1];return e.length>0&&t[t.length-1]<0}const te={type:0,value:""},ne=/[a-zA-Z0-9_]/;function re(e){if(!e)return[[]];if("/"===e)return[[te]];if(!e.startsWith("/"))throw new Error(`Invalid path "${e}"`);function t(e){throw new Error(`ERR (${n})/"${u}": ${e}`)}let n=0,r=n;const a=[];let s;function i(){s&&a.push(s),s=[]}let o,l=0,u="",p="";function c(){u&&(0===n?s.push({type:0,value:u}):1===n||2===n||3===n?(s.length>1&&("*"===o||"+"===o)&&t(`A repeatable param (${u}) must be alone in its segment. eg: '/:ids+.`),s.push({type:1,value:u,regexp:p,repeatable:"*"===o||"+"===o,optional:"*"===o||"?"===o})):t("Invalid state to consume buffer"),u="")}function d(){u+=o}while(l<e.length)if(o=e[l++],"\\"!==o||2===n)switch(n){case 0:"/"===o?(u&&c(),i()):":"===o?(c(),n=1):d();break;case 4:d(),n=r;break;case 1:"("===o?n=2:ne.test(o)?d():(c(),n=0,"*"!==o&&"?"!==o&&"+"!==o&&l--);break;case 2:")"===o?"\\"==p[p.length-1]?p=p.slice(0,-1)+o:n=3:p+=o;break;case 3:c(),n=0,"*"!==o&&"?"!==o&&"+"!==o&&l--,p="";break;default:t("Unknown state");break}else r=n,n=4;return 2===n&&t(`Unfinished custom RegExp for param "${u}"`),c(),i(),a}function ae(e,t,n){const r=Y(re(e.path),n);const a=o(r,{record:e,parent:t,children:[],alias:[]});return t&&!a.record.aliasOf===!t.record.aliasOf&&t.children.push(a),a}function se(e,t){const n=[],r=new Map;function a(e){return r.get(e)}function s(e,n,r){const a=!r,l=oe(e);l.aliasOf=r&&r.record;const c=ce(t,e),d=[l];if("alias"in e){const t="string"===typeof e.alias?[e.alias]:e.alias;for(const e of t)d.push(o({},l,{components:r?r.record.components:l.components,path:e,aliasOf:r?r.record:l}))}let h,f;for(const t of d){const{path:o}=t;if(n&&"/"!==o[0]){const e=n.record.path,r="/"===e[e.length-1]?"":"/";t.path=n.record.path+(o&&r+o)}if(h=ae(t,n,c),r?r.alias.push(h):(f=f||h,f!==h&&f.alias.push(h),a&&e.name&&!ue(h)&&i(e.name)),l.children){const e=l.children;for(let t=0;t<e.length;t++)s(e[t],h,r&&r.children[t])}r=r||h,(h.record.components&&Object.keys(h.record.components).length||h.record.name||h.record.redirect)&&p(h)}return f?()=>{i(f)}:u}function i(e){if(U(e)){const t=r.get(e);t&&(r.delete(e),n.splice(n.indexOf(t),1),t.children.forEach(i),t.alias.forEach(i))}else{const t=n.indexOf(e);t>-1&&(n.splice(t,1),e.record.name&&r.delete(e.record.name),e.children.forEach(i),e.alias.forEach(i))}}function l(){return n}function p(e){let t=0;while(t<n.length&&Q(e,n[t])>=0&&(e.record.path!==n[t].record.path||!de(e,n[t])))t++;n.splice(t,0,e),e.record.name&&!ue(e)&&r.set(e.record.name,e)}function c(e,t){let a,s,i,l={};if("name"in e&&e.name){if(a=r.get(e.name),!a)throw j(1,{location:e});0,i=a.record.name,l=o(ie(t.params,a.keys.filter((e=>!e.optional)).map((e=>e.name))),e.params&&ie(e.params,a.keys.map((e=>e.name)))),s=a.stringify(l)}else if("path"in e)s=e.path,a=n.find((e=>e.re.test(s))),a&&(l=a.parse(s),i=a.record.name);else{if(a=t.name?r.get(t.name):n.find((e=>e.re.test(t.path))),!a)throw j(1,{location:e,currentLocation:t});i=a.record.name,l=o({},t.params,e.params),s=a.stringify(l)}const u=[];let p=a;while(p)u.unshift(p.record),p=p.parent;return{name:i,path:s,params:l,matched:u,meta:pe(u)}}return t=ce({strict:!1,end:!0,sensitive:!1},t),e.forEach((e=>s(e))),{addRoute:s,resolve:c,removeRoute:i,getRoutes:l,getRecordMatcher:a}}function ie(e,t){const n={};for(const r of t)r in e&&(n[r]=e[r]);return n}function oe(e){return{path:e.path,redirect:e.redirect,name:e.name,meta:e.meta||{},aliasOf:void 0,beforeEnter:e.beforeEnter,props:le(e),children:e.children||[],instances:{},leaveGuards:new Set,updateGuards:new Set,enterCallbacks:{},components:"components"in e?e.components||null:e.component&&{default:e.component}}}function le(e){const t={},n=e.props||!1;if("component"in e)t.default=n;else for(const r in e.components)t[r]="boolean"===typeof n?n:n[r];return t}function ue(e){while(e){if(e.record.aliasOf)return!0;e=e.parent}return!1}function pe(e){return e.reduce(((e,t)=>o(e,t.meta)),{})}function ce(e,t){const n={};for(const r in e)n[r]=r in t?t[r]:e[r];return n}function de(e,t){return t.children.some((t=>t===e||de(e,t)))}const he=/#/g,fe=/&/g,me=/\//g,ge=/=/g,ye=/\?/g,be=/\+/g,xe=/%5B/g,ve=/%5D/g,we=/%5E/g,ke=/%60/g,Ie=/%7B/g,Se=/%7C/g,Ne=/%7D/g,Te=/%20/g;function _e(e){return encodeURI(""+e).replace(Se,"|").replace(xe,"[").replace(ve,"]")}function Ce(e){return _e(e).replace(Ie,"{").replace(Ne,"}").replace(we,"^")}function Ee(e){return _e(e).replace(be,"%2B").replace(Te,"+").replace(he,"%23").replace(fe,"%26").replace(ke,"`").replace(Ie,"{").replace(Ne,"}").replace(we,"^")}function Ae(e){return Ee(e).replace(ge,"%3D")}function $e(e){return _e(e).replace(he,"%23").replace(ye,"%3F")}function Re(e){return null==e?"":$e(e).replace(me,"%2F")}function Fe(e){try{return decodeURIComponent(""+e)}catch(t){}return""+e}function De(e){const t={};if(""===e||"?"===e)return t;const n="?"===e[0],r=(n?e.slice(1):e).split("&");for(let a=0;a<r.length;++a){const e=r[a].replace(be," "),n=e.indexOf("="),s=Fe(n<0?e:e.slice(0,n)),i=n<0?null:Fe(e.slice(n+1));if(s in t){let e=t[s];p(e)||(e=t[s]=[e]),e.push(i)}else t[s]=i}return t}function Me(e){let t="";for(let n in e){const r=e[n];if(n=Ae(n),null==r){void 0!==r&&(t+=(t.length?"&":"")+n);continue}const a=p(r)?r.map((e=>e&&Ee(e))):[r&&Ee(r)];a.forEach((e=>{void 0!==e&&(t+=(t.length?"&":"")+n,null!=e&&(t+="="+e))}))}return t}function Oe(e){const t={};for(const n in e){const r=e[n];void 0!==r&&(t[n]=p(r)?r.map((e=>null==e?null:""+e)):null==r?r:""+r)}return t}const Pe=Symbol(""),Le=Symbol(""),ze=Symbol(""),Be=Symbol(""),We=Symbol("");function Ue(){let e=[];function t(t){return e.push(t),()=>{const n=e.indexOf(t);n>-1&&e.splice(n,1)}}function n(){e=[]}return{add:t,list:()=>e,reset:n}}function Ve(e,t,n,r,a){const s=r&&(r.enterCallbacks[a]=r.enterCallbacks[a]||[]);return()=>new Promise(((i,o)=>{const l=e=>{!1===e?o(j(4,{from:n,to:t})):e instanceof Error?o(e):W(e)?o(j(2,{from:t,to:e})):(s&&r.enterCallbacks[a]===s&&"function"===typeof e&&s.push(e),i())},u=e.call(r&&r.instances[a],t,n,l);let p=Promise.resolve(u);e.length<3&&(p=p.then(l)),p.catch((e=>o(e)))}))}function Ge(e,t,n,r){const a=[];for(const s of e){0;for(const e in s.components){let o=s.components[e];if("beforeRouteEnter"===t||s.instances[e])if(He(o)){const i=o.__vccOpts||o,l=i[t];l&&a.push(Ve(l,n,r,s,e))}else{let l=o();0,a.push((()=>l.then((a=>{if(!a)return Promise.reject(new Error(`Couldn't resolve component "${e}" at "${s.path}"`));const o=i(a)?a.default:a;s.components[e]=o;const l=o.__vccOpts||o,u=l[t];return u&&Ve(u,n,r,s,e)()}))))}}}return a}function He(e){return"object"===typeof e||"displayName"in e||"props"in e||"__vccOpts"in e}function je(e){const t=(0,r.f3)(ze),n=(0,r.f3)(Be),s=(0,r.Fl)((()=>t.resolve((0,a.SU)(e.to)))),i=(0,r.Fl)((()=>{const{matched:e}=s.value,{length:t}=e,r=e[t-1],a=n.matched;if(!r||!a.length)return-1;const i=a.findIndex(y.bind(null,r));if(i>-1)return i;const o=Ye(e[t-2]);return t>1&&Ye(r)===o&&a[a.length-1].path!==o?a.findIndex(y.bind(null,e[t-2])):i})),o=(0,r.Fl)((()=>i.value>-1&&Je(n.params,s.value.params))),l=(0,r.Fl)((()=>i.value>-1&&i.value===n.matched.length-1&&b(n.params,s.value.params)));function p(n={}){return Xe(n)?t[(0,a.SU)(e.replace)?"replace":"push"]((0,a.SU)(e.to)).catch(u):Promise.resolve()}return{route:s,href:(0,r.Fl)((()=>s.value.href)),isActive:o,isExactActive:l,navigate:p}}const qe=(0,r.aZ)({name:"RouterLink",compatConfig:{MODE:3},props:{to:{type:[String,Object],required:!0},replace:Boolean,activeClass:String,exactActiveClass:String,custom:Boolean,ariaCurrentValue:{type:String,default:"page"}},useLink:je,setup(e,{slots:t}){const n=(0,a.qj)(je(e)),{options:s}=(0,r.f3)(ze),i=(0,r.Fl)((()=>({[Ze(e.activeClass,s.linkActiveClass,"router-link-active")]:n.isActive,[Ze(e.exactActiveClass,s.linkExactActiveClass,"router-link-exact-active")]:n.isExactActive})));return()=>{const a=t.default&&t.default(n);return e.custom?a:(0,r.h)("a",{"aria-current":n.isExactActive?e.ariaCurrentValue:null,href:n.href,onClick:n.navigate,class:i.value},a)}}}),Ke=qe;function Xe(e){if(!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey)&&!e.defaultPrevented&&(void 0===e.button||0===e.button)){if(e.currentTarget&&e.currentTarget.getAttribute){const t=e.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(t))return}return e.preventDefault&&e.preventDefault(),!0}}function Je(e,t){for(const n in t){const r=t[n],a=e[n];if("string"===typeof r){if(r!==a)return!1}else if(!p(a)||a.length!==r.length||r.some(((e,t)=>e!==a[t])))return!1}return!0}function Ye(e){return e?e.aliasOf?e.aliasOf.path:e.path:""}const Ze=(e,t,n)=>null!=e?e:null!=t?t:n,Qe=(0,r.aZ)({name:"RouterView",inheritAttrs:!1,props:{name:{type:String,default:"default"},route:Object},compatConfig:{MODE:3},setup(e,{attrs:t,slots:n}){const s=(0,r.f3)(We),i=(0,r.Fl)((()=>e.route||s.value)),l=(0,r.f3)(Le,0),u=(0,r.Fl)((()=>{let e=(0,a.SU)(l);const{matched:t}=i.value;let n;while((n=t[e])&&!n.components)e++;return e})),p=(0,r.Fl)((()=>i.value.matched[u.value]));(0,r.JJ)(Le,(0,r.Fl)((()=>u.value+1))),(0,r.JJ)(Pe,p),(0,r.JJ)(We,i);const c=(0,a.iH)();return(0,r.YP)((()=>[c.value,p.value,e.name]),(([e,t,n],[r,a,s])=>{t&&(t.instances[n]=e,a&&a!==t&&e&&e===r&&(t.leaveGuards.size||(t.leaveGuards=a.leaveGuards),t.updateGuards.size||(t.updateGuards=a.updateGuards))),!e||!t||a&&y(t,a)&&r||(t.enterCallbacks[n]||[]).forEach((t=>t(e)))}),{flush:"post"}),()=>{const a=i.value,s=e.name,l=p.value,u=l&&l.components[s];if(!u)return et(n.default,{Component:u,route:a});const d=l.props[s],h=d?!0===d?a.params:"function"===typeof d?d(a):d:null,f=e=>{e.component.isUnmounted&&(l.instances[s]=null)},m=(0,r.h)(u,o({},h,t,{onVnodeUnmounted:f,ref:c}));return et(n.default,{Component:m,route:a})||m}}});function et(e,t){if(!e)return null;const n=e(t);return 1===n.length?n[0]:n}const tt=Qe;function nt(e){const t=se(e.routes,e),n=e.parseQuery||De,i=e.stringifyQuery||Me,c=e.history;const d=Ue(),m=Ue(),y=Ue(),b=(0,a.XI)(V);let x=V;s&&e.scrollBehavior&&"scrollRestoration"in history&&(history.scrollRestoration="manual");const v=l.bind(null,(e=>""+e)),w=l.bind(null,Re),I=l.bind(null,Fe);function S(e,n){let r,a;return U(e)?(r=t.getRecordMatcher(e),a=n):a=e,t.addRoute(a,r)}function N(e){const n=t.getRecordMatcher(e);n&&t.removeRoute(n)}function T(){return t.getRoutes().map((e=>e.record))}function _(e){return!!t.getRecordMatcher(e)}function $(e,r){if(r=o({},r||b.value),"string"===typeof e){const a=h(n,e,r.path),s=t.resolve({path:a.path},r),i=c.createHref(a.fullPath);return o(a,s,{params:I(s.params),hash:Fe(a.hash),redirectedFrom:void 0,href:i})}let a;if("path"in e)a=o({},e,{path:h(n,e.path,r.path).path});else{const t=o({},e.params);for(const e in t)null==t[e]&&delete t[e];a=o({},e,{params:w(e.params)}),r.params=w(r.params)}const s=t.resolve(a,r),l=e.hash||"";s.params=v(I(s.params));const u=f(i,o({},e,{hash:Ce(l),path:s.path})),p=c.createHref(u);return o({fullPath:u,hash:l,query:i===Me?Oe(e.query):e.query||{}},s,{redirectedFrom:void 0,href:p})}function D(e){return"string"===typeof e?h(n,e,b.value.path):o({},e)}function M(e,t){if(x!==e)return j(8,{from:t,to:e})}function O(e){return z(e)}function P(e){return O(o(D(e),{replace:!0}))}function L(e){const t=e.matched[e.matched.length-1];if(t&&t.redirect){const{redirect:n}=t;let r="function"===typeof n?n(e):n;return"string"===typeof r&&(r=r.includes("?")||r.includes("#")?r=D(r):{path:r},r.params={}),o({query:e.query,hash:e.hash,params:"path"in r?{}:e.params},r)}}function z(e,t){const n=x=$(e),r=b.value,a=e.state,s=e.force,l=!0===e.replace,u=L(n);if(u)return z(o(D(u),{state:"object"===typeof u?o({},a,u.state):a,force:s,replace:l}),t||n);const p=n;let c;return p.redirectedFrom=t,!s&&g(i,r,n)&&(c=j(16,{to:p,from:r}),ne(r,r,!0,!1)),(c?Promise.resolve(c):W(p,r)).catch((e=>q(e)?q(e,2)?e:te(e):Q(e,p,r))).then((e=>{if(e){if(q(e,2))return z(o({replace:l},D(e.to),{state:"object"===typeof e.to?o({},a,e.to.state):a,force:s}),t||p)}else e=H(p,r,!0,l,a);return G(p,r,e),e}))}function B(e,t){const n=M(e,t);return n?Promise.reject(n):Promise.resolve()}function W(e,t){let n;const[r,a,s]=at(e,t);n=Ge(r.reverse(),"beforeRouteLeave",e,t);for(const o of r)o.leaveGuards.forEach((r=>{n.push(Ve(r,e,t))}));const i=B.bind(null,e,t);return n.push(i),rt(n).then((()=>{n=[];for(const r of d.list())n.push(Ve(r,e,t));return n.push(i),rt(n)})).then((()=>{n=Ge(a,"beforeRouteUpdate",e,t);for(const r of a)r.updateGuards.forEach((r=>{n.push(Ve(r,e,t))}));return n.push(i),rt(n)})).then((()=>{n=[];for(const r of e.matched)if(r.beforeEnter&&!t.matched.includes(r))if(p(r.beforeEnter))for(const a of r.beforeEnter)n.push(Ve(a,e,t));else n.push(Ve(r.beforeEnter,e,t));return n.push(i),rt(n)})).then((()=>(e.matched.forEach((e=>e.enterCallbacks={})),n=Ge(s,"beforeRouteEnter",e,t),n.push(i),rt(n)))).then((()=>{n=[];for(const r of m.list())n.push(Ve(r,e,t));return n.push(i),rt(n)})).catch((e=>q(e,8)?e:Promise.reject(e)))}function G(e,t,n){for(const r of y.list())r(e,t,n)}function H(e,t,n,r,a){const i=M(e,t);if(i)return i;const l=t===V,u=s?history.state:{};n&&(r||l?c.replace(e.fullPath,o({scroll:l&&u&&u.scroll},a)):c.push(e.fullPath,a)),b.value=e,ne(e,t,n,l),te()}let K;function X(){K||(K=c.listen(((e,t,n)=>{if(!oe.listening)return;const r=$(e),a=L(r);if(a)return void z(o(a,{replace:!0}),r).catch(u);x=r;const i=b.value;s&&R(A(i.fullPath,n.delta),C()),W(r,i).catch((e=>q(e,12)?e:q(e,2)?(z(e.to,r).then((e=>{q(e,20)&&!n.delta&&n.type===k.pop&&c.go(-1,!1)})).catch(u),Promise.reject()):(n.delta&&c.go(-n.delta,!1),Q(e,r,i)))).then((e=>{e=e||H(r,i,!1),e&&(n.delta&&!q(e,8)?c.go(-n.delta,!1):n.type===k.pop&&q(e,20)&&c.go(-1,!1)),G(r,i,e)})).catch(u)})))}let J,Y=Ue(),Z=Ue();function Q(e,t,n){te(e);const r=Z.list();return r.length?r.forEach((r=>r(e,t,n))):console.error(e),Promise.reject(e)}function ee(){return J&&b.value!==V?Promise.resolve():new Promise(((e,t)=>{Y.add([e,t])}))}function te(e){return J||(J=!e,X(),Y.list().forEach((([t,n])=>e?n(e):t())),Y.reset()),e}function ne(t,n,a,i){const{scrollBehavior:o}=e;if(!s||!o)return Promise.resolve();const l=!a&&F(A(t.fullPath,0))||(i||!a)&&history.state&&history.state.scroll||null;return(0,r.Y3)().then((()=>o(t,n,l))).then((e=>e&&E(e))).catch((e=>Q(e,t,n)))}const re=e=>c.go(e);let ae;const ie=new Set,oe={currentRoute:b,listening:!0,addRoute:S,removeRoute:N,hasRoute:_,getRoutes:T,resolve:$,options:e,push:O,replace:P,go:re,back:()=>re(-1),forward:()=>re(1),beforeEach:d.add,beforeResolve:m.add,afterEach:y.add,onError:Z.add,isReady:ee,install(e){const t=this;e.component("RouterLink",Ke),e.component("RouterView",tt),e.config.globalProperties.$router=t,Object.defineProperty(e.config.globalProperties,"$route",{enumerable:!0,get:()=>(0,a.SU)(b)}),s&&!ae&&b.value===V&&(ae=!0,O(c.location).catch((e=>{0})));const n={};for(const a in V)n[a]=(0,r.Fl)((()=>b.value[a]));e.provide(ze,t),e.provide(Be,(0,a.qj)(n)),e.provide(We,b);const i=e.unmount;ie.add(e),e.unmount=function(){ie.delete(e),ie.size<1&&(x=V,K&&K(),K=null,b.value=V,ae=!1,J=!1),i()}}};return oe}function rt(e){return e.reduce(((e,t)=>e.then((()=>t()))),Promise.resolve())}function at(e,t){const n=[],r=[],a=[],s=Math.max(t.matched.length,e.matched.length);for(let i=0;i<s;i++){const s=t.matched[i];s&&(e.matched.find((e=>y(e,s)))?r.push(s):n.push(s));const o=e.matched[i];o&&(t.matched.find((e=>y(e,o)))||a.push(o))}return[n,r,a]}}}]);
//# sourceMappingURL=chunk-vendors.a196a3a4.js.map